/**********************************************************************************************************************
 *  COPYRIGHT
 *  -------------------------------------------------------------------------------------------------------------------
 *  \verbatim
 *  Copyright (c) 2016 by Vector Informatik GmbH.                                             All rights reserved.
 *
 *                This software is copyright protected and proprietary to Vector Informatik GmbH.
 *                Vector Informatik GmbH grants to you only those rights as set out in the license conditions.
 *                All other rights remain with Vector Informatik GmbH.
 *  \endverbatim
 *  -------------------------------------------------------------------------------------------------------------------
 *  FILE DESCRIPTION
 *  -----------------------------------------------------------------------------------------------------------------*/
/**        \file  Dcm.c
 *        \brief  Implementation of DCM core
 *
 *      \details  MICROSAR DCM based on AR 4.0.3
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 *  REVISION HISTORY
 *  -------------------------------------------------------------------------------------------------------------------
 *  Refer to the module's header file.
 *
 *  FILE VERSION
 *  -------------------------------------------------------------------------------------------------------------------
 *  Refer to the VERSION CHECK below.
 *********************************************************************************************************************/
#define DCM_SOURCE
/* ----------------------------------------------
 ~&&&   Includes
---------------------------------------------- */
                                                                                                                                                     /* PRQA S 0857, 0828 EOF */ /* MD_MSR_1.1_857, MD_MSR_1.1_828 */
#include "Dcm.h"
#include "Dcm_Int.h"
#include "Rte_Dcm.h"
#include "SchM_Dcm.h"
#if ((DCM_UTI_NVM_READ_ENABLED == STD_ON) || \
    (DCM_UTI_NVM_WRITE_ENABLED == STD_ON))                                                                                                           /* COV_DCM_UNSUPPORTED XF xf xf */
# include "NvM.h"
#endif /* ((DCM_UTI_NVM_READ_ENABLED == STD_ON) || \
 (DCM_UTI_NVM_WRITE_ENABLED == STD_ON)) */
#if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                 /* COV_DCM_SUPPORT_ALWAYS TX */
# include "Det.h"
#endif /* (DCM_DEV_ERROR_DETECT == STD_ON) */
#include "PduR_Dcm.h"
#include "ComM_Dcm.h"
#if ((DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON) || \
    (DCM_SVC_28_SUPPORT_ENABLED == STD_ON))
# include "BswM_Dcm.h"
#endif /* ((DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON) || \
 (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)) */
#if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON)
# include "EcuM_Error.h"
#endif /* (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON) */
#if (((DCM_SVC_02_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_03_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_04_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_07_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)) && (DCM_DEM_API_403_ENABLED == STD_ON))                                                                  /* COV_DCM_SUPPORT_PARTIALLY XF xf xf xf xf xf tf tf tf xf */
# include "Dem.h"
#endif /* (((DCM_SVC_02_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_03_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_04_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_07_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)) && (DCM_DEM_API_403_ENABLED == STD_ON)) */
#if (((DCM_SVC_02_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_03_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_04_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_07_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)) && ((DCM_DEM_API_412_ENABLED == STD_ON) || (DCM_DEM_API_421_ENABLED == STD_ON)))                         /* COV_DCM_SUPPORT_PARTIALLY TF xf xf xf xf xf tf tf tf tf tf */
# include "Dem_Dcm.h"
#endif /* (((DCM_SVC_02_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_03_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_04_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_07_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) || \
 (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)) && ((DCM_DEM_API_412_ENABLED == STD_ON) || (DCM_DEM_API_421_ENABLED == STD_ON))) */
/* ----------------------------------------------
 ~&&&   Versions
---------------------------------------------- */
#if ((DCM_SW_MAJOR_VERSION !=  7u) || \
    (DCM_SW_MINOR_VERSION !=  1u) || \
    (DCM_SW_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm.h are inconsistent"
#endif
#if ((DCM_CBK_MAJOR_VERSION !=  7u) || \
    (DCM_CBK_MINOR_VERSION !=  1u) || \
    (DCM_CBK_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_Cbk.h are inconsistent"
#endif
#if ((DCM_TYPES_MAJOR_VERSION !=  7u) || \
    (DCM_TYPES_MINOR_VERSION !=  1u) || \
    (DCM_TYPES_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_Types.h are inconsistent"
#endif
#if ((DCM_INT_MAJOR_VERSION !=  7u) || \
    (DCM_INT_MINOR_VERSION !=  1u) || \
    (DCM_INT_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_Int.h are inconsistent"
#endif
#if ((DCM_CORE_MAJOR_VERSION !=  7u) || \
    (DCM_CORE_MINOR_VERSION !=  1u) || \
    (DCM_CORE_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_Core.h are inconsistent"
#endif
#if ((DCM_CORECBK_MAJOR_VERSION !=  7u) || \
    (DCM_CORECBK_MINOR_VERSION !=  1u) || \
    (DCM_CORECBK_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_CoreCbk.h are inconsistent"
#endif
#if ((DCM_CORETYPES_MAJOR_VERSION !=  7u) || \
    (DCM_CORETYPES_MINOR_VERSION !=  1u) || \
    (DCM_CORETYPES_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_CoreTypes.h are inconsistent"
#endif
#if ((DCM_COREINT_MAJOR_VERSION !=  7u) || \
    (DCM_COREINT_MINOR_VERSION !=  1u) || \
    (DCM_COREINT_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_CoreInt.h are inconsistent"
#endif
#if ((DCM_EXT_MAJOR_VERSION !=  7u) || \
    (DCM_EXT_MINOR_VERSION !=  1u) || \
    (DCM_EXT_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_Ext.h are inconsistent"
#endif
#if ((DCM_EXTCBK_MAJOR_VERSION !=  7u) || \
    (DCM_EXTCBK_MINOR_VERSION !=  1u) || \
    (DCM_EXTCBK_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_ExtCbk.h are inconsistent"
#endif
#if ((DCM_EXTTYPES_MAJOR_VERSION !=  7u) || \
    (DCM_EXTTYPES_MINOR_VERSION !=  1u) || \
    (DCM_EXTTYPES_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_ExtTypes.h are inconsistent"
#endif
#if ((DCM_EXTINT_MAJOR_VERSION !=  7u) || \
    (DCM_EXTINT_MINOR_VERSION !=  1u) || \
    (DCM_EXTINT_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_ExtInt.h are inconsistent"
#endif
#if ((DCM_CFG_MAJOR_VERSION !=  7u) || \
    (DCM_CFG_MINOR_VERSION !=  1u) || \
    (DCM_CFG_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_Cfg.h are inconsistent"
#endif
#if ((DCM_LCFG_MAJOR_VERSION !=  7u) || \
    (DCM_LCFG_MINOR_VERSION !=  1u) || \
    (DCM_LCFG_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_Lcfg.h are inconsistent"
#endif
#if ((DCM_PBCFG_MAJOR_VERSION !=  7u) || \
    (DCM_PBCFG_MINOR_VERSION !=  1u) || \
    (DCM_PBCFG_PATCH_VERSION !=  0u))
# error "Vendor specific version numbers of Dcm.c and Dcm_PBcfg.h are inconsistent"
#endif
/* ----------------------------------------------
 ~&&&   Switches
---------------------------------------------- */
#if (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
/* Verify consistency between DCM and DEM configurations. 
 * In case of error, please refer to the DCM technical reference (search for the error text) for more information and solution.
 */
# if defined(DEM_CFG_SUPPORT_DTR)
#  if (DEM_CFG_SUPPORT_DTR == STD_ON)
#   if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DCM_ENABLED == STD_ON)
#    error "DCM configured to handle OBD DID MIDs via DCM configuration, but MID handling is done by DEM."
#   endif
#  else
#   if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
#    error "DCM configured to handle OBD DID MIDs via DEM configuration, but no MID handling is done by DEM."
#   endif
#  endif
# endif
#endif /* (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                         /* COV_DCM_UNSUPPORTED XF */
# if (DCM_SVC_01_SUPPORT_ENABLED == STD_ON) || \
     (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON) || \
     (DCM_SVC_08_SUPPORT_ENABLED == STD_ON) || \
     (DCM_SVC_09_SUPPORT_ENABLED == STD_ON)
#  define DCM_OBDIDMGR_REQ_PARSER_ENABLED                            STD_ON
# else
#  define DCM_OBDIDMGR_REQ_PARSER_ENABLED                            STD_OFF
# endif
#endif /* (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) || \
    (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF xf xf */
# define DCM_UTI_LOOKUP_U16_ENABLED                                  STD_ON
#else
# define DCM_UTI_LOOKUP_U16_ENABLED                                  STD_OFF
#endif

#if (DCM_DIDMGR_RANGE_SUPPORT_ENABLED == STD_ON)                                                                                                     /* COV_DCM_UNSUPPORTED XF */
# define DCM_UTI_LOOKUP_RANGE_U16_ENABLED                            STD_ON
#else
# define DCM_UTI_LOOKUP_RANGE_U16_ENABLED                            STD_OFF
#endif
#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
# define DCM_NET_CONN_LOCK_ENABLED                                   STD_ON
#else
# define DCM_NET_CONN_LOCK_ENABLED                                   STD_OFF
#endif

#if (DCM_NET_PERIODIC_TX_HIPERF_ENABLED    == STD_OFF) && \
    (DCM_NET_MULTI_PERIODIC_TX_OBJ_ENABLED == STD_ON)                                                                                                /* COV_DCM_UNSUPPORTED XF tx xf*/
# define DCM_NET_PTXOBJ_LIMITER_ENABLED                              STD_ON
#else
# define DCM_NET_PTXOBJ_LIMITER_ENABLED                              STD_OFF
#endif

#if (DCM_SVC_11_ECU_RESET_ENABLED == STD_ON) || \
    (DCM_SVC_10_RESET_AFTER_RESPONSE == STD_ON) || \
    (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED TF xf tf xf */
# define DCM_NET_RX_BLOCKING_ENABLED                                 STD_ON
#else
# define DCM_NET_RX_BLOCKING_ENABLED                                 STD_OFF
#endif
#if (DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON) || \
    (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON) || \
    (DCM_DIAG_RST2DEF_ON_FUNC_OBD_REQ_ENABLED == STD_ON)                                                                                             /* COV_DCM_UNSUPPORTED TF xf tf xf */
# define DCM_STATE_PEND_SESS_SUPPORT_ENABLED                         STD_ON
#else
# define DCM_STATE_PEND_SESS_SUPPORT_ENABLED                         STD_OFF
#endif
/* derive reentrant scheduling from split task */
#define DCM_TSK_REENTRANT_SCHEDULER_ENABLED                          DCM_SPLIT_TASKS_ENABLED

#define DCM_TSK_TASK_KILL_ENABLED                                    DCM_NET_PROCESSING_CANCELLATION_ENABLED

#if (DCM_TSK_TASK_KILL_ENABLED == STD_ON) && \
    (DCM_TSK_REENTRANT_SCHEDULER_ENABLED == STD_ON)                                                                                                  /* COV_DCM_UNSUPPORTED XF xf tf */
# define DCM_TSK_TASK_COMPLEX_KILL_ENABLED                           STD_ON
#else
# define DCM_TSK_TASK_COMPLEX_KILL_ENABLED                           STD_OFF
#endif

#define DCM_TSK_TASK_FLAG_SUPPORT_ENABLED                            DCM_TSK_TASK_COMPLEX_KILL_ENABLED

#if (DCM_DEV_ERROR_DETECT == STD_ON) && \
    (DCM_STATE_SECURITY_EXT_SETTER_ENABLED == STD_ON)                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TF tx tf */
# define DCM_TSK_TRACING_ENABLED                                     STD_ON
#else
# define DCM_TSK_TRACING_ENABLED                                     STD_OFF
#endif
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF xf xf xf xf */
# define DCM_DIAG_SVC_CONTEXT_ENABLED                                STD_ON
#else
# define DCM_DIAG_SVC_CONTEXT_ENABLED                                STD_OFF
#endif

#if (DCM_NET_PROTOCOL_PRIORITISATION_ENABLED == STD_ON)                                                                                              /* COV_DCM_UNSUPPORTED XF */
# define DCM_DIAG_TOBJ_QUEUE_ENABLED                                 STD_ON
#else
# define DCM_DIAG_TOBJ_QUEUE_ENABLED                                 STD_OFF
#endif

#if (DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON) || \
    (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)                                                                                                 /* COV_DCM_UNSUPPORTED XF xf xf */
# define DCM_DIAG_SYNCH_FLAGS_ENABLED                                STD_ON
#else
# define DCM_DIAG_SYNCH_FLAGS_ENABLED                                STD_OFF
#endif

#if (DCM_DIAG_SYNCH_FLAGS_ENABLED == STD_ON)                                                                                                         /* COV_DCM_UNSUPPORTED XF */
# define DCM_DIAG_PROCESSOR_FLAGS_ENABLED                            STD_ON
#else
# define DCM_DIAG_PROCESSOR_FLAGS_ENABLED                            STD_OFF
#endif

#if (DCM_DIAG_TOBJ_QUEUE_ENABLED    == STD_ON) || \
    (DCM_DIAG_PROCESSOR_FLAGS_ENABLED == STD_ON)                                                                                                     /* COV_DCM_UNSUPPORTED XF xf xf */
# define DCM_DIAG_SYNCH_DATA_SET_ENABLED                             STD_ON
#else
# define DCM_DIAG_SYNCH_DATA_SET_ENABLED                             STD_OFF
#endif

#if (DCM_SVC_10_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_11_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_3E_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_SUPPORT_ALWAYS TX tx xf tf */
# define DCM_DIAG_SF_ONLY_SERVICE_ENABLED                            STD_ON
#else
# define DCM_DIAG_SF_ONLY_SERVICE_ENABLED                            STD_OFF
#endif

#if (DCM_SVC_10_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_11_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_28_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_85_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) || \
    (DCM_SVC_3E_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_SUPPORT_ALWAYS TX tx xf tf xf tf xf tf xf tf */
# define DCM_DIAG_ANY_SERVICE_WITH_SF_ENABLED                        STD_ON
#else
# define DCM_DIAG_ANY_SERVICE_WITH_SF_ENABLED                        STD_OFF
#endif
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON)                                                 /* COV_DCM_UNSUPPORTED XF xf xf */
/* Verify consistency between DCM and DEM configurations. 
 * In case of error, please refer to the DCM technical reference (search for the error text) for more information and solution.
 */
# if defined(DEM_CFG_SUPPORT_DTR)
#  if (DEM_CFG_SUPPORT_DTR == STD_ON)
#  else
#   error "DCM configured to handle OBD MIDs via DEM configuration, but no MID handling is done by DEM."
#  endif
# endif
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON)                                                 /* COV_DCM_UNSUPPORTED XF xf xf */
/* Verify consistency between DCM and DEM configurations. 
 * In case of error, please refer to the DCM technical reference (search for the error text) for more information and solution.
 */
# if defined(DEM_CFG_SUPPORT_DTR)
#  if (DEM_CFG_SUPPORT_DTR == STD_ON)
#   error "DCM configured to handle OBD MIDs via DCM configuration, but MID handling is done by DEM."
#  endif
# endif
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON) */
#if (DCM_SVC_11_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_SVC_11_ECU_RESET_ENABLED == STD_ON) && \
     ( (DCM_SVC_11_USER_ENABLED == STD_ON) || \
     (DCM_SVC_11_RAPID_SHTDWN_ENABLED == STD_ON) )
#  define DCM_SVC_11_ECURESET_EXEC_FILTER_ENABLED                    STD_ON
# else
#  define DCM_SVC_11_ECURESET_EXEC_FILTER_ENABLED                    STD_OFF
# endif
#endif /* (DCM_SVC_11_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
/* DEM API usage optimization */
# if ( (DCM_SVC_19_08_SUPPORT_ENABLED               == STD_ON) || \
     (DCM_SVC_19_14_SUPPORT_ENABLED                 == STD_ON) || \
     (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED      == STD_ON) || \
     (DCM_DEMAPI_SVC_19_GETFFRECORD_ENABLED         == STD_ON ) ) && \
     (DCM_DEM_API_PAGED_BUFFER_ENABLED              == STD_OFF)
#  define DCM_SVC_19_COPY_LINEAR_DATA_ENABLED                        STD_ON
# else
#  define DCM_SVC_19_COPY_LINEAR_DATA_ENABLED                        STD_OFF
# endif

# if (DCM_DEMAPI_SVC_19_GETFFRECORD_ENABLED  == STD_ON) || \
     (DCM_DEMAPI_SVC_19_GETEXTRECORD_ENABLED == STD_ON)
#  define DCM_SVC_19_RECORD_ITER_ENABLED                             STD_ON
# else
#  define DCM_SVC_19_RECORD_ITER_ENABLED                             STD_OFF
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_OCCUR_TIME_ENABLED       == STD_ON) || \
     (DCM_DEMAPI_SVC_19_READ_DTC_EXT_DATA_BY_DTC_NUM_ENABLED == STD_ON) || \
     (DCM_DEMAPI_SVC_19_READ_DTC_CNT_BY_STATUS_MASK_ENABLED  == STD_ON) || \
     (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED      == STD_ON) || \
     (DCM_SVC_19_05_SUPPORT_ENABLED                   == STD_ON) || \
     (DCM_DEMAPI_SVC_19_READ_DTC_FFR_BY_DTC_ENABLED   == STD_ON) || \
     (DCM_SVC_19_08_SUPPORT_ENABLED                   == STD_ON) || \
     (DCM_SVC_19_09_SUPPORT_ENABLED                   == STD_ON) || \
     (DCM_SVC_19_14_SUPPORT_ENABLED                   == STD_ON) || \
     (DCM_SVC_19_42_SUPPORT_ENABLED                   == STD_ON)
#  define DCM_SVC_19_CHAINING_ENABLED                                STD_ON

#  if (DCM_DEMAPI_SVC_19_READ_DTC_BY_OCCUR_TIME_ENABLED == STD_ON) || \
      (DCM_SVC_19_05_SUPPORT_ENABLED             == STD_ON) || \
      (DCM_SVC_19_09_SUPPORT_ENABLED             == STD_ON)
#   define DCM_SVC_19_CHAIN_END_ENABLED                              STD_ON
#  else
#   define DCM_SVC_19_CHAIN_END_ENABLED                              STD_OFF
#  endif
# else
#  define DCM_SVC_19_CHAINING_ENABLED                                STD_OFF
#  define DCM_SVC_19_CHAIN_END_ENABLED                               STD_OFF
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_SVC_27_MULTI_DELAY_TIMER_ENABLED == STD_ON)
#  define DCM_SVC_27_SOFT_TIMER_ENABLED                              STD_ON
# else
#  define DCM_SVC_27_SOFT_TIMER_ENABLED                              STD_OFF
# endif
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/* Consistent configuration checks */
# if (DCM_NET_PERIODIC_TX_ENABLED == STD_OFF)
#  error "Service 0x2A is enabled, but no periodic messages have been configured for Dcm. Please, refer to the Dcm TechRef for SID 0x2A configuration aspect."
# endif
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_SVC_2C_01_SUPPORT_ENABLED != DCM_SVC_2C_02_SUPPORT_ENABLED)
#  define DCM_SVC_2C_HYBRID_MODE_ENABLED                             STD_OFF
# else
#  define DCM_SVC_2C_HYBRID_MODE_ENABLED                             STD_ON
# endif

# if (DCM_SVC_2C_03_SUPPORT_ENABLED == STD_ON)
#  define DCM_SVC_2C_CLEAR_SUPPORT_ENABLED                           STD_ON
# else
#  define DCM_SVC_2C_CLEAR_SUPPORT_ENABLED                           STD_OFF
# endif

# if (DCM_DIDMGR_DYNDID_ASYNC_SUPPORT_ENABLED == STD_ON) && \
     (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON)
#  define DCM_SVC_2C_RACE_CONDITION_READ_ENABLED                     STD_ON
# else
#  define DCM_SVC_2C_RACE_CONDITION_READ_ENABLED                     STD_OFF
# endif

# if (DCM_DIDMGR_DYNDID_ASYNC_SUPPORT_ENABLED == STD_ON) && \
     ( (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON) || \
     (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON) )
#  define DCM_SVC_2C_CANCELOP_READ_ENABLED                           STD_ON
# else
#  define DCM_SVC_2C_CANCELOP_READ_ENABLED                           STD_OFF
# endif

# if (DCM_DIDMGR_PAGED_DID_SUPPORT_ENABLED == STD_ON)
#  error "Service 0x2C is not allowed when any paged DID is configured!"
# endif
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_DIDMGR_IODID_READ_SUPPORT_ENABLED == STD_ON) && \
     (DCM_DIDMGR_IODID_DYNLEN_ENABLED == STD_ON)
#  define DCM_SVC_2F_READ_RES_DATA_LEN_ENABLED                       STD_ON
# else
#  define DCM_SVC_2F_READ_RES_DATA_LEN_ENABLED                       STD_OFF
# endif
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
/* ----------------------------------------------
 ~&&&   Defines
---------------------------------------------- */
#if (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define DCM_MEMMGR_ACCESS_NONE                                      ((Dcm_MemMgrAccessType)0u)
# define DCM_MEMMGR_ACCESS_REQ_EXT                                   ((Dcm_MemMgrAccessType)1u)
# define DCM_MEMMGR_ACCESS_REQ_INT                                   ((Dcm_MemMgrAccessType)2u)

# define DCM_MEMMGR_OP_READ                                          ((Dcm_MemMgrMemoryOpType)0u)
# if (DCM_MEMMGR_MEMOP_READ_ENABLED == STD_ON)
#  define DCM_MEMMGR_OP_WRITE                                        ((Dcm_MemMgrMemoryOpType)(DCM_MEMMGR_OP_READ + 1u))
# else
#  define DCM_MEMMGR_OP_WRITE                                        ((Dcm_MemMgrMemoryOpType)(DCM_MEMMGR_OP_READ + 0u))
# endif
#endif /* (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                         /* COV_DCM_UNSUPPORTED XF */
# define DCM_OBDIDMGR_PFLAG_NONE                                     ((Dcm_ObdIdMgrParserFlagsType)0x00u)
# define DCM_OBDIDMGR_PFLAG_SINGLEDATAID                             ((Dcm_ObdIdMgrParserFlagsType)0x01u)
# define DCM_OBDIDMGR_PFLAG_REQHASDATA                               ((Dcm_ObdIdMgrParserFlagsType)0x02u)
#endif /* (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON) */
#define DCM_NET_COMM_ACTIVE                                          ((Dcm_NetActiveDiagnosticType)TRUE)
#define DCM_NET_COMM_NOT_ACTIVE                                      ((Dcm_NetActiveDiagnosticType)FALSE)

/* network variant abstraction */
#define Dcm_PbCfgNetNumRxPduIds                                      (Dcm_NetCfgGetNumRxPduIds(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumTxPduIds                                      (Dcm_NetCfgGetNumTxPduIds(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetCanTpRxPduIdMin                                  (Dcm_NetCfgGetMinCanTpRxPduId(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetCanTpRxPduIdMax                                  (Dcm_NetCfgGetMaxCanTpRxPduId(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumCanRxPduIds                                   (Dcm_NetCfgGetNumCanRxPduIds(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumPerTxObjects                                  (Dcm_NetCfgGetNumPerTxObjects(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumConnections                                   (Dcm_NetCfgGetNumConnections(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumProtocols                                     (Dcm_NetCfgGetNumProtocols(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumComMChannels                                  (Dcm_NetCfgGetNumComMChannels(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumBuffers                                       (Dcm_NetCfgGetNumBuffers(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumTransportObjects                              (Dcm_NetCfgGetNumTranspObjects(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNumAllComMChannels                               (Dcm_NetCfgGetNumAllComMChannels(DCM_VARMGR_ACTIVE_COMVAR))

#define Dcm_PbCfgNetRxPduInfo                                        (Dcm_NetCfgGetRxPduInfo(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetConnectionInfo                                   (Dcm_NetCfgGetConnectionInfo(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetProtocolInfo                                     (Dcm_NetCfgGetProtocolInfo(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetConnComMChannelMap                               (Dcm_NetCfgGetNetConnComMChannelMap(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetNetworkHdlLookUp                                 (Dcm_NetCfgGetNetworkHdlLookUp(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetTxPdu2ConnMap                                    (Dcm_NetCfgGetTxPdu2ConnMap(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetPerTxPdu2RsrsMap                                 (Dcm_NetCfgGetPerTxPdu2RsrsMap(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetPerTxPduIdInfo                                   (Dcm_NetCfgGetPerTxPduIdInfo(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetComCtrlChannelListAll                            (Dcm_NetCfgGetComCtrlChannelListAll(DCM_VARMGR_ACTIVE_COMVAR))
#define Dcm_PbCfgNetAllComMChannelMap                                (Dcm_NetCfgGetNetAllComMChannelMap(DCM_VARMGR_ACTIVE_COMVAR))

#if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON)
# define Dcm_PbRamNetBufferContext                                   (DCM_VARMGR_ACTIVE_RAMVAR.NetworkRam.BufferContexts)
# define Dcm_PbRamNetTransportObject                                 (DCM_VARMGR_ACTIVE_RAMVAR.NetworkRam.TranspObjects)
# define Dcm_PbRamNetComMContext                                     (DCM_VARMGR_ACTIVE_RAMVAR.NetworkRam.ComMContexts)
# define Dcm_PbRamNetPeriodicTxObject                                (DCM_VARMGR_ACTIVE_RAMVAR.NetworkRam.PeriodicTxObjects)
# define Dcm_PbRamNetConnId2TObjMap                                  (DCM_VARMGR_ACTIVE_RAMVAR.NetworkRam.ConnId2TObjIdMap)
# define Dcm_PbRamNetComCtrlChannels                                 (DCM_VARMGR_ACTIVE_RAMVAR.NetworkRam.ComCtrlChannels)
# define Dcm_PbCfgNetBufferInfo                                      (DCM_VARMGR_ACTIVE_ROMVAR.NetworkRom.BufferInfo)
#else
# define Dcm_PbRamNetBufferContext                                   (Dcm_SingletonContext.Network.BufferContext)
# define Dcm_PbRamNetTransportObject                                 (Dcm_SingletonContext.Network.TransportObject)
# define Dcm_PbRamNetComMContext                                     (Dcm_SingletonContext.Network.ComMContext)
# define Dcm_PbRamNetPeriodicTxObject                                (Dcm_SingletonContext.Network.PeriodicTxContext.TxObject)
# define Dcm_PbRamNetConnId2TObjMap                                  (Dcm_SingletonContext.Network.ConnId2TObjIdMap)
# define Dcm_PbRamNetComCtrlChannels                                 (Dcm_SingletonContext.Network.ComCtrlChannels)
# define Dcm_PbCfgNetBufferInfo                                      Dcm_CfgNetBufferInfo
#endif

#if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)                                                                                                 /* COV_DCM_UNSUPPORTED XF */
# define Dcm_NetGetDcmRxPduIdOfCanTpPduId(canTpPduId)                (Dcm_CfgNetCanTp2DcmRxPduIdMap[(canTpPduId)-DCM_NET_CANTP_RX_PDUID_MIN])        /* PRQA S 3453 */ /* MD_MSR_19.7 */
# if (DCM_NET_CONN_ECUC_ADDRESS_ENABLED == STD_ON)
#  define Dcm_NetGetNodeAddress(connId)                              (Dcm_PbCfgNetConnectionInfo[(connId)].EcuAddress)                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_NetGetNodeAddress(connId)                              ((uint8)DCM_NET_OWN_ECU_NUMBER)                                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif
#else
# define Dcm_NetGetDcmRxPduIdOfCanTpPduId(canTpPduId)                /* not used */
# define Dcm_NetGetNodeAddress(connId)                               /* not used */
#endif

#define Dcm_NetGetP2AdjTime(protocolIdx)                             (Dcm_NetGetProtObjOfProtId(protocolIdx)->SrvAdjTime.P2)                         /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_NetGetP2StarAdjTime(protocolIdx)                         (Dcm_NetGetProtObjOfProtId(protocolIdx)->SrvAdjTime.P2Star)                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DCM_NET_TOBJ_STATE_FREE                                      ((Dcm_NetTransportObjectStateType)0x00u)
#define DCM_NET_TOBJ_STATE_ONRX                                      ((Dcm_NetTransportObjectStateType)0x01u)
#define DCM_NET_TOBJ_STATE_RX_END                                    ((Dcm_NetTransportObjectStateType)0x02u)
#define DCM_NET_TOBJ_STATE_PREPTX                                    ((Dcm_NetTransportObjectStateType)0x04u)
#define DCM_NET_TOBJ_STATE_ONTX                                      ((Dcm_NetTransportObjectStateType)0x08u)
#define DCM_NET_TOBJ_STATE_READY                                     ((Dcm_NetTransportObjectStateType)0x10u)
#define DCM_NET_TOBJ_STATE_RESERVED                                  ((Dcm_NetTransportObjectStateType)0x20u)

#define DCM_NET_TOBJ_FLAG_NONE                                       ((Dcm_NetTransportObjectFlagType)0x00u)
#define DCM_NET_TOBJ_FLAG_INTERNAL                                   ((Dcm_NetTransportObjectFlagType)0x01u)
#define DCM_NET_TOBJ_FLAG_COPYHEAD                                   ((Dcm_NetTransportObjectFlagType)0x02u)
#define DCM_NET_TOBJ_FLAG_BUSY                                       ((Dcm_NetTransportObjectFlagType)0x04u)
#define DCM_NET_TOBJ_FLAG_CANCELED                                   ((Dcm_NetTransportObjectFlagType)0x08u)
#define DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ                               ((Dcm_NetTransportObjectFlagType)0x10u)
#define DCM_NET_TOBJ_FLAG_RCRRP_ON_TX                                ((Dcm_NetTransportObjectFlagType)0x20u)
#define DCM_NET_TOBJ_FLAG_RCRRP_SENT                                 ((Dcm_NetTransportObjectFlagType)0x40u)
#define DCM_NET_TOBJ_FLAG_RCRRP_TYPE_APPL                            ((Dcm_NetTransportObjectFlagType)0x80u)
#define DCM_NET_TOBJ_RESTYPE_NONE                                    ((Dcm_NetResponseType)0u)
#define DCM_NET_TOBJ_RESTYPE_LINEAR                                  ((Dcm_NetResponseType)1u)
#define DCM_NET_TOBJ_RESTYPE_PAGED                                   ((Dcm_NetResponseType)2u)
#define DCM_NET_TOBJ_RESTYPE_RCRRP                                   ((Dcm_NetResponseType)3u)
#define DCM_NET_TOBJ_RESTYPE_BUSY                                    ((Dcm_NetResponseType)4u)
#define DCM_NET_TOBJ_RESTYPE_UNSOLICITED                             ((Dcm_NetResponseType)5u)
#define DCM_NET_TOBJ_RESTYPE_ROE                                     ((Dcm_NetResponseType)6u)
#define DCM_NET_TOBJ_RESTYPE_SIMPLE                                  ((Dcm_NetResponseType)7u)

#define DCM_NET_CONN_PROP_NONE                                       ((Dcm_CfgNetConnPropertiesType)0x00u)
#define DCM_NET_CONN_PROP_TX_ON_FUNC_RX                              ((Dcm_CfgNetConnPropertiesType)0x01u)
#define DCM_NET_CONN_PROP_NO_MAIN_TX                                 ((Dcm_CfgNetConnPropertiesType)0x02u)

#define DCM_NET_INVALID_CONNID                                       ((Dcm_CfgNetNetIdRefMemType)Dcm_PbCfgNetNumConnections)
#define DCM_NET_INVALID_TOBJID                                       ((Dcm_CfgNetTObjHandleMemType)Dcm_PbCfgNetNumTransportObjects)
#define DCM_NET_INVALID_PROTID                                       ((Dcm_CfgNetProtRefMemType)Dcm_PbCfgNetNumProtocols)
/* ECU channel management optimization abstraction */
#define DCM_NETCHNL_COMM_ITER_TYPE                                   Dcm_CfgNetNetIdRefOptType
#define DCM_NETCHNL_COMM_ITER_NAME                                   lChannelIter
#define DCM_NETCHNL_COMM_LOCVAR_TYPE                                 Dcm_CfgNetNetIdRefMemType
#define DCM_NETCHNL_COMM_LOCVAR_NAME                                 lNetHandle

#if(DCM_NET_COMM_MULTI_CHANNEL_ENABLED == STD_ON)
# define DCM_NETCHNL_COMM_LOCVAR_DEF                                 DCM_UTI_VAR_DEF(DCM_NETCHNL_COMM_LOCVAR_TYPE, DCM_NETCHNL_COMM_LOCVAR_NAME)
# define DCM_NETCHNL_COMM_LOCVAR_VALUE                               DCM_NETCHNL_COMM_LOCVAR_NAME

# define DCM_NETCHNL_COMM_ITER_VALUE                                 DCM_NETCHNL_COMM_ITER_NAME
# define DCM_NETCHNL_COMM_ITER_DEF                                   DCM_UTI_VAR_DEF(DCM_NETCHNL_COMM_ITER_TYPE, DCM_NETCHNL_COMM_ITER_NAME)
# define DCM_NETCHNL_COMM_LOOP_FOR_UP                                DCM_UTI_LOOP_FOR_UP(DCM_NETCHNL_COMM_ITER_NAME, 0, Dcm_PbCfgNetNumComMChannels)

# define Dcm_NetChnlIdComMWrpValue(netId)                            (netId)                                                                         /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetChnlIdComMWrpOnly(netId)                             (netId)                                                                         /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetChnlIdComMWrpFirst(netId)                            (netId),                                                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define DCM_NETCHNL_COMM_LOCVAR_DEF                                 /* not used */
# define DCM_NETCHNL_COMM_LOCVAR_VALUE                               0u

# define DCM_NETCHNL_COMM_ITER_DEF                                   /* not used */
# define DCM_NETCHNL_COMM_ITER_VALUE                                 DCM_NETCHNL_COMM_LOCVAR_VALUE
# define DCM_NETCHNL_COMM_LOOP_FOR_UP                                /* not used */

# define Dcm_NetChnlIdComMWrpValue(netId)                            DCM_NETCHNL_COMM_LOCVAR_VALUE
# define Dcm_NetChnlIdComMWrpOnly(netId)                             /* not used */
# define Dcm_NetChnlIdComMWrpFirst(netId)                            /* not used */
#endif

/* Buffer management optimization abstraction */
#define DCM_NETBUF_ITER_TYPE                                         Dcm_CfgNetBufferRefOptType
#define DCM_NETBUF_ITER_NAME                                         lBufferIter
#define DCM_NETBUF_LOCVAR_TYPE                                       Dcm_CfgNetBufferRefMemType
#define DCM_NETBUF_LOCVAR_NAME                                       lBufferHandle

#if(DCM_NET_MULTI_BUFFER_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
# define DCM_NETBUF_LOCVAR_DEF                                       DCM_UTI_VAR_DEF(DCM_NETBUF_LOCVAR_TYPE, DCM_NETBUF_LOCVAR_NAME)
# define DCM_NETBUF_LOCVAR_VALUE                                     DCM_NETBUF_LOCVAR_NAME

# define DCM_NETBUF_ITER_VALUE                                       DCM_NETBUF_ITER_NAME
# define DCM_NETBUF_ITER_DEF                                         DCM_UTI_VAR_DEF(DCM_NETBUF_ITER_TYPE, DCM_NETBUF_ITER_NAME)
# define DCM_NETBUF_LOOP_FOR_UP                                      DCM_UTI_LOOP_FOR_UP(DCM_NETBUF_ITER_NAME, 0, Dcm_PbCfgNetNumBuffers)

# define Dcm_NetBufIdWrpValue(bufHdl)                                (bufHdl)                                                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetBufIdWrpOnly(bufHdl)                                 (bufHdl)                                                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetBufIdWrpFirst(bufHdl)                                (bufHdl),                                                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define DCM_NETBUF_ITER_VALUE                                       DCM_NETBUF_LOCVAR_VALUE
# define DCM_NETBUF_ITER_DEF                                         /* not used */
# define DCM_NETBUF_LOOP_FOR_UP                                      /* not used */

# define DCM_NETBUF_LOCVAR_DEF                                       /* not used */
# define DCM_NETBUF_LOCVAR_VALUE                                     0u

# define Dcm_NetBufIdWrpValue(bufHdl)                                DCM_NETBUF_LOCVAR_VALUE
# define Dcm_NetBufIdWrpOnly(bufHdl)                                 /* not used */
# define Dcm_NetBufIdWrpFirst(bufHdl)                                /* not used */
#endif

/* Network connection management optimization abstraction */
#define DCM_NETCONNID_ITER_TYPE                                      Dcm_NetConnRefOptType
#define DCM_NETCONNID_ITER_NAME                                      lConnIter
#define DCM_NETCONNID_PARAM_TYPE                                     Dcm_NetConnRefMemType
#define DCM_NETCONNID_PARAM_NAME                                     connId
#define DCM_NETCONNID_LOCVAR_TYPE                                    Dcm_NetConnRefMemType
#define DCM_NETCONNID_LOCVAR_NAME                                    lConnId

#if(DCM_NET_MULTI_CONNECT_ENABLED == STD_ON)
# define DCM_NETCONNID_PARAMDEF_ONLY                                 DCM_UTI_PARAM_DEF(DCM_NETCONNID_PARAM_TYPE, DCM_NETCONNID_PARAM_NAME)
# define DCM_NETCONNID_PARAMDEF_FIRST                                DCM_NETCONNID_PARAMDEF_ONLY,
# define DCM_NETCONNID_PARAM_VALUE                                   DCM_NETCONNID_PARAM_NAME
# define DCM_NETCONNID_PARAM_ONLY                                    DCM_NETCONNID_PARAM_NAME
# define DCM_NETCONNID_PARAM_FIRST                                   DCM_NETCONNID_PARAM_NAME,
# define DCM_NETCONNID_LOCVAR_DEF                                    DCM_UTI_VAR_DEF(DCM_NETCONNID_LOCVAR_TYPE, DCM_NETCONNID_LOCVAR_NAME)
# define DCM_NETCONNID_LOCVAR_ONLY                                   DCM_NETCONNID_LOCVAR_NAME
# define DCM_NETCONNID_LOCVAR_FIRST                                  DCM_NETCONNID_LOCVAR_NAME,
# define DCM_NETCONNID_LOCVAR_VALUE                                  DCM_NETCONNID_LOCVAR_NAME

# define DCM_NETCONNID_ITER_DEF                                      DCM_UTI_VAR_DEF(DCM_NETCONNID_ITER_TYPE, DCM_NETCONNID_ITER_NAME)
# define DCM_NETCONNID_LOOP_FOR_UP                                   DCM_UTI_LOOP_FOR_UP(DCM_NETCONNID_ITER_NAME, 0, Dcm_PbCfgNetNumConnections)
# define DCM_NETCONNID_ITER_BREAK                                    break;                                                                          /* PRQA S 3412 */ /* MD_MSR_19.4 */

# define DCM_NETCONNID_ITER_VALUE                                    DCM_NETCONNID_ITER_NAME
# define DCM_NETCONNID_ITER_ONLY                                     DCM_NETCONNID_ITER_NAME
# define DCM_NETCONNID_ITER_FIRST                                    DCM_NETCONNID_ITER_NAME,
# define Dcm_NetConnIdWrpValue(connId)                               (connId)                                                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetConnIdWrpOnly(connId)                                (connId)                                                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetConnIdWrpFirst(connId)                               (connId),                                                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define DCM_NETCONNID_PARAMDEF_ONLY                                 void                                                                            /* PRQA S 3460 */ /* MD_MSR_19.4 */
# define DCM_NETCONNID_PARAMDEF_FIRST                                /* not used */
# define DCM_NETCONNID_PARAM_VALUE                                   (DCM_NETCONNID_PARAM_TYPE)(0u)
# define DCM_NETCONNID_PARAM_ONLY                                    /* not used */
# define DCM_NETCONNID_PARAM_FIRST                                   /* not used */
# define DCM_NETCONNID_LOCVAR_DEF                                    /* not used */
# define DCM_NETCONNID_LOCVAR_ONLY                                   /* not used */
# define DCM_NETCONNID_LOCVAR_FIRST                                  /* not used */
# define DCM_NETCONNID_LOCVAR_VALUE                                  DCM_NETCONNID_PARAM_VALUE

# define DCM_NETCONNID_ITER_VALUE                                    DCM_NETCONNID_PARAM_VALUE
# define DCM_NETCONNID_ITER_DEF                                      /* not used */
# define DCM_NETCONNID_LOOP_FOR_UP                                   /* not used */
# define DCM_NETCONNID_ITER_BREAK                                    /* not used */

# define DCM_NETCONNID_ITER_ONLY                                     DCM_NETCONNID_PARAM_ONLY
# define DCM_NETCONNID_ITER_FIRST                                    DCM_NETCONNID_PARAM_FIRST
# define Dcm_NetConnIdWrpValue(connId)                               DCM_NETCONNID_PARAM_VALUE
# define Dcm_NetConnIdWrpOnly(connId)                                /* not used */
# define Dcm_NetConnIdWrpFirst(connId)                               /* not used */
#endif

/* Transport object management optimization abstraction */
#define DCM_NETTOBJ_ITER_TYPE                                        Dcm_CfgNetTObjHandleOptType
#define DCM_NETTOBJ_ITER_NAME                                        lTObjIter

#define DCM_NETTOBJ_CNTR_TYPE                                        DCM_NETTOBJ_ITER_TYPE
#define DCM_NETTOBJ_CNTR_NAME                                        lTObjCntr

#define DCM_NETTOBJ_LOCVAR_TYPE                                      Dcm_CfgNetTObjHandleMemType
#define DCM_NETTOBJ_LOCVAR_NAME                                      lTObjHandle

#if(DCM_NET_MULTI_TRANSP_OBJ_ENABLED == STD_ON)
# define DCM_NETTOBJ_LOCVAR_DEF                                      DCM_UTI_VAR_DEF(DCM_NETTOBJ_LOCVAR_TYPE, DCM_NETTOBJ_LOCVAR_NAME)
# define DCM_NETTOBJ_LOCVAR_VALUE                                    DCM_NETTOBJ_LOCVAR_NAME

# define DCM_NETTOBJ_ITER_VALUE                                      DCM_NETTOBJ_ITER_NAME
# define DCM_NETTOBJ_ITER_DEF                                        DCM_UTI_VAR_DEF(DCM_NETTOBJ_ITER_TYPE, DCM_NETTOBJ_ITER_NAME)
# define DCM_NETTOBJ_LOOP_FOR_UP                                     DCM_UTI_LOOP_FOR_UP(DCM_NETTOBJ_ITER_NAME, 0, Dcm_PbCfgNetNumTransportObjects)

# define DCM_NETTOBJ_CNTR_DEF                                        DCM_UTI_VAR_DEF(DCM_NETTOBJ_CNTR_TYPE, DCM_NETTOBJ_CNTR_NAME)
# define DCM_NETTOBJ_CNTR_INIT                                       DCM_UTI_VAR_ASSIGNMENT(DCM_NETTOBJ_CNTR_NAME, 0)
# define DCM_NETTOBJ_CNTR_NEXT                                       DCM_UTI_VAR_INC(DCM_NETTOBJ_CNTR_NAME)
# define DCM_NETTOBJ_CNTR_VALUE                                      DCM_NETTOBJ_CNTR_NAME
#else
# define DCM_NETTOBJ_LOCVAR_DEF                                      /* not used */
# define DCM_NETTOBJ_LOCVAR_VALUE                                    ((DCM_NETTOBJ_LOCVAR_TYPE)0u)

# define DCM_NETTOBJ_ITER_VALUE                                      DCM_NETTOBJ_LOCVAR_VALUE
# define DCM_NETTOBJ_ITER_DEF                                        /* not used */
# define DCM_NETTOBJ_LOOP_FOR_UP                                     /* not used */

# define DCM_NETTOBJ_CNTR_DEF                                        /* not used */
# define DCM_NETTOBJ_CNTR_INIT                                       /* not used */
# define DCM_NETTOBJ_CNTR_NEXT                                       /* not used */
# define DCM_NETTOBJ_CNTR_VALUE                                      DCM_NETTOBJ_LOCVAR_VALUE
#endif

/* Periodic transmit object management optimization abstraction */
#define DCM_NET_PTXOBJ_ITER_TYPE                                     Dcm_CfgNetPTxObjHandleOptType
#define DCM_NET_PTXOBJ_ITER_NAME                                     lPerTxObjIter
#define DCM_NET_PTXOBJ_LOCVAR_TYPE                                   Dcm_CfgNetPTxObjHandleMemType
#define DCM_NET_PTXOBJ_LOCVAR_NAME                                   lPerTxObjHandle
#define DCM_NET_PTXOBJ_PARAM_TYPE                                    DCM_NET_PTXOBJ_ITER_TYPE
#define DCM_NET_PTXOBJ_PARAM_NAME                                    perTxObjHandle

#if(DCM_NET_MULTI_PERIODIC_TX_OBJ_ENABLED == STD_ON)                                                                                                 /* COV_DCM_UNSUPPORTED XF */
# define DCM_NET_PTXOBJ_PARAMDEF_ONLY                                DCM_UTI_PARAM_DEF(DCM_NET_PTXOBJ_PARAM_TYPE, DCM_NET_PTXOBJ_PARAM_NAME)
# define DCM_NET_PTXOBJ_PARAMDEF_FIRST                               DCM_NET_PTXOBJ_PARAMDEF_ONLY,
# define DCM_NET_PTXOBJ_PARAM_VALUE                                  DCM_NET_PTXOBJ_PARAM_NAME
# define DCM_NET_PTXOBJ_PARAM_ONLY                                   DCM_NET_PTXOBJ_PARAM_NAME
# define DCM_NET_PTXOBJ_PARAM_FIRST                                  DCM_NET_PTXOBJ_PARAM_NAME,

# define DCM_NET_PTXOBJ_LOCVAR_DEF                                   DCM_UTI_VAR_DEF(DCM_NET_PTXOBJ_LOCVAR_TYPE, DCM_NET_PTXOBJ_LOCVAR_NAME)
# define DCM_NET_PTXOBJ_LOCVAR_VALUE                                 DCM_NET_PTXOBJ_LOCVAR_NAME

# define DCM_NET_PTXOBJ_ITER_DEF                                     DCM_UTI_VAR_DEF(DCM_NET_PTXOBJ_ITER_TYPE, DCM_NET_PTXOBJ_ITER_NAME)
# define DCM_NET_PTXOBJ_LOOP_FOR_UP_GEN                              DCM_UTI_LOOP_FOR_UP(DCM_NET_PTXOBJ_ITER_NAME, 0, Dcm_PbCfgNetNumPerTxObjects)
# define DCM_NET_PTXOBJ_LOOP_FOR_UP_SPEC                             DCM_UTI_LOOP_FOR_UP(DCM_NET_PTXOBJ_ITER_NAME, 0, Dcm_NetPeriodicMsgNumMsgsCurrConnection())
# define DCM_NET_PTXOBJ_LOOP_BREAK                                   break;                                                                          /* PRQA S 3412 */ /* MD_MSR_19.4 */

# define DCM_NET_PTXOBJ_ITER_VALUE                                   DCM_NET_PTXOBJ_ITER_NAME
# define DCM_NET_PTXOBJ_ITER_ONLY                                    DCM_NET_PTXOBJ_ITER_NAME
# define Dcm_NetPTxObjWrpValue(perTxObjHandle)                       (perTxObjHandle)                                                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetPTxObjWrpOnly(perTxObjHandle)                        (perTxObjHandle)                                                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetPTxObjWrpFirst(perTxObjHandle)                       (perTxObjHandle),                                                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define DCM_NET_PTXOBJ_PARAMDEF_ONLY                                void                                                                            /* PRQA S 3460 */ /* MD_MSR_19.4 */
# define DCM_NET_PTXOBJ_PARAMDEF_FIRST                               /* not used */
# define DCM_NET_PTXOBJ_PARAM_VALUE                                  ((DCM_NET_PTXOBJ_PARAM_TYPE)0u)
# define DCM_NET_PTXOBJ_PARAM_ONLY                                   /* not used */
# define DCM_NET_PTXOBJ_PARAM_FIRST                                  /* not used */

# define DCM_NET_PTXOBJ_LOCVAR_DEF                                   /* not used */
# define DCM_NET_PTXOBJ_LOCVAR_VALUE                                 ((DCM_NET_PTXOBJ_LOCVAR_TYPE)0u)

# define DCM_NET_PTXOBJ_ITER_DEF                                     /* not used */
# define DCM_NET_PTXOBJ_LOOP_FOR_UP_GEN                              /* not used */
# define DCM_NET_PTXOBJ_LOOP_FOR_UP_SPEC                             /* not used */
# define DCM_NET_PTXOBJ_LOOP_BREAK                                   /* not used */

# define DCM_NET_PTXOBJ_ITER_VALUE                                   DCM_NET_PTXOBJ_LOCVAR_VALUE
# define DCM_NET_PTXOBJ_ITER_ONLY                                    /* not used */
# define Dcm_NetPTxObjWrpValue(perTxObjHandle)                       DCM_NET_PTXOBJ_PARAM_VALUE
# define Dcm_NetPTxObjWrpOnly(perTxObjHandle)                        /* not used */
# define Dcm_NetPTxObjWrpFirst(perTxObjHandle)                       /* not used */
#endif

#if (DCM_NET_PTXOBJ_LIMITER_ENABLED == STD_ON)                                                                                                       /* COV_DCM_UNSUPPORTED XF */
# define DCM_NET_PTXOBJ_ITER_CTR_DEF                                 /* not used */
# define DCM_NET_PTXOBJ_ITER_CTR_VALUE                               (Dcm_SingletonContext.Network.PeriodicTxContext.NextTxObjectHdl)                /* PRQA S 3412 */ /* MD_MSR_19.4 */
#else
# define DCM_NET_PTXOBJ_ITER_CTR_DEF                                 DCM_NET_PTXOBJ_ITER_DEF
# define DCM_NET_PTXOBJ_ITER_CTR_VALUE                               DCM_NET_PTXOBJ_ITER_VALUE
#endif

#if(DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)                                                                                                        /* COV_DCM_UNSUPPORTED XF */
# define Dcm_NetProtIdWrpValue(protId)                               (protId)                                                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetProtIdWrpOnly(protId)                                (protId)                                                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetProtIdWrpFirst(protId)                               (protId),                                                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_NetProtIdWrpValue(protId)                               0u
# define Dcm_NetProtIdWrpOnly(protId)                                /* not used */
# define Dcm_NetProtIdWrpFirst(protId)                               /* not used */
#endif
#define DCM_NET_INVALID_PTXOBJ_HANDLE                                ((Dcm_CfgNetPTxObjHandleMemType)Dcm_PbCfgNetNumPerTxObjects)
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)                                                                                                  /* COV_DCM_UNSUPPORTED XF */
# define DCM_NET_ARENV_NTFRSLT_OK                                    NTFRSLT_OK
# define DCM_NET_ARENV_NTFRSLT_NOT_OK                                NTFRSLT_E_NOT_OK
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)                                                                                                  /* COV_DCM_SUPPORT_PARTIALLY TX tx xf */
# if (DCM_PDUR_API_401_ENABLED == STD_ON)                                                                                                            /* COV_DCM_UNSUPPORTED XF */
#  define DCM_NET_ARENV_NTFRSLT_OK                                   NTFRSLT_OK
#  define DCM_NET_ARENV_NTFRSLT_NOT_OK                               NTFRSLT_E_NOT_OK
# elif (DCM_PDUR_API_403_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
#  define DCM_NET_ARENV_NTFRSLT_OK                                   NTFRSLT_OK
#  define DCM_NET_ARENV_NTFRSLT_NOT_OK                               NTFRSLT_E_NOT_OK
# elif (DCM_PDUR_API_412_ENABLED == STD_ON)                                                                                                          /* COV_DCM_SUPPORT_ALWAYS TX */
#  define DCM_NET_ARENV_NTFRSLT_OK                                   E_OK
#  define DCM_NET_ARENV_NTFRSLT_NOT_OK                               E_NOT_OK
# else
#  error "Unsupported PduR version!"
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
#define DCM_PAGEDBUFFER_STATE_INACTIVE                               (Dcm_PagedBufferStateType)0x00u
#define DCM_PAGEDBUFFER_STATE_ACTIVATED                              (Dcm_PagedBufferStateType)0x01u
#define DCM_PAGEDBUFFER_STATE_ONTX                                   (Dcm_PagedBufferStateType)0x02u
#define DCM_REPEATER_USER_NONE                                       ((Dcm_RepeaterUserType)0)
#define DCM_REPEATER_USER_DEM                                        ((Dcm_RepeaterUserType)1)
#define DCM_REPEATER_USER_DIDMGR                                     ((Dcm_RepeaterUserType)2)
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)                                                                                                  /* COV_DCM_UNSUPPORTED XF */
# define Dcm_ModeMgrArEnvModeEcuResetType                            Dcm_ResetModeType
# define Dcm_ModeMgrArEnvModeRapidPowerShutDownType                  Dcm_ResetModeType
# define DCM_MODEMGR_ARENV_MODE_ECURESET_NONE                        DCM_NO_RESET
# define DCM_MODEMGR_ARENV_MODE_ECURESET_HARD                        DCM_HARD_RESET
# define DCM_MODEMGR_ARENV_MODE_ECURESET_KEYONOFF                    DCM_KEY_ON_OFF_RESET
# define DCM_MODEMGR_ARENV_MODE_ECURESET_SOFT                        DCM_SOFT_RESET
# define DCM_MODEMGR_ARENV_MODE_ECURESET_JMP2BOOT_OEM                DCM_BOOTLOADER_RESET
# define DCM_MODEMGR_ARENV_MODE_ECURESET_JMP2BOOT_SYS                DCM_SS_BOOTLOADER_RESET
# define DCM_MODEMGR_ARENV_MODE_ECURESET_EXECUTE                     DCM_RESET_EXECUTION
# define DCM_MODEMGR_ARENV_MODE_RPDPWRSHTDWN_ENABLE                  DCM_ENABLE_RAPID_POWER_SHUTDOWN_RESET
# define DCM_MODEMGR_ARENV_MODE_RPDPWRSHTDWN_DISABLE                 DCM_DISABLE_RAPID_POWER_SHUTDOWN_RESET
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)                                                                                                  /* COV_DCM_SUPPORT_PARTIALLY TX tx xf */
# define Dcm_ModeMgrArEnvModeEcuResetType                            Rte_ModeType_DcmEcuReset
# define Dcm_ModeMgrArEnvModeRapidPowerShutDownType                  Rte_ModeType_DcmModeRapidPowerShutDown
# define DCM_MODEMGR_ARENV_MODE_ECURESET_NONE                        RTE_MODE_DcmEcuReset_NONE
# define DCM_MODEMGR_ARENV_MODE_ECURESET_HARD                        RTE_MODE_DcmEcuReset_HARD
# define DCM_MODEMGR_ARENV_MODE_ECURESET_KEYONOFF                    RTE_MODE_DcmEcuReset_KEYONOFF
# define DCM_MODEMGR_ARENV_MODE_ECURESET_SOFT                        RTE_MODE_DcmEcuReset_SOFT
# define DCM_MODEMGR_ARENV_MODE_ECURESET_JMP2BOOT_OEM                RTE_MODE_DcmEcuReset_JUMPTOBOOTLOADER
# define DCM_MODEMGR_ARENV_MODE_ECURESET_JMP2BOOT_SYS                RTE_MODE_DcmEcuReset_JUMPTOSYSSUPPLIERBOOTLOADER
# define DCM_MODEMGR_ARENV_MODE_ECURESET_EXECUTE                     RTE_MODE_DcmEcuReset_EXECUTE
# define DCM_MODEMGR_ARENV_MODE_RPDPWRSHTDWN_ENABLE                  RTE_MODE_DcmModeRapidPowerShutDown_ENABLE_RAPIDPOWERSHUTDOWN
# define DCM_MODEMGR_ARENV_MODE_RPDPWRSHTDWN_DISABLE                 RTE_MODE_DcmModeRapidPowerShutDown_DISABLE_RAPIDPOWERSHUTDOWN
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
#define DCM_STATE_SEC_LEVEL_ITER_TYPE                                uint8_least
#define DCM_STATE_SEC_LEVEL_ITER_NAME                                lSecLvlIter

#if (DCM_STATE_SECURITY_MULTI_LEVELS_ENABLED == STD_ON)                                                                                              /* COV_DCM_UNSUPPORTED XF */
# define DCM_STATE_SEC_LEVEL_ITER_VALUE                              DCM_STATE_SEC_LEVEL_ITER_NAME
# define DCM_STATE_SEC_LEVEL_ITER_DEF                                DCM_UTI_VAR_DEF(DCM_STATE_SEC_LEVEL_ITER_TYPE, DCM_STATE_SEC_LEVEL_ITER_NAME)
# define DCM_STATE_SEC_LEVEL_LOOP_FOR_UP                             DCM_UTI_LOOP_FOR_UP(DCM_STATE_SEC_LEVEL_ITER_NAME, 0, DCM_STATE_SECURITY_NUM_LEVELS)
# define DCM_STATE_SEC_LEVEL_LOOP_BREAK                              break;                                                                          /* PRQA S 3412 */ /* MD_MSR_19.4 */
#else
# define DCM_STATE_SEC_LEVEL_ITER_VALUE                              0
# define DCM_STATE_SEC_LEVEL_ITER_DEF                                /* not used */
# define DCM_STATE_SEC_LEVEL_LOOP_FOR_UP                             /* not used */
# define DCM_STATE_SEC_LEVEL_LOOP_BREAK                              /* not used */
#endif
#define DCM_TSK_PRIO_LOW                                             ((Dcm_TskTaskPrioMemType)0)
#define DCM_TSK_PRIO_HIGH                                            ((Dcm_TskTaskPrioMemType)1)
#if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
# define DCM_TSK_NUM_PRIOS                                           ((Dcm_TskTaskPrioMemType)2)
#else
# define DCM_TSK_NUM_PRIOS                                           ((Dcm_TskTaskPrioMemType)1)
#endif

/* Task setup informations */
/* Task execution type */
#define DCM_TSK_ATR_EXEC_ONCE                                        ((Dcm_TskTaskAttributeType)0x00u)
#define DCM_TSK_ATR_EXEC_MULTI                                       ((Dcm_TskTaskAttributeType)0x01u)
/* Task kill ability type */
#define DCM_TSK_ATR_KILL_NEVER                                       ((Dcm_TskTaskAttributeType)0x00u)
#define DCM_TSK_ATR_KILL_ALWAYS                                      ((Dcm_TskTaskAttributeType)0x02u)

/* Runtime task information (flags) */
#define DCM_TSK_TASK_FLAG_NONE                                       ((Dcm_TskTaskFlagType)0x00u)
#define DCM_TSK_TASK_FLAG_KILLED                                     ((Dcm_TskTaskFlagType)0x01u)

#if (DCM_TSK_TASK_KILL_ENABLED == STD_ON)                                                                                                            /* COV_DCM_UNSUPPORTED XF */
# define Dcm_TskInitNonKillEvents(nonKillEvent)                      ,(nonKillEvent)                                                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_TskInitNonKillEvents(nonKillEvent)                      /* not used */
#endif
#if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
# define Dcm_TskInitPrio(tskPrio)                                    ,(tskPrio)                                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_TskInitPrio(tskPrio)                                    /* not used */
#endif

#define DCM_TSK_INIT_INFO(tskFunc, tskAtr, tskPrio, nonKillEvent)    DCM_TSK_INIT_INFO_LAST((tskFunc), (tskAtr), (tskPrio), (nonKillEvent)),         /* PRQA S 3453, 3458 */ /* MD_MSR_19.4, MD_MSR_19.7 */
#define DCM_TSK_INIT_INFO_LAST(tskFunc, tskAtr, tskPrio, nonKillEvent) {(tskFunc), (Dcm_TskTaskAttributeType)(tskAtr) Dcm_TskInitPrio(tskPrio) Dcm_TskInitNonKillEvents(nonKillEvent)} /* PRQA S 3453, 3458 */ /* MD_MSR_19.4, MD_MSR_19.7 */
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define DCM_DIDMGR_RANGELOOKUPRSLT_NOMATCH                          ((Dcm_DidMgrRangeLookUpResultType)0x00)
# define DCM_DIDMGR_RANGELOOKUPRSLT_MATCHED_SUPPORTED                ((Dcm_DidMgrRangeLookUpResultType)0x01)
# define DCM_DIDMGR_RANGELOOKUPRSLT_MATCHED_UNSUPPORTED              ((Dcm_DidMgrRangeLookUpResultType)0x02)
# define DCM_DIDMGR_RANGELOOKUPRSLT_MATCHED_ANY                      ((Dcm_DidMgrRangeLookUpResultType)(DCM_DIDMGR_RANGELOOKUPRSLT_MATCHED_SUPPORTED | DCM_DIDMGR_RANGELOOKUPRSLT_MATCHED_UNSUPPORTED))
# define DCM_DIDMGR_RANGELOOKUPRSLT_PENDING                          ((Dcm_DidMgrRangeLookUpResultType)0x04)

/* DID operation types - derive from the extern filter API */
# define DCM_DIDMGR_OP_READ                                          DCM_DID_OP_READ
# define DCM_DIDMGR_OP_WRITE                                         DCM_DID_OP_WRITE
# define DCM_DIDMGR_OP_IO                                            DCM_DID_OP_IO
# define DCM_DIDMGR_OP_SCALINGINFO                                   DCM_DID_OP_SCALINGINFO
# define DCM_DIDMGR_OP_DEFINE                                        DCM_DID_OP_DEFINE

/* Service port operation types */
# define DCM_DIDMGR_OPTYPE_READ                                      ((Dcm_DidMgrOpCallMemType)0x01u)
# define DCM_DIDMGR_OPTYPE_READLENGTH                                ((Dcm_DidMgrOpCallMemType)0x02u)
# define DCM_DIDMGR_OPTYPE_READCHKCOND                               ((Dcm_DidMgrOpCallMemType)0x04u)
# define DCM_DIDMGR_OPTYPE_RANGEREAD                                 DCM_DIDMGR_OPTYPE_READ
# define DCM_DIDMGR_OPTYPE_RANGEREADLENGTH                           DCM_DIDMGR_OPTYPE_READLENGTH

# define DCM_DIDMGR_OPTYPE_WRITE                                     ((Dcm_DidMgrOpCallMemType)0x01u)
# define DCM_DIDMGR_OPTYPE_RANGEWRITE                                DCM_DIDMGR_OPTYPE_WRITE

/* this value shall be for both OP_READ and OP_WRITE OP_TYPES the same! */
# define DCM_DIDMGR_OPTYPE_RANGEISDIDAVAILABLE                       ((Dcm_DidMgrOpCallMemType)0x10u)

# define DCM_DIDMGR_OPTYPE_GETSCALING                                ((Dcm_DidMgrOpCallMemType)0x01u)

# define DCM_DIDMGR_OPTYPE_DEFINE                                    ((Dcm_DidMgrOpCallMemType)0x01u)

# define DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU                            ((Dcm_DidMgrOpCallMemType)0x01u)
# define DCM_DIDMGR_OPTYPE_IO_RST2DEF                                ((Dcm_DidMgrOpCallMemType)0x02u)
# define DCM_DIDMGR_OPTYPE_IO_FRZCURSTATE                            ((Dcm_DidMgrOpCallMemType)0x04u)
# define DCM_DIDMGR_OPTYPE_IO_SHRTTRMADJ                             ((Dcm_DidMgrOpCallMemType)0x08u)

/* Service port operation classes */

# define DCM_DIDMGR_OPCLS_READ_RANGE                                 ((Dcm_DidMgrOpClassType)0)
# define DCM_DIDMGR_OPCLS_READ_SYNC                                  ((Dcm_DidMgrOpClassType)1)
# define DCM_DIDMGR_OPCLS_READ_ASYNC                                 ((Dcm_DidMgrOpClassType)2)
# define DCM_DIDMGR_OPCLS_READ_PAGE                                  ((Dcm_DidMgrOpClassType)3)
# define DCM_DIDMGR_OPCLS_READ_VID                                   ((Dcm_DidMgrOpClassType)4)

# define DCM_DIDMGR_OPCLS_READLENGTH_RANGE                           ((Dcm_DidMgrOpClassType)0)
# define DCM_DIDMGR_OPCLS_READLENGTH_SYNC                            ((Dcm_DidMgrOpClassType)1)
# define DCM_DIDMGR_OPCLS_READLENGTH_ASYNC                           ((Dcm_DidMgrOpClassType)2)

# define DCM_DIDMGR_OPCLS_READCHK_COND_SYNC                          ((Dcm_DidMgrOpClassType)0)
# define DCM_DIDMGR_OPCLS_READCHK_COND_ASYNC                         ((Dcm_DidMgrOpClassType)1)

# define DCM_DIDMGR_OPCLS_WRITE_RANGE                                ((Dcm_DidMgrOpClassType)0)
# define DCM_DIDMGR_OPCLS_WRITE_NLEN_SYNC_NRES_ERROR                 ((Dcm_DidMgrOpClassType)1)
# define DCM_DIDMGR_OPCLS_WRITE_NLEN_ASYNC_NRES_ERROR                ((Dcm_DidMgrOpClassType)2)
# define DCM_DIDMGR_OPCLS_WRITE_LEN_SYNC_NRES_ERROR                  ((Dcm_DidMgrOpClassType)3)
# define DCM_DIDMGR_OPCLS_WRITE_LEN_ASYNC_NRES_ERROR                 ((Dcm_DidMgrOpClassType)4)
# define DCM_DIDMGR_OPCLS_WRITE_LEN_SYNC_RES_ERROR                   ((Dcm_DidMgrOpClassType)5)
# define DCM_DIDMGR_OPCLS_WRITE_NLEN_SYNC_NRES_NERROR                ((Dcm_DidMgrOpClassType)6)

# define DCM_DIDMGR_OPCLS_ISDIDAVAILABLE                             ((Dcm_DidMgrOpClassType)0)

# define DCM_DIDMGR_OPCLS_GETSCALING_SYNC                            ((Dcm_DidMgrOpClassType)0)
# define DCM_DIDMGR_OPCLS_GETSCALING_ASYNC                           ((Dcm_DidMgrOpClassType)1)

# define DCM_DIDMGR_OPCLS_DEFINE                                     ((Dcm_DidMgrOpClassType)0)

# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_NCEMR_ERROR         ((Dcm_DidMgrOpClassType)0)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_NCEMR_ERROR          ((Dcm_DidMgrOpClassType)1)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_NCEMR_ERROR           ((Dcm_DidMgrOpClassType)2)
# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_NCEMR_ERROR        ((Dcm_DidMgrOpClassType)3)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_NCEMR_ERROR         ((Dcm_DidMgrOpClassType)4)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_NCEMR_ERROR          ((Dcm_DidMgrOpClassType)5)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_RES_NCEMR_ERROR            ((Dcm_DidMgrOpClassType)6)

# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR8_ERROR         ((Dcm_DidMgrOpClassType)7)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR8_ERROR          ((Dcm_DidMgrOpClassType)8)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR8_ERROR           ((Dcm_DidMgrOpClassType)9)
# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR8_ERROR        ((Dcm_DidMgrOpClassType)10)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR8_ERROR         ((Dcm_DidMgrOpClassType)11)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR8_ERROR          ((Dcm_DidMgrOpClassType)12)

# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR16_ERROR        ((Dcm_DidMgrOpClassType)13)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR16_ERROR         ((Dcm_DidMgrOpClassType)14)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR16_ERROR          ((Dcm_DidMgrOpClassType)15)
# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR16_ERROR       ((Dcm_DidMgrOpClassType)16)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR16_ERROR        ((Dcm_DidMgrOpClassType)17)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR16_ERROR         ((Dcm_DidMgrOpClassType)18)

# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR32_ERROR        ((Dcm_DidMgrOpClassType)19)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR32_ERROR         ((Dcm_DidMgrOpClassType)20)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR32_ERROR          ((Dcm_DidMgrOpClassType)21)
# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR32_ERROR       ((Dcm_DidMgrOpClassType)22)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR32_ERROR        ((Dcm_DidMgrOpClassType)23)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR32_ERROR         ((Dcm_DidMgrOpClassType)24)

# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMRN_ERROR         ((Dcm_DidMgrOpClassType)25)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMRN_ERROR          ((Dcm_DidMgrOpClassType)26)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMRN_ERROR           ((Dcm_DidMgrOpClassType)27)
# define DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMRN_ERROR        ((Dcm_DidMgrOpClassType)28)
# define DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMRN_ERROR         ((Dcm_DidMgrOpClassType)29)
# define DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMRN_ERROR          ((Dcm_DidMgrOpClassType)30)

# define DCM_DIDMGR_OPCLS_IO_FIRST_OPCLS_WITH_EXT_CEMR               DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR8_ERROR

# define DCM_DIDMGR_LOOKUP_STATE_DIDRANGE                            ((Dcm_DidMgrDidLookUpStateType)0)
# define DCM_DIDMGR_LOOKUP_STATE_CONCRETEDID                         ((Dcm_DidMgrDidLookUpStateType)1)
# define DCM_DIDMGR_LOOKUP_STATE_DIDFILTER_EXTERN                    ((Dcm_DidMgrDidLookUpStateType)2)

# if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
#  define Dcm_DidMgrWrapAsyncDidOpStatus(opStatus)                   (opStatus)                                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_DidMgrWrapAsyncDidOpStatus(opStatus)                   (DCM_INITIAL)                                                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif

# if (DCM_DIDMGR_STATIC_DID_ASYNC_SUPPORT_ENABLED == STD_ON)
#  define Dcm_DidMgrWrapStaticDidAsyncOpStatus(opStatus)             (opStatus)                                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_DidMgrWrapStaticDidAsyncOpStatus(opStatus)             (DCM_INITIAL)                                                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif

# if (DCM_DIDMGR_OPTYPE_READ_ENABLED == STD_ON)
#  if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
#   define Dcm_DidMgrRead                                            Dcm_DidMgrReadPaged
#  else
#   define Dcm_DidMgrRead                                            Dcm_DidMgrReadLinear
#  endif
# endif
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define DCM_RIDMGR_OP_START                                         ((Dcm_RidMgrOpType)0x01u)
# define DCM_RIDMGR_OP_STOP                                          ((Dcm_RidMgrOpType)0x02u)
# define DCM_RIDMGR_OP_REQRSLTS                                      ((Dcm_RidMgrOpType)0x04u)

# define DCM_RIDMGR_OPTYPE_NONE                                      ((Dcm_RidMgrOpCallType)0u)
# define DCM_RIDMGR_OPTYPE_REQ                                       ((Dcm_RidMgrOpCallType)1u)
# define DCM_RIDMGR_OPTYPE_REQ_RES                                   ((Dcm_RidMgrOpCallType)2u)
# define DCM_RIDMGR_OPTYPE_RES                                       ((Dcm_RidMgrOpCallType)3u)
# define DCM_RIDMGR_OPTYPE_REQ_DYNLEN                                ((Dcm_RidMgrOpCallType)4u)
# define DCM_RIDMGR_OPTYPE_REQ_DYNLEN_RES                            ((Dcm_RidMgrOpCallType)5u)
# define DCM_RIDMGR_OPTYPE_RES_DYNLEN                                ((Dcm_RidMgrOpCallType)6u)
# define DCM_RIDMGR_OPTYPE_REQ_DYNLEN_RES_DYNLEN                     ((Dcm_RidMgrOpCallType)7u)
# define DCM_RIDMGR_OPTYPE_REQ_RES_DYNLEN                            ((Dcm_RidMgrOpCallType)8u)

# define DCM_RIDMGR_DYNLEN_MASK_REQ                                  ((Dcm_RidMgrDynLenMaskType)0x01u)
# define DCM_RIDMGR_DYNLEN_MASK_RES                                  ((Dcm_RidMgrDynLenMaskType)0x02u)
#endif /* (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON) */
/* network to diagnostic variant abstraction */
#if (DCM_VARMGR_SUPPORT_ENABLED == STD_ON)
# define Dcm_PbCfgDiagSvcId2ProtMap                                  (DCM_VARMGR_ACTIVE_BRIDGEVAR.Svc2ProtocolMap)
#else
# define Dcm_PbCfgDiagSvcId2ProtMap                                  Dcm_CfgDiagSvcId2ProtMap
#endif
#define DCM_DIAG_CHK_LVL_SERVICE_ID                                  ((Dcm_DiagCheckLvlType)0u)
#define DCM_DIAG_CHK_LVL_PARAMETER                                   ((Dcm_DiagCheckLvlType)1u)
#define DCM_DIAG_CHK_LVL_SUBFUNC                                     ((Dcm_DiagCheckLvlType)2u)

#define DCM_NUM_DIAG_CHK_LVLS                                        (DCM_DIAG_CHK_LVL_SUBFUNC + 1u)

/* Bit encoding for the enumerator values below (not AR standard!)*/
#define DCM_DIAG_RES_ANY_OK                                          ((uint8)0x00u)
#define DCM_DIAG_RES_ANY_NOT_OK                                      ((uint8)0x01u)
#define DCM_DIAG_RES_POS_ANY                                         ((uint8)0x00u)
#define DCM_DIAG_RES_NEG_ANY                                         ((uint8)0x02u)

#define DCM_DIAG_APPL_NOTIFICATION_NONE                              ((Dcm_DiagApplNotificationType)0x00u)
#define DCM_DIAG_APPL_NOTIFICATION_OEM                               ((Dcm_DiagApplNotificationType)0x01u)
#define DCM_DIAG_APPL_NOTIFICATION_SYS                               ((Dcm_DiagApplNotificationType)0x02u)
#define DCM_DIAG_APPL_NOTIFICATION_SVC_HDLR                          ((Dcm_DiagApplNotificationType)0x04u)
#define DCM_DIAG_APPL_NOTIFICATION_SID_FOUND                         ((Dcm_DiagApplNotificationType)0x08u)

#define DCM_DIAG_QUEUE_FLAG_NONE                                     ((Dcm_DiagProcessorFlagType)0x00u)
#define DCM_DIAG_QUEUE_FLAG_IS_WAITING                               ((Dcm_DiagProcessorFlagType)0x01u)
#define DCM_DIAG_QUEUE_FLAG_IS_ACTIVE                                ((Dcm_DiagProcessorFlagType)0x02u)

#define DCM_DIAG_SVC_CFG_PROP_HAS_SUBFUNC                            ((DcmCfg_DiagServicePropertiesType)0x01u)
#define DCM_DIAG_SVC_CFG_PROP_CALL_POST_HDLR_ALWAYS                  ((DcmCfg_DiagServicePropertiesType)0x02u)

#define Dcm_DiagGetP2Time(sesStateIdx)                               (Dcm_CfgStateSessionInfo[(sesStateIdx)].P2ServerTime.P2)                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_DiagGetP2StarTime(sesStateIdx)                           (Dcm_CfgStateSessionInfo[(sesStateIdx)].P2ServerTime.P2Star)                    /* PRQA S 3453 */ /* MD_MSR_19.7 */

#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
# define DCM_DIAG_RECOVERY_CHCKBIT_ALL_COMM_CHANNELS                 (Dcm_UtiMake32Bit(0u, 0u, DCM_NET_MAX_NUM_ALL_COMM_CHANNELS, 0u))
#else
# define DCM_DIAG_RECOVERY_CHCKBIT_ALL_COMM_CHANNELS                 0u
#endif

#define DCM_DIAG_RECOVERY_CHCKBIT_SESSION                            (Dcm_UtiGetBitFromIndex(uint32, 16u))

#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
# define DCM_DIAG_RECOVERY_CHCKBIT_SECURITY                          (Dcm_UtiGetBitFromIndex(uint32, 17u))
#else
# define DCM_DIAG_RECOVERY_CHCKBIT_SECURITY                          0u
#endif

#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
# define DCM_DIAG_RECOVERY_CHCKBIT_SVC85_STATE                       (Dcm_UtiGetBitFromIndex(uint32, 18u))
#else
# define DCM_DIAG_RECOVERY_CHCKBIT_SVC85_STATE                       0u
#endif

#if (DCM_SVC_85_DTC_GRP_ENABLED == STD_ON)
# define DCM_DIAG_RECOVERY_CHCKBIT_SVC85_DTC_GROUP                   (Dcm_UtiGetBitFromIndex(uint32, 19u))
#else
# define DCM_DIAG_RECOVERY_CHCKBIT_SVC85_DTC_GROUP                   0u
#endif

#if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
# define DCM_DIAG_RECOVERY_CHCKBIT_SESSION_CONN                      (Dcm_UtiGetBitFromIndex(uint32, 20u))
#else
# define DCM_DIAG_RECOVERY_CHCKBIT_SESSION_CONN                      0u
#endif

#define DCM_DIAG_RECOVERY_CHCKBIT_RESERVED                           Dcm_UtiMake32Bit(0u, 0x60, 0u, 0u)

#define DCM_DIAG_RECOVERY_CHCKBIT_CONSTANT                           Dcm_UtiMake32Bit(0x0F, 0u, 0u, 0u)

#define DCM_DIAG_RECOVERY_SIGNATURE                                  ((uint32)(DCM_NET_MAX_NUM_COMM_CHANNELS_CONST | \
                                                                     DCM_DIAG_RECOVERY_CHCKBIT_ALL_COMM_CHANNELS | \
                                                                     DCM_DIAG_RECOVERY_CHCKBIT_SESSION | \
                                                                     DCM_DIAG_RECOVERY_CHCKBIT_SECURITY | \
                                                                     DCM_DIAG_RECOVERY_CHCKBIT_SVC85_STATE | \
                                                                     DCM_DIAG_RECOVERY_CHCKBIT_SVC85_DTC_GROUP | \
                                                                     DCM_DIAG_RECOVERY_CHCKBIT_SESSION_CONN | \
                                                                     DCM_DIAG_RECOVERY_CHCKBIT_RESERVED | \
                                                                     DCM_DIAG_RECOVERY_CHCKBIT_CONSTANT))
/* Variant management optimization abstraction */
#define DCM_VARMGR_ACTIVE_COMVAR                                     (Dcm_SingletonContext.VarMgr.ActiveComVariant)
#define DCM_VARMGR_ACTIVE_BRIDGEVAR                                  (Dcm_SingletonContext.VarMgr.ActiveBridgeVariant)
#define DCM_VARMGR_ACTIVE_RAMVAR                                     (Dcm_SingletonContext.VarMgr.ActiveRamVariant)
#define DCM_VARMGR_ACTIVE_ROMVAR                                     (Dcm_SingletonContext.VarMgr.ActiveRomVariant)
#if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON)
# define Dcm_PbCfgVarMgrDiagVariantFilter                            (DCM_VARMGR_ACTIVE_ROMVAR.DiagRom.VariantFilter)
#else
# define Dcm_PbCfgVarMgrDiagVariantFilter                            Dcm_CfgVarMgrVariantTable
#endif
#if (DCM_SVC_10_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_SUPPORT_ALWAYS TX */
# define DCM_SVC10_PROGRESS_WAIT_RST_ACK                             ((Dcm_RepeaterProgressType)0)
# define DCM_SVC10_PROGRESS_WAIT_RCRRP_ACK                           ((Dcm_RepeaterProgressType)1)
# define DCM_SVC10_PROGRESS_SET_PRGCOND                              ((Dcm_RepeaterProgressType)2)
#endif /* (DCM_SVC_10_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC_19_DEM_SETFILTER_CLASS_01                           ((Dcm_Svc19DemSetFilterClassType)0u) /* SF 0x01, 0x02, 0x0A */
# define DCM_SVC_19_DEM_SETFILTER_CLASS_02                           ((Dcm_Svc19DemSetFilterClassType)1u) /* SF 0x07 */
# define DCM_SVC_19_DEM_SETFILTER_CLASS_03                           ((Dcm_Svc19DemSetFilterClassType)2u) /* SF 0x11, 0x0F  */
# define DCM_SVC_19_DEM_SETFILTER_CLASS_04                           ((Dcm_Svc19DemSetFilterClassType)3u) /* SF 0x12, 0x13 */
# define DCM_SVC_19_DEM_SETFILTER_CLASS_05                           ((Dcm_Svc19DemSetFilterClassType)4u) /* SF 0x15 */
# define DCM_SVC_19_DEM_SETFILTER_CLASS_06                           ((Dcm_Svc19DemSetFilterClassType)5u) /* SF 0x17 */

# define DCM_SVC_19_DEM_SETFILTER_NUM_CLASSES                        (DCM_SVC_19_DEM_SETFILTER_CLASS_06+1u)

# define DCM_SVC_19_USE_MASK_REQ                                     ((Dcm_Svc19DemSetFilterMaskUsageType)0u)
# define DCM_SVC_19_USE_MASK_ALL                                     ((Dcm_Svc19DemSetFilterMaskUsageType)1u)

# define DCM_SVC_19_RECNUM_ALL                                       ((uint8)0xFFu)
# define DCM_SVC_19_RECNUM_OBD_ALL                                   ((uint8)0xFEu)

# define DCM_SVC_19_RECLIST_END                                      ((uint8)0xFFu)
/* Vector DCM to Vector DEM Interface check */
# if (DCM_DEMAPI_SVC_19_READ_DTC_EXT_DATA_BY_DTC_NUM_ENABLED == STD_ON)
#  if ( defined(DCM_SVC_19_NUM_EXTDATA_RECID) && !defined (DCM_SVC_19_LST_EXTDATA_RECID)) || \
      (!defined(DCM_SVC_19_NUM_EXTDATA_RECID) &&  defined (DCM_SVC_19_LST_EXTDATA_RECID))
#   error "Inconsistent setup! Check your user configuration file upon DCM TechRef!"
#  else
#   if (defined(DCM_SVC_19_NUM_EXTDATA_RECID) && defined (DCM_SVC_19_LST_EXTDATA_RECID))                                                             /* COV_DCM_UNSUPPORTED XF xf xf */
/* the DCM knows the extended data records of the DEM */
#   else
#    if ( defined(DEM_DCM_NUM_EXTDATA_RECID) && !defined (DEM_DCM_LST_EXTDATA_RECID)) || \
        (!defined(DEM_DCM_NUM_EXTDATA_RECID) &&  defined (DEM_DCM_LST_EXTDATA_RECID))
#     error "Inconsistent setup! Check your user configuration file upon DCM TechRef!"
#    else
#     if (defined(DEM_DCM_NUM_EXTDATA_RECID) && defined (DEM_DCM_LST_EXTDATA_RECID))                                                                 /* COV_DCM_SUPPORT_WITH_MSR_DEM TX tx tx */
/* use the information provided by DEM */
#      define DCM_SVC_19_NUM_EXTDATA_RECID                           DEM_DCM_NUM_EXTDATA_RECID
#      define DCM_SVC_19_LST_EXTDATA_RECID                           DEM_DCM_LST_EXTDATA_RECID
#     else
#      define DCM_SVC_19_NUM_EXTDATA_RECID                           0
#      define DCM_SVC_19_LST_EXTDATA_RECID                           /* empty */
#      error "Missing information for the supported DTC Extended Data Records! See DCM TechRef!"
#     endif
#    endif
#   endif
#  endif
#  define DCM_SVC_19_EXTDATA_RECID_SIZE                              (DCM_SVC_19_NUM_EXTDATA_RECID     + 1)
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_EXT_DATA_BY_DTC_NUM_ENABLED == STD_ON)
#  if ( defined(DCM_SVC_19_NUM_OBD_EXTDATA_RECID) && !defined (DCM_SVC_19_LST_OBD_EXTDATA_RECID)) || \
      (!defined(DCM_SVC_19_NUM_OBD_EXTDATA_RECID) &&  defined (DCM_SVC_19_LST_OBD_EXTDATA_RECID))
#   error "Inconsistent setup! Check your user configuration file upon DCM TechRef!"
#  else
#   if (defined(DCM_SVC_19_NUM_OBD_EXTDATA_RECID) && defined (DCM_SVC_19_LST_OBD_EXTDATA_RECID))                                                     /* COV_DCM_UNSUPPORTED XF xf xf */
/* the DCM knows the OBD extended data records of the DEM */
#   else
#    if ( defined(DEM_DCM_NUM_OBD_EXTDATA_RECID) && !defined (DEM_DCM_LST_OBD_EXTDATA_RECID)) || \
        (!defined(DEM_DCM_NUM_OBD_EXTDATA_RECID) &&  defined (DEM_DCM_LST_OBD_EXTDATA_RECID))
#     error "Inconsistent setup! Check your user configuration file upon DCM TechRef!"
#    else
#     if ( defined(DEM_DCM_NUM_OBD_EXTDATA_RECID) && defined (DEM_DCM_LST_OBD_EXTDATA_RECID))                                                        /* COV_DCM_SUPPORT_WITH_MSR_DEM TX tx tx */
/* use the information provided by DEM */
#      define DCM_SVC_19_NUM_OBD_EXTDATA_RECID                       DEM_DCM_NUM_OBD_EXTDATA_RECID
#      define DCM_SVC_19_LST_OBD_EXTDATA_RECID                       DEM_DCM_LST_OBD_EXTDATA_RECID
#     else
#      define DCM_SVC_19_NUM_OBD_EXTDATA_RECID                       0
#      define DCM_SVC_19_LST_OBD_EXTDATA_RECID                       /* empty */
#     endif
#    endif
#   endif
#  endif
/* Actual table sizes */
#  define DCM_SVC_19_OBD_EXTDATA_RECID_SIZE                          (DCM_SVC_19_NUM_OBD_EXTDATA_RECID + 1)

#  if (DCM_SVC_19_NUM_OBD_EXTDATA_RECID > 0)                                                                                                         /* COV_DCM_UNSUPPORTED XF */
#   define DCM_SVC_19_OBD_EXT_RECORD_ENABLED                         STD_ON
#  endif
# endif

# if defined(DCM_SVC_19_OBD_EXT_RECORD_ENABLED)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
/* already set */
# else
#  define DCM_SVC_19_OBD_EXT_RECORD_ENABLED                          STD_OFF
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_FFR_BY_DTC_ENABLED == STD_ON)
#  if ( defined(DCM_SVC_19_NUM_FRZFRAME_RECID) && !defined (DCM_SVC_19_LST_FRZFRAME_RECID)) || \
      (!defined(DCM_SVC_19_NUM_FRZFRAME_RECID) &&  defined (DCM_SVC_19_LST_FRZFRAME_RECID))
#   error "Inconsistent setup! Check your user configuration file upon DCM TechRef!"
#  else
#   if (defined(DCM_SVC_19_NUM_FRZFRAME_RECID) && defined (DCM_SVC_19_LST_FRZFRAME_RECID))                                                           /* COV_DCM_UNSUPPORTED XF xf xf */
/* the DCM knows the OBD extended data records of the DEM */
#   else
#    if ( defined(DEM_DCM_NUM_FRZFRAME_RECID) && !defined (DEM_DCM_LST_FRZFRAME_RECID)) || \
        (!defined(DEM_DCM_NUM_FRZFRAME_RECID) &&  defined (DEM_DCM_LST_FRZFRAME_RECID))
#     error "Inconsistent setup! Check your user configuration file upon DCM TechRef!"
#    else
#     if ( defined(DEM_DCM_NUM_FRZFRAME_RECID) && defined (DEM_DCM_LST_FRZFRAME_RECID))                                                              /* COV_DCM_SUPPORT_WITH_MSR_DEM TX tx tx */
/* use the information provided by DEM */
#      define DCM_SVC_19_NUM_FRZFRAME_RECID                          DEM_DCM_NUM_FRZFRAME_RECID
#      define DCM_SVC_19_LST_FRZFRAME_RECID                          DEM_DCM_LST_FRZFRAME_RECID
#     else
#      define DCM_SVC_19_NUM_FRZFRAME_RECID                          0
#      define DCM_SVC_19_LST_FRZFRAME_RECID                          /* empty */
#      error "Missing information for the supported DTC Freeze Frame Records! See DCM TechRef!"
#     endif
#    endif
#   endif
#  endif
/* Actual table sizes */
#  define DCM_SVC_19_FRZFRAME_RECID_SIZE                             (DCM_SVC_19_NUM_FRZFRAME_RECID    + 1)
# endif
# if !defined(DCM_EXT_SVC19_PATCH_CONTEXT)                                                                                                           /* COV_DCM_UNSUPPORTED TX */
#  define DCM_EXT_SVC19_PATCH_CONTEXT                                /* not used */
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define DCM_SVC_27_LEVEL_MASK                                       (Dcm_UtiGetMaskFromXintType(uint8, DCM_STATE_SECURITY_NUM_LEVELS))              /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* Security access management optimization abstraction */
# define DCM_SVC27_CNTR_ITER_TYPE                                    uint8_least
# define DCM_SVC27_CNTR_ITER_NAME                                    lCntrIter

# if (DCM_SVC_27_MULTI_ATTEMPT_COUNTER_ENABLED == STD_ON)
#  define DCM_SVC27_CNTR_ITER_DEF                                    DCM_UTI_VAR_DEF(DCM_SVC27_CNTR_ITER_TYPE, DCM_SVC27_CNTR_ITER_NAME)
#  define DCM_SVC27_CNTR_LOOP_FOR_UP                                 DCM_UTI_LOOP_FOR_UP(DCM_SVC27_CNTR_ITER_NAME, 0, DCM_SVC_27_NUM_ATTEMPT_COUNTERS)
#  define DCM_SVC27_CNTR_ITER_VALUE                                  DCM_SVC27_CNTR_ITER_NAME
# else
#  define DCM_SVC27_CNTR_ITER_DEF                                    /* not used */
#  define DCM_SVC27_CNTR_LOOP_FOR_UP                                 /* not used */
#  define DCM_SVC27_CNTR_ITER_VALUE                                  0
# endif

# define DCM_SVC27_TMR_ITER_TYPE                                     uint8_least
# define DCM_SVC27_TMR_ITER_NAME                                     lTmrIter

# if (DCM_SVC_27_SOFT_TIMER_ENABLED == STD_ON)
#  define DCM_SVC27_TMR_ITER_DEF                                     DCM_UTI_VAR_DEF(DCM_SVC27_TMR_ITER_TYPE, DCM_SVC27_TMR_ITER_NAME)
#  define DCM_SVC27_TMR_LOOP_FOR_UP                                  DCM_UTI_LOOP_FOR_UP(DCM_SVC27_TMR_ITER_NAME, 0, DCM_SVC_27_NUM_DELAY_TIMERS)
#  define DCM_SVC27_TMR_ITER_VALUE                                   DCM_SVC27_TMR_ITER_NAME
# else
#  define DCM_SVC27_TMR_ITER_DEF                                     /* not used */
#  define DCM_SVC27_TMR_LOOP_FOR_UP                                  /* not used */
#  define DCM_SVC27_TMR_ITER_VALUE                                   0
# endif
# define DCM_SVC_27_SEED_LVL_INVALID                                 ((uint8)0x00u)
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
# define DCM_SVC_28_CTRL_OP_MASK                                     (0x03u)
#endif /* (DCM_SVC_28_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define DCM_SVC2A_RATE_TYPE_SLOW                                    ((Dcm_Svc2ASchedRateMemType)0)
# define DCM_SVC2A_RATE_TYPE_MED                                     ((Dcm_Svc2ASchedRateMemType)1)
# define DCM_SVC2A_RATE_TYPE_FAST                                    ((Dcm_Svc2ASchedRateMemType)2)

# define DCM_SVC2A_RATE_TYPE_MASK                                    ((Dcm_Svc2ASchedRateMemType)0x03u)

# define DCM_SVC2A_RATE_TYPE_STOPPED                                 ((Dcm_Svc2ASchedRateMemType)0x10u)
# define DCM_SVC2A_RATE_TYPE_RESERVED                                ((Dcm_Svc2ASchedRateMemType)0x40u)
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define DCM_SVC2A_MAX_RESPONSE_LEN                                  ((uint8)(DCM_NET_PERIODIC_BUFFER_SIZE - 1u))
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define DCM_SVC2C_INVALID_DYNDID_HDL                                (Dcm_UtiMaxValueOfUintType(Dcm_CfgDidMgrDynDidHandleMemType))

# define DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED                        0u

# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON) && \
     (DCM_DIDMGR_STATIC_DID_ASYNC_SUPPORT_ENABLED == STD_ON) && \
     (DCM_DIDMGR_DYNDID_SRCITEM_CHECK_COND_ENABLED == STD_ON)
#  define DCM_SVC_2C_NUM_PROCESS_CONTEXTS                            2u
#  define DCM_SVC_2C_PROCESS_CONTEXT_ID_EXT_ONLY                     1u
# else
#  define DCM_SVC_2C_NUM_PROCESS_CONTEXTS                            1u
#  define DCM_SVC_2C_PROCESS_CONTEXT_ID_EXT_ONLY                     0u
# endif

# if(DCM_DEV_ERROR_REPORT == STD_ON)
#  define DCM_SVC_2C_READ_BUFFER_OVERHEAD                            2
# else
#  define DCM_SVC_2C_READ_BUFFER_OVERHEAD                            0
# endif
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
/* ----------------------------------------------
 ~&&&   Function-like macros
---------------------------------------------- */
#if (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define Dcm_MemMgrGetMemBlockLenSize(formatByte)                    (Dcm_UtiGetHiNibble(formatByte))                                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_MemMgrGetMemBlockAddrSize(formatByte)                   (Dcm_UtiGetLoNibble(formatByte))                                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_MemMgrGetMemBlockInfoLength(formatByte)                 ((uint8)(Dcm_MemMgrGetMemBlockAddrSize(formatByte) + Dcm_MemMgrGetMemBlockLenSize(formatByte))) /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dcm_MemMgrReadMemory(opStatus, pMemBlock, resData, errorCode) (Dcm_MemMgrExecuteMemoryOperation(Dcm_ReadMemory, (opStatus), (pMemBlock), (resData), (errorCode))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_MemMgrWriteMemory(opStatus, pMemBlock, reqData, errorCode) (Dcm_MemMgrExecuteMemoryOperation(Dcm_WriteMemory, (opStatus), (pMemBlock), (reqData), (errorCode))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
/* Check if it is an available ID at all: (id MOD 0x20) == 0 */
# define Dcm_ObdIdMgrIsAvailabilityId(obdId)                         (((obdId) & 0x1Fu) == 0)                                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_ObdIdMgrGetObdIdMaskBit(obdId)                          ((uint32)(0x01UL << (31u - (((obdId)-1u) & 0x1Fu))))                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_ObdIdMgrIsIdSupported(availMask, obdId)                 (Dcm_UtiBitOpTest(uint32, (availMask), Dcm_ObdIdMgrGetObdIdMaskBit(obdId)))     /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_ObdIdMgrGetAvailabilityIdIdx(obdId)                     ((uint8)(((uint8)(obdId)) >> 5u))                                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_ObdIdMgrGetAvailabilityId(id)                           ((uint8)((id) & 0xE0))                                                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_ObdIdMgrGetMaskValue(obdAidId, pMaskData)               ((pMaskData)[Dcm_ObdIdMgrGetAvailabilityIdIdx(obdAidId)])                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)                                                                                                  /* COV_DCM_UNSUPPORTED XF */
/* only one instance of DCM allowed */
# define Dcm_VersionArEnvSetModuleInstance(versionInfoPtr)           ((versionInfoPtr)->instanceID = (uint16)0)                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)                                                                                                  /* COV_DCM_SUPPORT_PARTIALLY TX tx xf */
# define Dcm_VersionArEnvSetModuleInstance(versionInfoPtr)           /* Not used */
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)                                                                                                  /* COV_DCM_UNSUPPORTED XF */
/* SchM AR abstraction */
# define Dcm_UtiArEnvEnterCriticalSection()                          SchM_Enter_Dcm(DCM_EXCLUSIVE_AREA_0)                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_UtiArEnvLeaveCriticalSection()                          SchM_Exit_Dcm(DCM_EXCLUSIVE_AREA_0)                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)                                                                                                  /* COV_DCM_SUPPORT_PARTIALLY TX tx xf */
/* SchM AR abstraction */
# define Dcm_UtiArEnvEnterCriticalSection()                          SchM_Enter_Dcm_DCM_EXCLUSIVE_AREA_0()                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_UtiArEnvLeaveCriticalSection()                          SchM_Exit_Dcm_DCM_EXCLUSIVE_AREA_0()                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
/* NvM AR abstraction */
# define Dcm_UtiArEnvNvMGetErrorStatus(blockId, nvmStatus)           (NvM_GetErrorStatus((blockId),(nvmStatus)))                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
/* *** Assertions for the core *** */
#define Dcm_DebugOptIsModuleInitialized()                            (Dcm_DebugInitState == DCM_DEBUG_INITPATTERN)                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dcm_DebugDeInit()                                            (Dcm_DebugInitState = DCM_DEBUG_UNINITPATTERN)                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_DebugInitMemory()                                        (Dcm_DebugDeInit())                                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_DebugInit()                                              (Dcm_DebugInitState = DCM_DEBUG_INITPATTERN)                                    /* PRQA S 3453 */ /* MD_MSR_19.7 */
#if(DCM_NET_MULTI_CHANNEL_ENABLED == STD_ON)
/* Protect against parallel request from another CAN channel */
# define Dcm_NetMultiChannelEnterCS()                                Dcm_UtiArEnvEnterCriticalSection()                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetMultiChannelLeaveCS()                                Dcm_UtiArEnvLeaveCriticalSection()                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_NetMultiChannelEnterCS()                                /* not used */
# define Dcm_NetMultiChannelLeaveCS()                                /* not used */
#endif

/* Buffer management */
#define Dcm_NetBufferIsFree(hBuffer)                                 (Dcm_PbRamNetBufferContext[Dcm_NetBufIdWrpValue(hBuffer)].IsInUseCnt == 0u)     /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_NetBufferLock(hBuffer)                                   (Dcm_PbRamNetBufferContext[Dcm_NetBufIdWrpValue(hBuffer)].IsInUseCnt=1u)        /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_NetBufferRelease(hBuffer)                                (Dcm_PbRamNetBufferContext[Dcm_NetBufIdWrpValue(hBuffer)].IsInUseCnt--)         /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_NetBufferUsageEnter(hBuffer)                             (Dcm_PbRamNetBufferContext[Dcm_NetBufIdWrpValue(hBuffer)].IsInUseCnt++)         /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_NetBufferUsageLeave(hBuffer)                             (Dcm_NetBufferRelease(hBuffer))                                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */

#if(DCM_NET_MULTI_TRANSP_OBJ_ENABLED == STD_ON)
# if(DCM_NET_TRANSP_OBJ_DYN_ALLOC_ENABLED == STD_ON)
#  define Dcm_NetGetTranspObjIdOfConnection(connId)                  (Dcm_PbRamNetConnId2TObjMap[(connId)])                                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_NetGetTranspObjIdOfConnection(connId)                  (connId)                                                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif
# define Dcm_NetGetTranspObjIdForConnection(connectionId)            (Dcm_NetGetTranspObjIdOfConnection(connectionId))                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_NetGetTranspObjIdOfConnection(connId)                   0u                                                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
# if(DCM_NET_MULTI_CONNECT_ENABLED == STD_ON)
#  define Dcm_NetGetTranspObjIdForConnection(connectionId)           ((Dcm_CfgNetTObjHandleMemType)((Dcm_NetGetTranspObjByHandle(0)->ConnId==(connectionId))?0:DCM_NET_INVALID_TOBJID)) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_NetGetTranspObjIdForConnection(connectionId)           0u                                                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif
#endif

#define Dcm_NetGetConnIdOfRxPduId(rxPduId)                           (Dcm_NetConnIdWrpValue(Dcm_PbCfgNetRxPduInfo[(rxPduId)].ConnRef))               /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_NetGetConnIdOfTxPduId(txPduId)                           (Dcm_NetConnIdWrpValue(Dcm_PbCfgNetTxPdu2ConnMap[(txPduId)]))                   /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dcm_NetGetTranspObjIdOfRxPduId(rxPduId)                      (Dcm_NetGetTranspObjIdOfConnection(Dcm_NetGetConnIdOfRxPduId(rxPduId)))         /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_NetGetTranspObjIdOfTxPduId(txPduId)                      (Dcm_NetGetTranspObjIdOfConnection(Dcm_NetGetConnIdOfTxPduId(txPduId)))         /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_NetGetTranspObjByHandle(tObjId)                          (&(Dcm_PbRamNetTransportObject[(tObjId)]))                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* transport object access */
#if(DCM_NET_TRANSP_OBJ_DYN_ALLOC_ENABLED == STD_ON)
/* a function is used */
#else
# define Dcm_NetAllocateOrGetTranspObject                            Dcm_NetGetTranspObjIdOfConnection
#endif

#if(DCM_NET_MULTI_CONNECT_ENABLED == STD_ON)
# define Dcm_NetTranspObjGetConnIdValue(pTranspObj)                  (Dcm_NetConnIdWrpValue((pTranspObj)->ConnId))                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetTranspObjGetConnIdOnly(pTranspObj)                   Dcm_NetConnIdWrpOnly((pTranspObj)->ConnId)                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetTranspObjSetConnId(pTranspObj, value)                ((pTranspObj)->ConnId = Dcm_NetConnIdWrpValue(value))                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_NetTranspObjGetConnIdValue(pTranspObj)                  0                                                                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetTranspObjGetConnIdOnly(pTranspObj)                   /* not used */
# define Dcm_NetTranspObjSetConnId(pTranspObj, value)                /* not used */
#endif

#define Dcm_NetTranspObjGetBufferHandleValue(pTranspObj)             (Dcm_NetBufIdWrpValue((pTranspObj)->BufferHdl))                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_NetTranspObjGetBufferHandleOnly(pTranspObj)              Dcm_NetBufIdWrpOnly((pTranspObj)->BufferHdl)                                    /* PRQA S 3453 */ /* MD_MSR_19.7 */
#if(DCM_NET_MULTI_BUFFER_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
# define Dcm_NetTranspObjSetBufferHandle(pTranspObj, value)          ((pTranspObj)->BufferHdl = Dcm_NetBufIdWrpValue(value))                         /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_NetTranspObjSetBufferHandle(pTranspObj, value)          /* not used */
#endif

#define Dcm_NetGetBufferObjOfTranspObj(pTranspObj)                   (&(Dcm_PbCfgNetBufferInfo[Dcm_NetTranspObjGetBufferHandleValue(pTranspObj)]))   /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_NetGetBufferPtrOfTranspObj(pTranspObj)                   (Dcm_NetGetBufferObjOfTranspObj(pTranspObj)->BufferPtr)                         /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_NetGetBufferSizeOfTranspObj(pTranspObj)                  (Dcm_NetGetBufferObjOfTranspObj(pTranspObj)->Size)                              /* PRQA S 3453 */ /* MD_MSR_19.7 */

#if(DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)                                                                                                        /* COV_DCM_UNSUPPORTED XF */
# define Dcm_NetGetProtIdOfActiveProtocol()                          (Dcm_SingletonContext.Network.ActiveProtocol)                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetGetProtIdOfConnection(connId)                        (Dcm_PbCfgNetConnectionInfo[(connId)].ProtRef)                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetGetProtIdOfTranspObj(pTranspObj)                     (Dcm_NetGetProtIdOfConnection(Dcm_NetTranspObjGetConnIdValue(pTranspObj)))      /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_NetGetProtIdOfActiveProtocol()                          0u                                                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetGetProtIdOfConnection(connId)                        0u                                                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetGetProtIdOfTranspObj(pTranspObj)                     0u                                                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

#define Dcm_NetGetProtObjOfProtId(protId)                            (&Dcm_PbCfgNetProtocolInfo[(protId)])                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_NetGetProtObjOfConnection(connId)                        (Dcm_NetGetProtObjOfProtId(Dcm_NetGetProtIdOfConnection(connId)))               /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_NetGetProtObjOfTranspObj(pTranspObj)                     (Dcm_NetGetProtObjOfConnection(Dcm_NetTranspObjGetConnIdValue(pTranspObj)))     /* PRQA S 3453 */ /* MD_MSR_19.7 */

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
# if (DCM_NET_PERIODIC_TX_CONN_SPECIFIC_NUM_TX_OBJ_ENABLED == STD_ON)
#  define Dcm_NetPeriodicMsgGetTxPduIdByConn(connId, txObjIdx)       (Dcm_PbCfgNetPerTxPduIdInfo[Dcm_PbCfgNetConnectionInfo[(connId)].PeriodicTxRef + (txObjIdx)]) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetPeriodicMsgGetNumMsgsFor(connId)                    (Dcm_PbCfgNetConnectionInfo[(connId)].NumPeriodicTxPduIds)                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_NetPeriodicMsgGetTxPduIdByConn(connId, txObjIdx)       (Dcm_PbCfgNetPerTxPduIdInfo[((connId) * Dcm_PbCfgNetNumPerTxObjects) + (txObjIdx)]) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetPeriodicMsgGetNumMsgsFor(connId)                    ((Dcm_CfgNetPTxObjHandleMemType)Dcm_PbCfgNetNumPerTxObjects)                    /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif

# define Dcm_NetPeriodicMsgGetTxPduIdCurrConn(txObjIdx)              (Dcm_NetPeriodicMsgGetTxPduIdByConn(Dcm_NetPeriodicMsgGetConnection(),(txObjIdx))) /* PRQA S 3453 */ /* MD_MSR_19.7 */

# if (DCM_NET_MULTI_CONNECT_ENABLED == STD_ON)
#  define Dcm_NetPeriodicMsgSetConnection(connId)                    (Dcm_SingletonContext.Network.PeriodicTxContext.ConnIdInUse = (connId))         /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetPeriodicMsgGetConnection()                          (Dcm_SingletonContext.Network.PeriodicTxContext.ConnIdInUse)                    /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetPeriodicMsgResetConnection()                        (Dcm_SingletonContext.Network.PeriodicTxContext.ConnIdInUse = DCM_NET_INVALID_CONNID) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetPeriodicMsgSupportedFor(connId)                     (Dcm_NetPeriodicMsgGetNumMsgsFor(connId) != 0)                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_NetPeriodicMsgSetConnection(connId)                    /* not used */
#  define Dcm_NetPeriodicMsgGetConnection()                          0u
#  define Dcm_NetPeriodicMsgResetConnection()                        /* not used */
#  define Dcm_NetPeriodicMsgSupportedFor(connId)                     /* not used */
# endif

# define Dcm_NetPeriodicMsgGetTxBuffer(txObjHandle)                  (Dcm_PbRamNetPeriodicTxObject[Dcm_NetPTxObjWrpValue(txObjHandle)].TxBuffer)     /* PRQA S 3453 */ /* MD_MSR_19.7 */

# if (DCM_NET_MULTI_PERIODIC_TX_OBJ_ENABLED == STD_ON)
#  define Dcm_NetPeriodicMsgNumMsgsCurrConnection()                  (Dcm_NetPeriodicMsgGetNumMsgsFor(Dcm_NetPeriodicMsgGetConnection()))            /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetPeriodicMsgGetHandleFromTxPduId(txPduId)            ((Dcm_CfgNetPTxObjHandleOptType)(Dcm_PbCfgNetPerTxPdu2RsrsMap[txPduId]))        /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_NetPeriodicMsgNumMsgsCurrConnection()                  ((Dcm_CfgNetPTxObjHandleOptType)1u)                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetPeriodicMsgGetHandleFromTxPduId(txPduId)            ((Dcm_CfgNetPTxObjHandleOptType)0u)                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif

# if (DCM_NET_PTXOBJ_LIMITER_ENABLED == STD_ON)
#  define Dcm_NetPeriodicMsgResetMsgCounter()                        (Dcm_SingletonContext.Network.PeriodicTxContext.TxObjectCntr = Dcm_NetPeriodicMsgNumMsgsCurrConnection()) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetPeriodicMsgDecMsgCounter()                          (--Dcm_SingletonContext.Network.PeriodicTxContext.TxObjectCntr)                 /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetPeriodicMsgResetMsgHdl()                            (Dcm_SingletonContext.Network.PeriodicTxContext.NextTxObjectHdl = 0u)           /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetPeriodicMsgNextMsgHdl()                             {++Dcm_SingletonContext.Network.PeriodicTxContext.NextTxObjectHdl; if(Dcm_SingletonContext.Network.PeriodicTxContext.NextTxObjectHdl >= Dcm_NetPeriodicMsgNumMsgsCurrConnection()){Dcm_NetPeriodicMsgResetMsgHdl();}  } /* PRQA S 3412, 3453, 3458 */ /* MD_MSR_19.4, MD_MSR_19.7 */
# else
#  define Dcm_NetPeriodicMsgResetMsgCounter()                        /* not used */
#  define Dcm_NetPeriodicMsgDecMsgCounter()                          /* not used */
#  define Dcm_NetPeriodicMsgResetMsgHdl()                            /* not used */
#  define Dcm_NetPeriodicMsgNextMsgHdl()                             /* not used */
# endif

# if(DCM_NET_PTXOBJ_SOFT_TIMER_ENABLED == STD_ON)
#  define Dcm_NetPTxObjTimerStart(perTxObjHandle, value)             {if(Dcm_TmrGetTimer(DCM_TMR_ID_PERIODIC_TX) == 0){Dcm_TmrStartTimer(DCM_TMR_ID_PERIODIC_TX, 1u);}Dcm_SplitTaskEnterCS(); Dcm_PbRamNetPeriodicTxObject[(perTxObjHandle)].Timer = (Dcm_TmrTimerCntrMemType)(value); Dcm_SplitTaskLeaveCS();  } /* PRQA S 3109, 3412, 3453, 3458 */ /* MD_MSR_14.3, MD_MSR_19.4, MD_MSR_19.7 */
#  define Dcm_NetPTxObjTimerStop(perTxObjHandle)                     {Dcm_SplitTaskEnterCS(); Dcm_PbRamNetPeriodicTxObject[(perTxObjHandle)].Timer = 0u; Dcm_SplitTaskLeaveCS();  } /* PRQA S 3109, 3412, 3453, 3458 */ /* MD_MSR_14.3, MD_MSR_19.4, MD_MSR_19.7 */
#  define Dcm_NetPTxObjTimerExpired(perTxObjHandle)                  (Dcm_PbRamNetPeriodicTxObject[(perTxObjHandle)].Timer == 0u)                    /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetPTxObjTimerDec(perTxObjHandle)                      (--Dcm_PbRamNetPeriodicTxObject[(perTxObjHandle)].Timer)                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
/* on single object usage - use the "HW" timer */
#  define Dcm_NetPTxObjTimerStart(perTxObjHandle, value)             (Dcm_TmrStartTimer(DCM_TMR_ID_PERIODIC_TX, value))                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetPTxObjTimerStop(perTxObjHandle)                     (Dcm_TmrStopTimer(DCM_TMR_ID_PERIODIC_TX))                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetPTxObjTimerExpired(perTxObjHandle)                  /* not used */
#  define Dcm_NetPTxObjTimerDec(perTxObjHandle)                      /* not used */
# endif

#endif /* (DCM_NET_PERIODIC_TX_ENABLED == STD_ON) */

#if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
# define Dcm_NetGetSessionConnection()                               (Dcm_SingletonContext.Network.SessionConnection)                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetSetSessionConnection(connId)                         (Dcm_SingletonContext.Network.SessionConnection = (connId))                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_NetGetSessionConnection()                               /* not used */
# define Dcm_NetSetSessionConnection(connId)                         /* not used */
#endif

#define Dcm_NetGetComStateByChannelId(channelId)                     (Dcm_PbRamNetComMContext[Dcm_NetChnlIdComMWrpValue(channelId)].ComState)        /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_NetGetComStateByConnection(connId)                       (Dcm_NetGetComStateByChannelId(Dcm_PbCfgNetConnectionInfo[Dcm_NetConnIdWrpValue(connId)].NetworkIdRef)) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_NetGetComStateByRxPduId(rxPduId)                         (Dcm_NetGetComStateByConnection(Dcm_NetGetConnIdOfRxPduId(rxPduId)))            /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dcm_NetGetComStateByTranspObject(pTranspObj)                 (Dcm_NetGetComStateByConnection(Dcm_NetTranspObjGetConnIdValue(pTranspObj)))    /* PRQA S 3453 */ /* MD_MSR_19.7 */

#if (DCM_NET_CONN_PROPERTIES_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
# define Dcm_NetGetProperties(pTranspObj)                            (Dcm_PbCfgNetConnectionInfo[Dcm_NetTranspObjGetConnIdValue(pTranspObj)].Properties) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetIsPropertieSet(pTranspObj, prop)                     (Dcm_UtiBitOpTest(Dcm_CfgNetConnPropertiesType, Dcm_NetGetProperties(pTranspObj), (prop))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_NetGetProperties(pTranspObj)                            /* not used */
# define Dcm_NetIsPropertieSet(pTranspObj, prop)                     /* not used */
#endif
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)                                                                                                  /* COV_DCM_UNSUPPORTED XF */
# define Dcm_NetArEnvComMActiveDiag(channel)                         (ComM_DCM_ActiveDiagnostic())                                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetArEnvComMInactiveDiag(channel)                       (ComM_DCM_InactiveDiagnostic())                                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* Use PDU-R AR 3.2.x cancellation API */
# define Dcm_NetArEnvPduRCancelReceive(rxPduId)                      (PduR_DcmCancelReceive((rxPduId)))                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetArEnvPduRCancelTransmit(txPduId)                     (PduR_DcmCancelTransmit((txPduId)))                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetArEnvGetTransmResult(notifResult)                    ((Dcm_NetTransmissionResultType)(((notifResult) == DCM_NET_ARENV_NTFRSLT_OK)?DCM_E_OK:DCM_E_NOT_OK)) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)                                                                                                  /* COV_DCM_SUPPORT_PARTIALLY TX tx xf */
# define Dcm_NetArEnvComMActiveDiag(channel)                         (ComM_DCM_ActiveDiagnostic((channel)))                                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_NetArEnvComMInactiveDiag(channel)                       (ComM_DCM_InactiveDiagnostic((channel)))                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */

# if (DCM_PDUR_API_401_ENABLED == STD_ON)                                                                                                            /* COV_DCM_UNSUPPORTED XF */
#  define Dcm_NetArEnvGetTransmResult(notifResult)                   ((Dcm_NetTransmissionResultType)(((notifResult) == DCM_NET_ARENV_NTFRSLT_OK)?DCM_E_OK:DCM_E_NOT_OK)) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetArEnvPduRCancelReceive(rxPduId)                     (PduR_DcmCancelReceiveRequest((rxPduId)))                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetArEnvPduRCancelTransmit(txPduId)                    (PduR_DcmCancelTransmitRequest((txPduId)))                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
# elif (DCM_PDUR_API_403_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
#  define Dcm_NetArEnvGetTransmResult(notifResult)                   ((Dcm_NetTransmissionResultType)(((notifResult) == DCM_NET_ARENV_NTFRSLT_OK)?DCM_E_OK:DCM_E_NOT_OK)) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetArEnvPduRCancelReceive(rxPduId)                     (PduR_DcmCancelReceive((rxPduId)))                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetArEnvPduRCancelTransmit(txPduId)                    (PduR_DcmCancelTransmit((txPduId)))                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
# elif (DCM_PDUR_API_412_ENABLED == STD_ON)                                                                                                          /* COV_DCM_SUPPORT_ALWAYS TX */
#  define Dcm_NetArEnvGetTransmResult(notifResult)                   (notifResult)                                                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetArEnvPduRCancelReceive(rxPduId)                     (PduR_DcmCancelReceive((rxPduId)))                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_NetArEnvPduRCancelTransmit(txPduId)                    (PduR_DcmCancelTransmit((txPduId)))                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  error "Unsupported PduR version!"
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
#if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
# define Dcm_RepeaterSetUser(repUser)                                (Dcm_InstanceContext.Repeater.Contexts.User = (repUser))                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_RepeaterSetUser(repUser)                                /* not used */
#endif

#define Dcm_RepeaterResetOpStatus()                                  (Dcm_InstanceContext.Repeater.Contexts.OpStatus = DCM_INITIAL)
#if (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON)                                                                                                          /* COV_DCM_SUPPORT_ALWAYS TX */
# if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
#  define Dcm_ModeGetCommControlState(networkRef)                    (Dcm_PbRamNetComCtrlChannels[(networkRef)])                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_ModeSetCommControlState(networkRef, mode)              (Dcm_PbRamNetComCtrlChannels[(networkRef)] = (mode))                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif

# if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
#  define Dcm_ModeGetControlDtcSettingMode()                         (Dcm_SingletonContext.ModeMgr.CtrlDtcSetting.Mode)                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_ModeSetControlDtcSettingMode(newMode)                  (Dcm_SingletonContext.ModeMgr.CtrlDtcSetting.Mode = (newMode))                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_ModeGetControlDtcSettingMode()                         /* not used */
#  define Dcm_ModeSetControlDtcSettingMode(newMode)                  /* not used */
# endif

# if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON) && \
     (DCM_SVC_85_DTC_GRP_ENABLED == STD_ON)
#  define Dcm_ModeGetControlDtcSettingGroup()                        (Dcm_SingletonContext.ModeMgr.CtrlDtcSetting.DTCGroup)                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_ModeSetControlDtcSettingGroup(newGroup)                (Dcm_SingletonContext.ModeMgr.CtrlDtcSetting.DTCGroup = (newGroup))             /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_ModeGetControlDtcSettingGroup()                        /* not used */
#  define Dcm_ModeSetControlDtcSettingGroup(newGroup)                /* not used */
# endif
#endif /* (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)                                                                                                  /* COV_DCM_UNSUPPORTED XF */
# define Dcm_ModeArEnvBswMComControlModeChange(network, newMode)     (BswM_Dcm_RequestCommunicationMode((network), (newMode)))                       /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dcm_ModeMgrArEnvSwitchReqEcuReset(newMode)                  (Dcm_ModeSwitchEcuReset(newMode))                                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_ModeMgrArEnvSwitchAckEcuReset()                         (Dcm_ModeSwitchAckEcuReset())                                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dcm_ModeMgrArEnvSwitchReqRapidPowerShutDown(newMode)        (Dcm_ModeSwitchEcuReset(newMode))                                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_ModeMgrArEnvSwitchAckRapidPowerShutDown()               (Dcm_ModeSwitchAckEcuReset())                                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)                                                                                                  /* COV_DCM_SUPPORT_PARTIALLY TX tx xf */
# define Dcm_ModeArEnvBswMComControlModeChange(network, newMode)     (BswM_Dcm_CommunicationMode_CurrentState((network), (newMode)))                 /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dcm_ModeMgrArEnvSwitchReqEcuReset(newMode)                  (Dcm_ModeSwitchEcuReset(newMode))                                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_ModeMgrArEnvSwitchAckEcuReset()                         (Dcm_ModeSwitchAckEcuReset())                                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dcm_ModeMgrArEnvSwitchReqRapidPowerShutDown(newMode)        (Dcm_ModeSwitchRapidShutDown(newMode))                                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_ModeMgrArEnvSwitchAckRapidPowerShutDown()               (Dcm_ModeSwitchAckRapidShutDown())                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
#if (DCM_STATE_PEND_SESS_SUPPORT_ENABLED == STD_ON)
# define Dcm_StateSetPendingSession(session)                         (Dcm_SingletonContext.StateMgr.PendingSession = (session))                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_StateGetPendingSession()                                (Dcm_SingletonContext.StateMgr.PendingSession)                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_StateSetPendingSession(session)                         /* not used */
# define Dcm_StateGetPendingSession()                                /* not used */
#endif
#define Dcm_StateSyncPendingSession()                                Dcm_StateSetPendingSession(Dcm_SingletonContext.StateMgr.Preconditions.Session) /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dcm_StateGetPreconditionStates(stateRef)                     (Dcm_CfgStatePreconditions[(stateRef)].States)                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_StateGetSession()                                        (Dcm_SingletonContext.StateMgr.Preconditions.Session)                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_StateGetPreconditionSession(stateRef)                    (Dcm_StateGetPreconditionStates(stateRef).Session)                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
# define Dcm_StateGetSecurity()                                      (Dcm_SingletonContext.StateMgr.Preconditions.Security)                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_StateGetPreconditionSecurity(stateRef)                  (Dcm_StateGetPreconditionStates(stateRef).Security)                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif
#define Dcm_StateIsDefaultSessionActive()                            ((Dcm_StateGetSession() & DCM_STATE_VALUE_SESSION_INIT) != 0)                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_StateIsSupportedInSession(precondition)                  ((Dcm_StateGetSession() & (precondition).Session) != 0)                         /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_StateGetSessionValue(stateIdx)                           (Dcm_CfgStateSessionInfo[stateIdx].Value)                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */

#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
# define Dcm_StateIsSecurityLocked()                                 ((Dcm_StateGetSecurity() & DCM_STATE_VALUE_SECURITY_INIT) != 0)                 /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_StateIsSupportedInSecurityLevel(precondition)           ((Dcm_StateGetSecurity() & (precondition).Security) != 0)                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_StateGetSecurityValue(stateIdx)                         ((Dcm_SecLevelType)(((stateIdx) == 0)?0u:Dcm_CfgStateSecurityInfo[(stateIdx)-1u].Value)) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif
#define Dcm_TskGetEvent(taskId)                                      (Dcm_SingletonContext.TaskMgr.TaskContext[(taskId)].TaskEvents)                 /* PRQA S 3453 */ /* MD_MSR_19.7 */

#if (DCM_TSK_TASK_FLAG_SUPPORT_ENABLED == STD_ON)                                                                                                    /* COV_DCM_UNSUPPORTED XF */
# define Dcm_TskGetFlag(taskId)                                      (Dcm_SingletonContext.TaskMgr.TaskContext[(taskId)].TaskFlags)                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_TskIsFlagSet(taskId, flg)                               (Dcm_UtiBitOpTest(Dcm_TskTaskFlagType, Dcm_SingletonContext.TaskMgr.TaskContext[(taskId)].TaskFlags, (flg))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_TskSetFlag(taskId, flg)                                 (Dcm_UtiBitOpSet(Dcm_TskTaskFlagType, Dcm_SingletonContext.TaskMgr.TaskContext[(taskId)].TaskFlags, (flg))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_TskClrFlag(taskId, flg)                                 (Dcm_UtiBitOpClr(Dcm_TskTaskFlagType, Dcm_SingletonContext.TaskMgr.TaskContext[(taskId)].TaskFlags, (flg))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_TskGetFlag(taskId)                                      0 /* not used */
# define Dcm_TskIsFlagSet(taskId)                                    FALSE /* not used */
# define Dcm_TskSetFlag(taskId, flg)                                 /* not used */
# define Dcm_TskClrFlag(taskId, flg)                                 /* not used */
#endif

#if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
# define Dcm_TskWrapPrioValue(taskPrio)                              (taskPrio)                                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_TskGetPrioValue(taskId)                                 (dcmTsk_TaskInfo[(taskId)].TskPrio)                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_TskWrapPrioValue(taskPrio)                              (DCM_TSK_PRIO_LOW)                                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_TskGetPrioValue(taskId)                                 (DCM_TSK_PRIO_LOW)                                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

#if (DCM_TSK_TRACING_ENABLED == STD_ON)
# define Dcm_TskTraceInit()                                          (Dcm_UtiStackInit(Dcm_SingletonContext.TaskMgr.CurrentTaskPrioStack))           /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_TskTraceTskPush(taskId)                                 (Dcm_UtiStackPush(Dcm_SingletonContext.TaskMgr.CurrentTaskPrioStack, (Dcm_TskMgrTraceStackBaseType)(taskId))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_TskTraceTskPop()                                        (Dcm_UtiStackPop(Dcm_SingletonContext.TaskMgr.CurrentTaskPrioStack))            /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_TskTraceIsFull()                                        (Dcm_UtiStackIsFull(Dcm_SingletonContext.TaskMgr.CurrentTaskPrioStack, Dcm_TskMgrTraceStackBaseType)) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_TskTraceIsEmpty()                                       (Dcm_UtiStackIsEmpty(Dcm_SingletonContext.TaskMgr.CurrentTaskPrioStack))        /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dcm_TskTraceGetCurrTskId()                                  (Dcm_UtiStackTop(Dcm_SingletonContext.TaskMgr.CurrentTaskPrioStack))            /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_TskTraceGetCurrTskPrio()                                (Dcm_TskGetPrioValue(Dcm_TskTraceGetCurrTskId()))                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_TskTraceInit()                                          /* not used */
# define Dcm_TskTraceTskPush(taskId)                                 /* not used */
# define Dcm_TskTraceTskPop()                                        /* not used */
# define Dcm_TskTraceIsFull()                                        /* not used */
# define Dcm_TskTraceIsEmpty()                                       /* not used */

# define Dcm_TskTraceGetCurrTskId()                                  /* not used */
# define Dcm_TskTraceSetCurrTskPrio()                                /* not used */
#endif
#define Dcm_TmrGetTimer(timerId)                                     (Dcm_SingletonContext.TimerMgr.Timer[(timerId)])                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define Dcm_DidMgrIsOpSupported(pDidInfo,   op)                     (((op) & (pDidInfo)->Operations) != 0)                                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_DidMgrIsOpTypeSupported(pDidOpInfo, opType)             (((opType) & (pDidOpInfo)->CallTypes) != 0)                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */

# if (DCM_DIDMGR_DYNDID_DEEP_CHECK_ON_READ_ENABLED == STD_ON)
/* a real function is used for optimal code size */
# else
#  define Dcm_DidMgrDynDidStateCheck(pDidInfoContext)                (Dcm_DidMgrStaticDidStateCheck((pDidInfoContext)->Descriptor.DidOpInfoPtr->ExecCondRef)) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif

# define Dcm_DidMgrStaticDidStateCheck(ExecCondRef)                  (Dcm_StateCheck((ExecCondRef), DCM_DIAG_CHK_LVL_PARAMETER))                     /* PRQA S 3453 */ /* MD_MSR_19.7 */

# if (DCM_DIDMGR_OP_INFO_COMBINED_ENABLED == STD_ON)
#  define Dcm_DidMgrOpInfoRedirector(opRef, opRefType)               (Dcm_CfgDidMgrOpInfoCombined[(opRef)].opRefType)                                /* PRQA S 3453, 3410 */ /* MD_MSR_19.7, MD_Dcm_AbstractTokenReplacment_3410 */
# else
#  define Dcm_DidMgrOpInfoRedirector(opRef, opRefType)               (opRef)                                                                         /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif

# if (DCM_DIDMGR_IO_MASKRECORD_ENABLED == STD_ON)
#  define Dcm_DidMgrGetCtrlEnblMaskLength(pDidInfo)                  (Dcm_CfgDidMgrOpInfoIoControl[Dcm_DidMgrOpInfoRedirector((pDidInfo)->OpRef, OpRefIoControl)].CtrlEnblMaskLength) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_DidMgrGetCtrlEnblMaskLength(pDidInfo)                  0u                                                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif

# define Dcm_DidMgrGetCtrlOpInfoRef(opRef)                           (Dcm_CfgDidMgrOpInfoIoControl[Dcm_DidMgrOpInfoRedirector(opRef, OpRefIoControl)].RetCtrlToEcuOpRef) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_DidMgrGetCtrlOpExecCondRef(opRef)                       (Dcm_CfgDidMgrOpInfoIoControl[Dcm_DidMgrOpInfoRedirector(opRef, OpRefIoControl)].CtrlExecCondRef) /* PRQA S 3453 */ /* MD_MSR_19.7 */

# if (DCM_DIDMGR_OP_INFO_SCALING_ENABLED == STD_ON)
#  define Dcm_DidMgrGetScalingLayoutRef(pDidInfo)                    (Dcm_CfgDidMgrOpInfoScaling[Dcm_DidMgrOpInfoRedirector((pDidInfo)->OpRef, OpRefScaling)].ScalingInfoRef) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_DidMgrGetSignalScalingSize(pDidInfo)                   (Dcm_CfgDidMgrSignalScalingInfo[Dcm_DidMgrGetScalingLayoutRef(pDidInfo)])       /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif

# if (DCM_DIDMGR_DYNDID_VAR_NUM_ITEMS_ENABLED == STD_ON)
#  define Dcm_DidMgrGetDynDidSize(dynDidHandle)                      (Dcm_CfgDidMgrOpInfoDefine[(dynDidHandle)].NumItems)                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_DidMgrGetDynDidSrcItemStartRef(dynDidHandle)           (Dcm_CfgDidMgrOpInfoDefine[(dynDidHandle)].SrcItemRef)                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_DidMgrGetDynDidSize(dynDidHandle)                      ((uint8)DCM_NUM_ITEMS_PER_DYNDID)                                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_DidMgrGetDynDidSrcItemStartRef(dynDidHandle)           ((Dcm_CfgDidMgrDynDidSrcItemIdxMemType)((Dcm_CfgDidMgrDynDidSrcItemIdxMemType)(dynDidHandle)) * ((uint8)DCM_NUM_ITEMS_PER_DYNDID)) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif
# if (DCM_DIDMGR_DYNDID_CLR_ON_STATE_CHG_ENABLED == STD_ON)
#  define Dcm_DidMgrGetDynDidReadExecPrecond(dynDidHandle)           (Dcm_CfgDidMgrOpInfoDefine[(dynDidHandle)].ReadExecCondRef)                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif
# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON)
#  define Dcm_DidMgrGetDynDidIdFromHandle(dynDidHandle)              ((Dcm_CfgDidMgrOpInfoDefine[(dynDidHandle)].Did))                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif

# if (DCM_DIDMGR_MULTISIGNAL_ENABLED == STD_ON)
#  define Dcm_DidMgrGetOpClassRef(opInfoRef)                         (Dcm_CfgDidMgrDidOpClassInfo[(opInfoRef)].OpClassRef)                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_DidMgrGetOpClassRef(opInfoRef)                         (opInfoRef)                                                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define Dcm_RidMgrConvOpOfSubFunc(sf)                               ((Dcm_RidMgrOpType)(((sf) < 4)?Dcm_RidMgrSubFunc2OpMap[(sf)]:0u))               /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_RidMgrStateCheckRid(execCondRef)                        (Dcm_StateCheck((execCondRef), DCM_DIAG_CHK_LVL_PARAMETER))                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON) */
/* API mapping */
#if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
# define Dcm_SplitTaskEnterCS()                                      Dcm_UtiArEnvEnterCriticalSection()                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_SplitTaskLeaveCS()                                      Dcm_UtiArEnvLeaveCriticalSection()                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_SplitTaskEnterCS()                                      /* Not used */
# define Dcm_SplitTaskLeaveCS()                                      /* Not used */
#endif
#if(DCM_NET_MULTI_TRANSP_OBJ_ENABLED == STD_ON)
# define Dcm_DiagGetTranspObj()                                      (Dcm_InstanceContext.Diag.TranspObj)                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_DiagSetTranspObj(tObjPtr)                               (Dcm_InstanceContext.Diag.TranspObj = (tObjPtr))                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_DiagClrTranspObj()                                      (Dcm_InstanceContext.Diag.TranspObj = NULL_PTR)                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */
# if (DCM_DIAG_TOBJ_QUEUE_ENABLED == STD_ON)                                                                                                         /* COV_DCM_UNSUPPORTED XF */
#  define Dcm_DiagGetQueuedTranspObj()                               (Dcm_InstanceContext.Diag.QueuedSet.TranspObj)                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  if (DCM_DIAG_GARB_COL_ENABLED == STD_ON)
#   define Dcm_DiagSetQueuedTranspObj(tObjPtr)                       { \
                                                                     Dcm_InstanceContext.Diag.QueuedSet.TranspObj = (tObjPtr); \
                                                                     Dcm_UtiBitOpSet(Dcm_TskTaskEvMemType, Dcm_InstanceContext.Diag.QueuedSet.QueuedTObjects, (Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, (tObjPtr)->Handle))); \
                                                                     }                                                                               /* PRQA S 3453, 3458 */ /* MD_MSR_19.7, MD_MSR_19.4 */
#  else
#   define Dcm_DiagSetQueuedTranspObj(tObjPtr)                       (Dcm_InstanceContext.Diag.QueuedSet.TranspObj = (tObjPtr))                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  endif
#  define Dcm_DiagClrQueuedTranspObj()                               (Dcm_InstanceContext.Diag.QueuedSet.TranspObj = NULL_PTR)                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_DiagGetQueuedTranspObj()                               Dcm_DiagGetTranspObj()                                                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_DiagSetQueuedTranspObj(tObjPtr)                        Dcm_DiagSetTranspObj(tObjPtr)                                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_DiagClrQueuedTranspObj()                               Dcm_DiagClrTranspObj()                                                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif
#else
# define Dcm_DiagGetTranspObj()                                      (Dcm_NetGetTranspObjByHandle(0))                                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_DiagSetTranspObj(tObjPtr)                               /* not used */
# define Dcm_DiagClrTranspObj()                                      /* not used */
# define Dcm_DiagGetQueuedTranspObj()                                Dcm_DiagGetTranspObj()                                                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_DiagSetQueuedTranspObj(tObjPtr)                         Dcm_DiagSetTranspObj(tObjPtr)                                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_DiagClrQueuedTranspObj()                                Dcm_DiagClrTranspObj()                                                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

#if (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
# define Dcm_DiagRcrRpLimiterReset()                                 (Dcm_InstanceContext.Diag.NumRcrRpTimeouts = DCM_DIAG_RCRRP_LIMIT_COUNT)        /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_DiagRcrRpLimiterReset()                                 /* not used */
#endif
/* Utility for set/unset variant bits in a bit field */
#define Dcm_VarMgrBitSetCalcSize(bits)                               (Dcm_UtiBitSetCalcSize(Dcm_CfgVarMgrBitSetBaseType, (bits)))                    /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_VarMgrBitSetTestBit(bitSet, bit)                         (Dcm_UtiBitSetTestBit(Dcm_CfgVarMgrBitSetBaseType, (bitSet), (bit)))            /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_VarMgrBitSetSetBit(bitSet, bit)                          (Dcm_UtiBitSetSetBit(Dcm_CfgVarMgrBitSetBaseType, (bitSet), (bit)))             /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dcm_VarMgrBitSetClrBit(bitSet, bit)                          (Dcm_UtiBitSetClrBit(Dcm_CfgVarMgrBitSetBaseType, (bitSet), (bit)))             /* PRQA S 3453 */ /* MD_MSR_19.7 */

#if(DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON)
# define Dcm_EcuMErrorNotification(errorCode)                        (EcuM_BswErrorHook((uint16) DCM_MODULE_ID, (uint8) (errorCode)))                /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dcm_EcuMErrorNotification(errorCode)                        /* not used */
#endif
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
# if !defined(Dcm_ExtSvc19UtiPatchDtcStatusInit)                                                                                                     /* COV_DCM_UNSUPPORTED TX */
#  define Dcm_ExtSvc19UtiPatchDtcStatusInit()                        /* not used */
# endif
# if !defined(Dcm_ExtSvc19UtiPatchDtcStatusApplyByRequest)                                                                                           /* COV_DCM_UNSUPPORTED TX */
#  define Dcm_ExtSvc19UtiPatchDtcStatusApplyByRequest(dtcStatusPtr)  /* not used */
# endif
# if !defined(Dcm_ExtSvc19UtiPatchDtcStatusApplyByResult)                                                                                            /* COV_DCM_UNSUPPORTED TX */
#  define Dcm_ExtSvc19UtiPatchDtcStatusApplyByResult(dtcStatusPtr)   /* not used */
# endif
# if !defined(Dcm_ExtSvc19UtiPatchDtcStatusSetForApply)                                                                                              /* COV_DCM_UNSUPPORTED TX */
#  define Dcm_ExtSvc19UtiPatchDtcStatusSetForApply()                 /* not used */
# endif
# if !defined(Dcm_ExtSvc19UtiPatchDtcStatusSetForFilter)                                                                                             /* COV_DCM_UNSUPPORTED TX */
#  define Dcm_ExtSvc19UtiPatchDtcStatusSetForFilter(dtcStatusMaskPtr) /* not used */
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define Dcm_Svc27ResetSequence()                                    (Dcm_InstanceContext.Diag.Services.Svc27.SeedLevel = DCM_SVC_27_SEED_LVL_INVALID) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc27GetLevOfSubFuncIdx(subFuncIdx)                     ((uint8)((subFuncIdx) / 2u))                                                    /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc27GetCurReqLev()                                     (Dcm_Svc27GetLevOfSubFuncIdx(Dcm_InstanceContext.Repeater.Contexts.Context.Svc27.SfIdx)) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# if (DCM_STATE_SECURITY_MULTI_LEVELS_ENABLED == STD_ON)
#  define Dcm_Svc27GetCurReqLevAttemptIdx()                          (Dcm_Svc27GetCurReqLev())                                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_Svc27GetCurReqLevAttemptIdx()                          0u
# endif

# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
#  if (DCM_STATE_SEC_DELAY_TIME_ON_FAILED_GET_ATT_CNTR_ENABLED == STD_ON)
#   define Dcm_Svc27ReloadReadFailedGet(secLev)                      (Dcm_UtiBitOpTest(uint32, Dcm_InstanceContext.Diag.Services.Svc27.ReloadMask, Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvOptType, (secLev)))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#   define Dcm_Svc27ReloadReadFailedSet(secLev)                      (Dcm_UtiBitOpSet(uint32, Dcm_InstanceContext.Diag.Services.Svc27.ReloadMask, Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvOptType, (secLev)))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  else
#   define Dcm_Svc27ReloadReadFailedGet(secLev)                      /* not used */
#   define Dcm_Svc27ReloadReadFailedSet(secLev)                      /* not used */
#  endif
#  if (DCM_SVC_27_MULTI_ATTEMPT_COUNTER_ENABLED == STD_ON)
#   define Dcm_Svc27CounterSet(secLev, value)                        (Dcm_InstanceContext.Diag.Services.Svc27.AttemptCount[(secLev)] = (value))      /* PRQA S 3453 */ /* MD_MSR_19.7 */
#   define Dcm_Svc27CounterReset(secLev)                             (Dcm_InstanceContext.Diag.Services.Svc27.AttemptCount[(secLev)] = 0u)           /* PRQA S 3453 */ /* MD_MSR_19.7 */
#   define Dcm_Svc27CounterInc(secLev)                               {if(Dcm_Svc27CounterGet(secLev) < Dcm_UtiMaxValueOfUintType(uint8)) {++Dcm_InstanceContext.Diag.Services.Svc27.AttemptCount[(secLev)];} } /* PRQA S 3453, 3458 */ /* MD_MSR_19.7, MD_MSR_19.4 */
#   define Dcm_Svc27CounterGet(secLev)                               (Dcm_InstanceContext.Diag.Services.Svc27.AttemptCount[(secLev)])                /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  else
#   define Dcm_Svc27CounterSet(secLev, value)                        (Dcm_InstanceContext.Diag.Services.Svc27.AttemptCount[0] = (value))             /* PRQA S 3453 */ /* MD_MSR_19.7 */
#   define Dcm_Svc27CounterReset(secLev)                             (Dcm_InstanceContext.Diag.Services.Svc27.AttemptCount[0] = 0u)                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
#   define Dcm_Svc27CounterInc(secLev)                               {if(Dcm_Svc27CounterGet(0) < Dcm_UtiMaxValueOfUintType(uint8)) {++Dcm_InstanceContext.Diag.Services.Svc27.AttemptCount[0];} } /* PRQA S 3453, 3458 */ /* MD_MSR_19.7, MD_MSR_19.4 */
#   define Dcm_Svc27CounterGet(secLev)                               (Dcm_InstanceContext.Diag.Services.Svc27.AttemptCount[0])                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  endif
#  if(DCM_SVC_27_SOFT_TIMER_ENABLED == STD_ON)
#   define Dcm_Svc27TimerSet(secLev, time)                           {Dcm_SplitTaskEnterCS(); Dcm_InstanceContext.Diag.Services.Svc27.DelayTime[(secLev)] = (Dcm_Svc27TimerType)(time); Dcm_SplitTaskLeaveCS(); } /* PRQA S 3109, 3453, 3458 */ /* MD_MSR_14.3, MD_MSR_19.4, MD_MSR_19.7*/
#   define Dcm_Svc27TimerGet(secLev)                                 (Dcm_InstanceContext.Diag.Services.Svc27.DelayTime[(secLev)])                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
#   define Dcm_Svc27TimerReset(secLev)                               (Dcm_InstanceContext.Diag.Services.Svc27.DelayTime[(secLev)] = 0u)              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#   define Dcm_Svc27TimerStart(secLev)                               {if(Dcm_TmrGetTimer(DCM_TMR_ID_SECURITY_0) == 0){Dcm_TmrStartTimer(DCM_TMR_ID_SECURITY_0, 1u);/* start with one tick */} } /* PRQA S 3453, 3458 */ /* MD_MSR_19.4, MD_MSR_19.7*/
#   define Dcm_Svc27TimerExpired(secLev)                             (Dcm_InstanceContext.Diag.Services.Svc27.DelayTime[(secLev)] == 0u)             /* PRQA S 3453 */ /* MD_MSR_19.7 */
#   define Dcm_Svc27TimerDec(secLev)                                 (--Dcm_InstanceContext.Diag.Services.Svc27.DelayTime[(secLev)])                 /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  else
#   define Dcm_Svc27TimerSet(secLev, time)                           {Dcm_SplitTaskEnterCS(); Dcm_InstanceContext.Diag.Services.Svc27.DelayTime[0] = (Dcm_Svc27TimerType)(time); Dcm_SplitTaskLeaveCS(); } /* PRQA S 3109, 3453, 3458 */ /* MD_MSR_14.3, MD_MSR_19.4, MD_MSR_19.7*/
#   define Dcm_Svc27TimerGet(secLev)                                 (Dcm_InstanceContext.Diag.Services.Svc27.DelayTime[0])                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
#   define Dcm_Svc27TimerReset(secLev)                               (Dcm_InstanceContext.Diag.Services.Svc27.DelayTime[0] = 0u)                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
#   define Dcm_Svc27TimerStart(secLev)                               (Dcm_TmrStartTimer(DCM_TMR_ID_SECURITY_0, Dcm_InstanceContext.Diag.Services.Svc27.DelayTime[0])) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#   define Dcm_Svc27TimerExpired(secLev)                             (Dcm_TmrGetTimer(DCM_TMR_ID_SECURITY_0) == 0)                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
#   define Dcm_Svc27TimerDec(secLev)                                 /* not used */
#  endif
# else
#  define Dcm_Svc27CounterSet(secLev, value)                         /* not used */
#  define Dcm_Svc27CounterReset(secLev)                              /* not used */
#  define Dcm_Svc27CounterInc(secLev)                                /* not used */
#  define Dcm_Svc27CounterGet(secLev)                                /* not used */
#  define Dcm_Svc27TimerSet(secLev, time)                            /* not used */
#  define Dcm_Svc27TimerGet(secLev)                                  /* not used */
#  define Dcm_Svc27TimerReset(secLev)                                /* not used */
#  define Dcm_Svc27TimerStart(secLev, time)                          /* not used */
#  define Dcm_Svc27TimerExpired(secLev)                              /* not used */
#  define Dcm_Svc27TimerDec(secLev)                                  /* not used */
# endif
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_28_USER_ENABLED == STD_ON)
#  define Dcm_Svc28IsInternallyProcessed()                           (Dcm_InstanceContext.Repeater.Contexts.Context.Svc28.IsInternallyProcessed == TRUE) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_Svc28SetInternallyProcessed(state)                     (Dcm_InstanceContext.Repeater.Contexts.Context.Svc28.IsInternallyProcessed = (state)) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_Svc28IsInternallyProcessed()                           /* Not used */
#  define Dcm_Svc28SetInternallyProcessed(state)                     /* Not used */
# endif
#endif /* (DCM_SVC_28_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define Dcm_Svc2ASchdGetFreeSpace()                                 ((Dcm_Svc2ASchdItemHandleMemType)(DCM_SVC_2A_SCHEDULER_SIZE - Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries)) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc2AGetSchedulingTimeOfEntry(pSchedTableEntry)         (Dcm_CfgSvc2ASchdRateTime[(pSchedTableEntry)->Rate & DCM_SVC2A_RATE_TYPE_MASK]) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define Dcm_Svc2AIsPeriodicDid(did)                                 ((((uint16)(did)) & 0xFF00u) == 0xF200u)                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc2AMakePeriodicDid(didLoByte)                         (Dcm_UtiMake16Bit((uint8)0xF2u, (didLoByte)))                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc2AMakeSchdRateFromUdsRate(udsRate)                   (Dcm_Svc2ASchedRateMemType)((udsRate)-1u)                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_SVC_2C_HYBRID_MODE_ENABLED == STD_ON)
#  define Dcm_Svc2CIsDidSrcItem(srcItemIdx)                          (Dcm_UtiGenericBitSetTestBit(Dcm_InstanceContext.Diag.Services.Svc2C.Sequencer,(srcItemIdx))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_Svc2CSetDidSrcItem(srcItemIdx)                         (Dcm_UtiGenericBitSetSetBit(Dcm_InstanceContext.Diag.Services.Svc2C.Sequencer,(srcItemIdx))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dcm_Svc2CSetMemSrcItem(srcItemIdx)                         (Dcm_UtiGenericBitSetClrBit(Dcm_InstanceContext.Diag.Services.Svc2C.Sequencer,(srcItemIdx))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# else
#  define Dcm_Svc2CIsDidSrcItem(srcItemIdx)                          /* not used */
#  define Dcm_Svc2CSetDidSrcItem(srcItemIdx)                         /* not used */
#  define Dcm_Svc2CSetMemSrcItem(srcItemIdx)                         /* not used */
# endif

# define Dcm_Svc2CGetSrcItemIndex(dynDidHandle, offset)              ((Dcm_CfgDidMgrDynDidSrcItemIdxMemType)(Dcm_DidMgrGetDynDidSrcItemStartRef(dynDidHandle)  + (offset))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define Dcm_Svc2CIsDynDidDefined(dynDidHandle)                      (Dcm_InstanceContext.Diag.Services.Svc2C.Items[(dynDidHandle)].Count != 0u)     /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc2CIsDidDefined(pDidInfo)                             ((!Dcm_DidMgrIsOpSupported(pDidInfo, DCM_DIDMGR_OP_DEFINE)) || Dcm_Svc2CIsDynDidDefined((pDidInfo)->OpRef)) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc2CGetMaxDynDidProtocolLen()                          ((Dcm_CfgNetBufferSizeMemType)(Dcm_NetGetBufferSizeOfTranspObj(Dcm_DiagGetTranspObj()) - 3u)) /* for response: 0x62 DID_H DID_L <DATA> */ /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# define Dcm_Svc2FIsDidActive(ioDidHdl)                              (Dcm_UtiGenericBitSetTestBit(Dcm_InstanceContext.Diag.Services.Svc2F.ActiveIoDids,(ioDidHdl))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc2FSetDidActive(ioDidHdl)                             (Dcm_UtiGenericBitSetSetBit(Dcm_InstanceContext.Diag.Services.Svc2F.ActiveIoDids,(ioDidHdl))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dcm_Svc2FClrDidActive(ioDidHdl)                             (Dcm_UtiGenericBitSetClrBit(Dcm_InstanceContext.Diag.Services.Svc2F.ActiveIoDids,(ioDidHdl))) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
/* ----------------------------------------------
 ~&&&   Typedefs Exported Level 2
---------------------------------------------- */
#if (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
typedef uint8 Dcm_MemMgrAccessType;
typedef uint8 Dcm_MemMgrMemoryOpType;

/* Shared data type for other service processors (e.g. 0x2C), using optimized data types */
struct DCM_MEMMGRMEMBLOCKTYPE_TAG
{
  Dcm_CfgMemMgrReqAddrType  Address;  /* The address to access */
  Dcm_CfgMemMgrReqSizeType  Length;   /* The number of bytes requested */
# if (DCM_MEMMGR_MID_SUPPORT_ENABLED == STD_ON)
  uint8                     Mid;      /* The memory identifier */
# endif
};
typedef struct DCM_MEMMGRMEMBLOCKTYPE_TAG Dcm_MemMgrMemBlockType;
typedef P2VAR(Dcm_MemMgrMemBlockType, TYPEDEF, DCM_VAR_NOINIT) Dcm_MemMgrMemBlockPtrType;

typedef P2FUNC(Dcm_MemMgrOpResultType, DCM_CALLOUT_CODE, Dcm_MemMgrOpFuncType)(Dcm_OpStatusType /*OpStatus*/
  , uint8  /*MemoryIdentifier*/
  , uint32 /*MemoryAddress*/
  , uint32 /*MemorySize*/
  , Dcm_MsgType /*MemoryData*/
# if (DCM_DCM_AR_VERSION >= DCM_DCM_AR_VERSION_422)
  , Dcm_NegativeResponseCodePtrType /* NRC */
# endif
  );
# if (DCM_MEMMGR_RAM_CONTEXT_ENABLED == STD_ON)
struct DCM_MEMMANAGERCONTEXTTYPE_TAG
{
#  if(DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
  Dcm_MemMgrAccessType  LockedByClient;
#  endif
};
typedef struct DCM_MEMMANAGERCONTEXTTYPE_TAG Dcm_MemManagerContextType;
# endif
#endif /* (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                         /* COV_DCM_UNSUPPORTED XF */
typedef uint8 Dcm_ObdIdMgrParserFlagsType;

typedef union
{                                                                                                                                                    /* PRQA S 0750 */ /* MD_Dcm_Optimize_0750 */
  uint32                    MaskValue;
  Dcm_ObdIdMgrHandleMemType Handle;
}Dcm_ObdIdMgrListItemResultType;

struct DCM_OBDIDMGRLISTITEMTYPE_TAG
{
  Dcm_ObdIdMgrListItemResultType Result;
  uint8                          Id;
};
typedef struct DCM_OBDIDMGRLISTITEMTYPE_TAG Dcm_ObdIdMgrListItemType;

typedef P2VAR(Dcm_ObdIdMgrListItemType, AUTOMATIC, DCM_VAR_NOINIT)   Dcm_ObdIdMgrListItemPtrType;

typedef P2FUNC(sint16_least, DCM_CODE, Dcm_ObdIdMgrGetAvailabilityMaskFuncType) (uint8, Dcm_Uint32VarDataPtrType);

struct DCM_OBDIDMGRDESCTYPE_TAG
{
  Dcm_ObdIdMgrGetAvailabilityMaskFuncType                       GetMaskFunc;
  Dcm_ObdIdMgrListItemType                                      ParseResult[6]; /* OUT: The list of supported IDs to be processed later */
  uint8                                                         ParseCount;     /* OUT: actual parseResult size */
  Dcm_ObdIdMgrParserFlagsType                                   ParseFlags;     /* IN: single/multi ID, contains data */
  boolean                                                       IsAvailabilityId; /* OUT: specifies whether the request has availability IDs or DATA ID(s) */
};
typedef struct DCM_OBDIDMGRDESCTYPE_TAG Dcm_ObdIdMgrDescType;

typedef P2VAR(Dcm_ObdIdMgrDescType, AUTOMATIC, DCM_VAR_NOINIT)           Dcm_ObdIdMgrDescPtrType;
#endif /* (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON) */
typedef P2CONST(Dcm_CfgNetBufferInfoType, TYPEDEF, DCM_CONST_PBCFG) Dcm_PbCfgNetBufferInfoPtrType;
typedef P2VAR(Dcm_CfgNetBufferSizeOptType, TYPEDEF, DCM_VAR_NOINIT) Dcm_CfgNetBufferSizePtrType;
typedef boolean Dcm_NetActiveDiagnosticType;

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
struct DCM_NETPERIODICTXCONTEXTTYPE_TAG
{
  DCM_PB_RAM_DATA_DECL(Dcm_NetPeriodicTxObjectType, TxObject, DCM_NET_MAX_NUM_PERIODIC_TX_OBJ_CONST)
# if(DCM_NET_MULTI_CONNECT_ENABLED == STD_ON)
  Dcm_NetConnRefMemType           ConnIdInUse;
# endif
# if (DCM_NET_PTXOBJ_LIMITER_ENABLED == STD_ON)
  Dcm_CfgNetPTxObjHandleMemType   NextTxObjectHdl;
  Dcm_CfgNetPTxObjHandleMemType   TxObjectCntr;
# endif
};
typedef struct DCM_NETPERIODICTXCONTEXTTYPE_TAG Dcm_NetPeriodicTxContextType;
#endif

typedef P2VAR(Dcm_NetTransportObjectType, TYPEDEF, DCM_VAR_NOINIT) Dcm_NetTransportObjectPtrType;

struct DCM_NETCONTEXTTYPE_TAG
{
  DCM_PB_RAM_DATA_DECL(Dcm_NetBufferContextType, BufferContext, DCM_NET_NUM_BUFFERS_CONST)
  DCM_PB_RAM_DATA_DECL(Dcm_NetTransportObjectType, TransportObject, DCM_NET_MAX_NUM_TRANSP_OBJECTS_CONST)
  DCM_PB_RAM_DATA_DECL(Dcm_NetComMContextType, ComMContext, DCM_NET_MAX_NUM_COMM_CHANNELS_CONST)
#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
  Dcm_NetPeriodicTxContextType  PeriodicTxContext;
#endif
#if(DCM_NET_TRANSP_OBJ_DYN_ALLOC_ENABLED == STD_ON)
  DCM_PB_RAM_DATA_DECL(Dcm_CfgNetTObjHandleMemType, ConnId2TObjIdMap, DCM_NET_MAX_NUM_CONNECTIONS_CONST)
#endif
#if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
  DCM_PB_RAM_DATA_DECL(Dcm_CommunicationModeType, ComCtrlChannels, DCM_NET_MAX_NUM_ALL_COMM_CHANNELS)
#endif
#if(DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)                                                                                                        /* COV_DCM_UNSUPPORTED XF */
  Dcm_CfgNetProtRefMemType      ActiveProtocol;
#endif
#if(DCM_NET_MULTI_TRANSP_OBJ_ENABLED == STD_ON)
  Dcm_NetConnRefMemType         NumActiveConnections;
#endif
#if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
  Dcm_NetConnRefMemType         SessionConnection;
#endif
  Dcm_NetActiveDiagnosticType   ActiveDiagnostic;
#if (DCM_NET_RX_BLOCKING_ENABLED == STD_ON)
  boolean                       RxAllowed;
#endif
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
  boolean                       KeepAlive;
#endif
};
typedef struct DCM_NETCONTEXTTYPE_TAG Dcm_NetContextType;
typedef uint8 Dcm_PagedBufferStateType;

typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_PagedBufferUpdateFuncType)(Dcm_MsgType, Dcm_CfgNetBufferSizePtrType);
typedef P2FUNC(void, DCM_CODE, Dcm_PagedBufferCancelFuncType)(void);

struct DCM_PAGEDBUFFERCONTEXTTYPE_TAG
{
  Dcm_PagedBufferUpdateFuncType  UpdateFunc;
  Dcm_PagedBufferCancelFuncType  CancelFunc;
  Dcm_PbCfgNetBufferInfoPtrType  BufferInfoPtr;
  Dcm_MsgLenType                 RemainingLen;
  Dcm_CfgNetBufferSizeMemType    WriteIndex;
  Dcm_CfgNetBufferSizeMemType    ReadIndex;
  Dcm_PagedBufferStateType       State;
#if (DCM_NET_MULTI_BUFFER_ENABLED == STD_ON)                                                                                                         /* COV_DCM_UNSUPPORTED XF */
  Dcm_CfgNetBufferRefMemType     BufferHdl;
#endif
  boolean                        UpdateFinished;
  boolean                        IsInUnderrun;
};
typedef struct DCM_PAGEDBUFFERCONTEXTTYPE_TAG Dcm_PagedBufferContextType;
typedef uint8 Dcm_RepeaterProgressType;
typedef uint8 Dcm_RepeaterUserType;
#if (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON)                                                                                                          /* COV_DCM_SUPPORT_ALWAYS TX */
# if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
struct DCM_MODECTRLDTCSETTINGCONTEXTTYPE_TAG
{
#  if (DCM_SVC_85_DTC_GRP_ENABLED == STD_ON)
  uint32                             DTCGroup;
#  endif
  Rte_ModeType_DcmControlDtcSetting  Mode;
};
typedef struct DCM_MODECTRLDTCSETTINGCONTEXTTYPE_TAG Dcm_ModeCtrlDtcSettingContextType;
# endif

struct DCM_MODECONTEXTTYPE_TAG
{
# if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
  Dcm_ModeCtrlDtcSettingContextType CtrlDtcSetting;
# else
  uint8 spare;
# endif
};
typedef struct DCM_MODECONTEXTTYPE_TAG Dcm_ModeContextType;
#endif /* (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON) */
typedef P2CONST(Dcm_CfgStateRefMemType, TYPEDEF, DCM_CONST)  Dcm_CfgStateRefMemPtrType;

struct DCM_STATECONTEXTTYPE_TAG
{
  Dcm_CfgStateDiagStateInfoType Preconditions;
#if (DCM_STATE_PEND_SESS_SUPPORT_ENABLED == STD_ON)
  Dcm_CfgStateGroupMemType      PendingSession;
#endif
};
typedef struct DCM_STATECONTEXTTYPE_TAG Dcm_StateContextType;
typedef uint8        Dcm_TskTaskPrioMemType;
typedef uint8_least  Dcm_TskTaskPrioOptType;

typedef uint8        Dcm_TskTaskAttributeType;
typedef uint8        Dcm_TskTaskFlagType;

typedef Dcm_TskTaskIdMemType  Dcm_TskMgrTraceStackBaseType;
typedef Dcm_UtiStackType(Dcm_TskMgrTraceStackBaseType, DCM_TSK_NUM_PRIOS) Dcm_TskMgrTraceStackType;

struct DCM_TSKTASKCONTEXTTYPE_TAG
{
  Dcm_TskTaskEvMemType    TaskEvents;
#if (DCM_TSK_TASK_FLAG_SUPPORT_ENABLED == STD_ON)                                                                                                    /* COV_DCM_UNSUPPORTED XF */
  Dcm_TskTaskFlagType     TaskFlags;
#endif
};
typedef struct DCM_TSKTASKCONTEXTTYPE_TAG Dcm_TskTaskContextType;

struct DCM_TSKSCHEDULERCONTEXTTYPE_TAG
{
  boolean SchdIsActive;
};

typedef struct DCM_TSKSCHEDULERCONTEXTTYPE_TAG Dcm_TskSchedulerContextType;

struct DCM_TSKCONTEXTTYPE_TAG
{
  volatile Dcm_TskTaskContextType      TaskContext[DCM_TSK_NUM_TASKS];
  volatile Dcm_TskSchedulerContextType TaskScheduler[DCM_TSK_NUM_PRIOS];
#if (DCM_TSK_TRACING_ENABLED == STD_ON)
  volatile Dcm_TskMgrTraceStackType    CurrentTaskPrioStack;
#endif
};
typedef struct DCM_TSKCONTEXTTYPE_TAG Dcm_TskContextType;
struct DCM_TMRCONTEXTTYPE_TAG
{
  volatile Dcm_TmrTimerCntrMemType   Timer[DCM_TMR_NUM_TIMERS];
};
typedef struct DCM_TMRCONTEXTTYPE_TAG Dcm_TmrContextType;
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
typedef P2CONST(Dcm_CfgDidMgrDidInfoType, TYPEDEF, DCM_CONST)            Dcm_DidMgrDidInfoPtrType;
typedef P2CONST(Dcm_CfgDidMgrOpInfoType, TYPEDEF, DCM_CONST)             Dcm_DidMgrOpInfoPtrType;
typedef P2CONST(Dcm_CfgDidMgrSignalOpClassInfoType, TYPEDEF, DCM_CONST)  Dcm_DidMgrSignalOpClassInfoPtrType;
# if (DCM_DIDMGR_MULTISIGNAL_ENABLED == STD_ON)
typedef P2CONST(Dcm_CfgDidMgrDidOpClassInfoType, TYPEDEF, DCM_CONST)     Dcm_DidMgrDidOpClassInfoPtrType;
typedef P2CONST(Dcm_CfgDidMgrSignalInfoType, TYPEDEF, DCM_CONST)         Dcm_DidMgrSignalInfoPtrType;
# endif

# if(DCM_DIDMGR_XX_ACCESS_LOCK_ENABLED == STD_ON)
struct DCM_DIDMGRDIDRSRCCONTEXTTYPE_TAG
{
#  if (DCM_DIDMGR_22_ACCESS_LOCK_ENABLED == STD_ON)
  uint16 ReadOnce;
#  endif
#  if (DCM_DIDMGR_2A_ACCESS_LOCK_ENABLED == STD_ON)
  uint16 ReadPeriodic;
#  endif
#  if (DCM_DIDMGR_2C_ACCESS_LOCK_ENABLED == STD_ON)
  uint16 ReadDynamic;
#  endif
#  if (DCM_DIDMGR_2E_ACCESS_LOCK_ENABLED == STD_ON)
  uint16 Write;
#  endif
#  if (DCM_DIDMGR_2F_ACCESS_LOCK_ENABLED == STD_ON)
  uint16 Io;
#  endif
};
typedef struct DCM_DIDMGRDIDRSRCCONTEXTTYPE_TAG Dcm_DidMgrDidRsrcContextType;
# endif

# if (DCM_DIDMGR_RAM_CONTEXT_ENABLED == STD_ON)
struct DCM_DIDMANAGERCONTEXTTYPE_TAG
{
#  if(DCM_DIDMGR_XX_ACCESS_LOCK_ENABLED == STD_ON)
  Dcm_DidMgrDidRsrcContextType  DidRsrcContext;
#  endif
#  if (DCM_DIDMGR_IODID_NBYTE_EXT_CEMR_ENABLED == STD_ON)
  Dcm_MsgItemType IoControlCemrSessionMask[DCM_DIDMGR_IODID_MAX_EXT_CEMR_SIZE_CONST];
#  endif
};
typedef struct DCM_DIDMANAGERCONTEXTTYPE_TAG Dcm_DidManagerContextType;
# endif
# if (DCM_DIDMGR_MULTISIGNAL_ENABLED == STD_ON)
struct DCM_DIDMGRDIDOPTYPEWORKCONTEXTTYPE_TAG
{
  Dcm_DidMgrSignalOpClassInfoPtrType    SignalOpList;
  Dcm_DidMgrSignalInfoPtrType           SignalInfoList;
  Dcm_CfgDidMgrSignalIterMemType        NumSignals;
};
typedef struct DCM_DIDMGRDIDOPTYPEWORKCONTEXTTYPE_TAG Dcm_DidMgrDidOpTypeBaseContextType;
# endif

# if (DCM_DIDMGR_OPTYPECONTEXT_READ_ENABLED == STD_ON)
struct DCM_DIDMGROPTYPEREADCONTEXTTYPE_TAG
{
#  if (DCM_DIDMGR_MSIG_OPTYPE_READ_ENABLED == STD_ON)
  Dcm_CfgDidMgrOptimizedDidLengthType  Offset;
#  endif
#  if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
  Dcm_CfgDidMgrOptimizedDidLengthType  Progress;
  Dcm_CfgNetBufferSizeMemType          PageProgress;
#   if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
  Dcm_OpStatusType                     OpStatus;
#   endif
#  endif
};
typedef struct DCM_DIDMGROPTYPEREADCONTEXTTYPE_TAG Dcm_DidMgrOpTypeReadContextType;
# endif

# if (DCM_DIDMGR_OPTYPECONTEXT_LOOKUP_ENABLED == STD_ON)
typedef uint8 Dcm_DidMgrDidLookUpStateType;
struct DCM_DIDMGRLOOKUPCONTEXTTYPE_TAG
{
  Dcm_DidMgrDidLookUpStateType State;
};
typedef struct DCM_DIDMGRLOOKUPCONTEXTTYPE_TAG Dcm_DidMgrLookUpContextType;
# endif

# if (DCM_DIDMGR_OPTYPECONTEXT_GETSCALING_ENABLED == STD_ON)
typedef P2CONST(Dcm_CfgNetBufferSizeMemType, TYPEDEF, DCM_CONST) Dcm_CfgDidMgrScalingInfoLengthPtrType; /* shall always fit the biggest buffer */
struct DCM_DIDMGROPTYPEREADSCALINGCONTEXTTYPE_TAG
{
  Dcm_CfgDidMgrScalingInfoLengthPtrType  LayoutList;
};
typedef struct DCM_DIDMGROPTYPEREADSCALINGCONTEXTTYPE_TAG Dcm_DidMgrOpTypeReadScalingContextType;
# endif

# if (DCM_DIDMGR_OPTYPECONTEXT_IO_ENABLED == STD_ON)
struct DCM_DIDMGROPTYPEIOCONTEXTTYPE_TAG
{
  Dcm_MsgType                        EnableMaskPtr;
#  if (DCM_DIDMGR_OPCLS_IO_ANY_WITH_EXT_CEMR_ENABLED == STD_ON)
  uint32                             ControlEnableMaskRecord;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_ANY_WITH_INT_CEMR_ENABLED == STD_ON)
  boolean                            OperExecuted;
  Dcm_CfgDidMgrSignalIterMemType     SignalIter;
  Dcm_MsgItemType                    BitScanner;
#  endif
};
typedef struct DCM_DIDMGROPTYPEIOCONTEXTTYPE_TAG Dcm_DidMgrOpTypeIoContextType;
# endif

# if (DCM_DIDMGR_OPTYPECONTEXT_SHARED_ENABLED == STD_ON)
typedef union
{                                                                                                                                                    /* PRQA S 0750 */ /* MD_Dcm_Optimize_0750 */
#  if (DCM_DIDMGR_OPTYPECONTEXT_LOOKUP_ENABLED == STD_ON)
  Dcm_DidMgrLookUpContextType               LookUp;
#  endif
#  if (DCM_DIDMGR_OPTYPECONTEXT_READ_ENABLED == STD_ON)
  Dcm_DidMgrOpTypeReadContextType           Read;
#  endif
#  if (DCM_DIDMGR_OPTYPECONTEXT_IO_ENABLED == STD_ON)
  Dcm_DidMgrOpTypeIoContextType             Io;
#  endif
#  if (DCM_DIDMGR_OPTYPECONTEXT_GETSCALING_ENABLED == STD_ON)
  Dcm_DidMgrOpTypeReadScalingContextType    ReadScaling;
#  endif
}Dcm_DidMgrDidSharedOpTypeContextType;
# endif

struct DCM_DIDMGRDIDOPTYPECONTEXTTYPE_TAG
{
# if (DCM_DIDMGR_OPTYPECONTEXT_ENABLED == STD_ON)
#  if (DCM_DIDMGR_MULTISIGNAL_ENABLED == STD_ON)
  Dcm_DidMgrDidOpTypeBaseContextType    Base;
#  endif
#  if (DCM_DIDMGR_OPTYPECONTEXT_SHARED_ENABLED == STD_ON)
  Dcm_DidMgrDidSharedOpTypeContextType  OpType;
#  endif
# else
  uint8 spare;
# endif
};
typedef struct DCM_DIDMGRDIDOPTYPECONTEXTTYPE_TAG Dcm_DidMgrDidOpTypeContextType;
typedef P2VAR(Dcm_DidMgrDidOpTypeContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_DidMgrDidOpTypeContextPtrType;

struct DCM_DIDMGRDIDDESCRIPTORTYPE_TAG
{
  Dcm_DidMgrDidInfoPtrType            DidInfoPtr;
  Dcm_DidMgrOpInfoPtrType             DidOpInfoPtr;
# if (DCM_DIDMGR_MULTISIGNAL_ENABLED == STD_ON)
  Dcm_DidMgrDidOpClassInfoPtrType     DidOpClassInfoPtr;
# endif
  Dcm_DidMgrSignalOpClassInfoPtrType  DidSignalOpClassInfoPtr;
};
typedef struct DCM_DIDMGRDIDDESCRIPTORTYPE_TAG Dcm_DidMgrDidDescriptorType;

struct DCM_DIDMGRDIDINFOCONTEXTTYPE_TAG
{
  Dcm_DidMgrDidDescriptorType      Descriptor;
  uint16                           Did;
  uint16                           DidLength;
};
typedef struct DCM_DIDMGRDIDINFOCONTEXTTYPE_TAG Dcm_DidMgrDidInfoContextType;
typedef P2VAR(Dcm_DidMgrDidInfoContextType, TYPEDEF, DCM_VAR_NOINIT)  Dcm_DidMgrDidInfoContextPtrType;
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
typedef P2CONST(Dcm_CfgRidMgrRidInfoType, TYPEDEF, DCM_CONST)  Dcm_RidMgrRidInfoPtrType;
typedef P2CONST(Dcm_CfgRidMgrOpInfoType, TYPEDEF, DCM_CONST)   Dcm_RidMgrOpInfoPtrType;
#endif /* (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON)                                                                                                        /* COV_DCM_UNSUPPORTED XF */
struct DCM_OBDDTCMGRREADDTCCONTEXTTYPE_TAG
{
  Dcm_PagedBufferUpdateFuncType  CopyFunc;
  Dem_DTCOriginType              Origin;
  uint8                          StatusMask;
};
typedef struct DCM_OBDDTCMGRREADDTCCONTEXTTYPE_TAG Dcm_ObdDtcMgrReadDtcContextType;

typedef P2VAR(Dcm_ObdDtcMgrReadDtcContextType, TYPEDEF, DCM_VAR_NOINIT) Dcm_ObdDtcMgrReadDtcContextPtrType;

struct DCM_OBDDTCMANAGERCONTEXTTYPE_TAG
{
  Dcm_ObdDtcMgrReadDtcContextPtrType  ReadDtcContextPtr;
};
typedef struct DCM_OBDDTCMANAGERCONTEXTTYPE_TAG Dcm_ObdDtcManagerContextType;
#endif /* (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON) */
typedef uint8 Dcm_DiagCheckLvlType;

struct DCM_DIAGPOSTPROCESSORCONTEXTTYPE_TAG
{
  uint16 SrcAddr;
  uint8  Sid;
  uint8  ReqType;
};
typedef struct DCM_DIAGPOSTPROCESSORCONTEXTTYPE_TAG Dcm_DiagPostProcessorContextType;

typedef P2FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE, Dcm_DiagServiceLengthGetterFuncType) (Dcm_DiagSubServiceRefOptType);
#if(DCM_VARMGR_SUPPORT_ENABLED == STD_ON)

struct DCM_VARMANAGERCONTEXTTYPE_TAG
{
# if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)                                                                                                        /* COV_DCM_SUPPORT_ALWAYS TX */
  Dcm_CfgVarMgrComVariantType       ActiveComVariant;
# endif
# if (DCM_DIAG_MULTI_SVC_TABLE_ENABLED == STD_ON)                                                                                                    /* COV_DCM_UNSUPPORTED XF */
  Dcm_CfgVarMgrBridgeVariantType    ActiveBridgeVariant;
# endif
# if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON)
  Dcm_CfgVarMgrRamVariantType       ActiveRamVariant;
  Dcm_CfgVarMgrRomVariantType       ActiveRomVariant;
# endif
# if (DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)
#  if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)                                                                                             /* COV_DCM_UNSUPPORTED XF */
  Dcm_CfgVarMgrBitSetBaseType       ActiveCfgVariants[Dcm_VarMgrBitSetCalcSize(DCM_VARMGR_NUM_CFG_VARIANTS_CONST)];
#  else
  Dcm_CfgVarMgrDiagVariantIdMemType ActiveCfgVariantId;
#  endif
# endif
};
typedef struct DCM_VARMANAGERCONTEXTTYPE_TAG Dcm_VarManagerContextType;
#endif
#if (DCM_SVC_01_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
struct DCM_SVC01REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_ObdIdMgrDescType    ParserDesc;
};
typedef struct DCM_SVC01REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc01RepeaterProxyContextType;
#endif /* (DCM_SVC_01_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_03_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
struct DCM_SVC03REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_ObdDtcMgrReadDtcContextType  ReadDtcContext;
};
typedef struct DCM_SVC03REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc03RepeaterProxyContextType;
#endif /* (DCM_SVC_03_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON)                                                 /* COV_DCM_UNSUPPORTED XF xf xf */
struct DCM_SVC06REPEATERPROXYCONTEXTTYPE_TAG
{
  uint8 Spare; /* Currently not used */
};
typedef struct DCM_SVC06REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc06RepeaterProxyContextType;
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON)                                                 /* COV_DCM_UNSUPPORTED XF xf xf */
struct DCM_SVC06REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_ObdIdMgrDescType    ParserDesc;
};
typedef struct DCM_SVC06REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc06RepeaterProxyContextType;
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON) */
#if (DCM_SVC_07_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
struct DCM_SVC07REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_ObdDtcMgrReadDtcContextType  ReadDtcContext;
};
typedef struct DCM_SVC07REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc07RepeaterProxyContextType;
#endif /* (DCM_SVC_07_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_08_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
struct DCM_SVC08REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_ObdIdMgrDescType    ParserDesc;
};
typedef struct DCM_SVC08REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc08RepeaterProxyContextType;
#endif /* (DCM_SVC_08_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_09_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
struct DCM_SVC09REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_ObdIdMgrDescType    ParserDesc;
};
typedef struct DCM_SVC09REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc09RepeaterProxyContextType;
#endif /* (DCM_SVC_09_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
struct DCM_SVC0AREPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_ObdDtcMgrReadDtcContextType  ReadDtcContext;
};
typedef struct DCM_SVC0AREPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc0ARepeaterProxyContextType;
#endif /* (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_10_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_SUPPORT_ALWAYS TX */
struct DCM_SVC10REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_StateIndexMemType            SesStateIdx;
# if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
  Dcm_ProgConditionsType           ProgConditions;
  Dcm_ModeMgrArEnvModeEcuResetType ResetMode;
# endif
};
typedef struct DCM_SVC10REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc10RepeaterProxyContextType;
#endif /* (DCM_SVC_10_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_11_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
struct DCM_SVC11REPEATERPROXYCONTEXTTYPE_TAG
{
  uint8 SubFuncId;
};
typedef struct DCM_SVC11REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc11RepeaterProxyContextType;
#endif /* (DCM_SVC_11_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_14_SUPPORT_ENABLED == STD_ON)
struct DCM_SVC14REPEATERPROXYCONTEXTTYPE_TAG
{
  uint32   Dtc;
};
typedef struct DCM_SVC14REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc14RepeaterProxyContextType;
#endif /* (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
struct DCM_19_REPEATERPROXYCONTEXTTYPE_TAG
{
# if (DCM_SVC_19_COPY_LINEAR_DATA_ENABLED == STD_ON)
  Dcm_PagedBufferUpdateFuncType                          CopyFunc;
# endif
  P2CONST(Dcm_RepeaterProxyFuncType, TYPEDEF, DCM_CONST) FuncChain;
# if (DCM_SVC_19_RECORD_ITER_ENABLED == STD_ON)
  Dcm_Uint8ConstDataPtrType                              RecordNumList;
# endif
  uint32                                                 Dtc;
  uint16                                                 NumDtc;
  Dem_DTCOriginType                                      Origin;
  uint8                                                  RecordNum;
  DCM_EXT_SVC19_PATCH_CONTEXT
};
typedef struct DCM_19_REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc19RepeaterProxyContextType;
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_22_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
struct DCM_SVC22REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_DidMgrDidInfoContextPtrType   DidInfoContextPtr;
  Dcm_DidMgrDidInfoContextType      DidInfoContextList[DCM_SVC_22_MAX_DID_LIST_LEN_CONST];
  Dcm_DidMgrDidOpTypeContextType    DidOpTypeContext;
  Dcm_MsgLenType                TotalLength;
# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
  Dcm_CfgNetBufferSizeMemType   ReadProgress;
# endif
  uint8                         NumDids;
  uint8                         DidIter;
# if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
  Dcm_OpStatusType              OpStatus;
# endif
};
typedef struct DCM_SVC22REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc22RepeaterProxyContextType;
#endif /* (DCM_SVC_22_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_23_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
struct DCM_SVC23REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_MemMgrMemBlockType  MemBlock;
};
typedef struct DCM_SVC23REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc23RepeaterProxyContextType;
#endif /* (DCM_SVC_23_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_24_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
struct DCM_SVC24REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_DidMgrDidInfoContextType      DidInfoContext;
  Dcm_DidMgrDidOpTypeContextType    DidOpTypeContext;
};
typedef struct DCM_SVC24REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc24RepeaterProxyContextType;
#endif /* (DCM_SVC_24_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
typedef uint16 Dcm_Svc27TimerType;
# endif

struct DCM_SVC27REPEATERPROXYCONTEXTTYPE_TAG
{
  uint8   SfIdx;
  boolean IsZeroSeed;
};
typedef struct DCM_SVC27REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc27RepeaterProxyContextType;

struct DCM_SVC27CONTEXTTYPE_TAG
{
# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
#  if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
                            uint32              GetAttCntrEventMask;
                            uint32              SetAttCntrEventMask;
#  endif
#  if (DCM_STATE_SEC_DELAY_TIME_ON_FAILED_GET_ATT_CNTR_ENABLED == STD_ON)
                            uint32              ReloadMask;
#  endif
  DCM_VOLATILE_ON_SPLITTASK Dcm_Svc27TimerType  DelayTime[DCM_SVC_27_NUM_DELAY_TIMERS];
                            uint8               AttemptCount[DCM_SVC_27_NUM_ATTEMPT_COUNTERS];
#  if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
                            Dcm_OpStatusType    GetAttOpStatus;
                            Dcm_OpStatusType    SetAttOpStatus;
#  endif
# endif
                            uint8               SeedLevel;/* 0 = invalid (no seed) -> 1..7F - active seed */
};
typedef struct DCM_SVC27CONTEXTTYPE_TAG Dcm_Svc27ContextType;
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
struct DCM_SVC28REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_CommunicationModeType  ComMode;
  Dcm_CfgNetNetIdRefMemType  NetworkRef;
  uint8                      SubServiceId;
# if (DCM_SVC_28_USER_ENABLED == STD_ON)
  boolean                    IsInternallyProcessed;
# endif
};
typedef struct DCM_SVC28REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc28RepeaterProxyContextType;
#endif /* (DCM_SVC_28_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
typedef uint8       Dcm_Svc2ASchedRateMemType;
typedef uint8       Dcm_Svc2ASchdItemHandleMemType;
typedef uint8_least Dcm_Svc2ASchdItemHandleOptType;

struct DCM_SVC2ASCHDENTRYTYPE_TAG
{
                            Dcm_DidMgrDidInfoContextType DidContext;
  DCM_VOLATILE_ON_SPLITTASK Dcm_TmrTimerCntrMemType      Timer;
                            Dcm_Svc2ASchedRateMemType    Rate;
};
typedef struct DCM_SVC2ASCHDENTRYTYPE_TAG Dcm_Svc2ASchdEntryType;

typedef P2VAR(Dcm_Svc2ASchdEntryType, TYPEDEF, DCM_VAR_NOINIT) Dcm_Svc2ASchdEntryPtrType;

struct DCM_SVC2ASCHEDULERTYPE_TAG
{
  Dcm_DidMgrDidInfoContextPtrType DidContextPtr;
  Dcm_Svc2ASchdEntryType          Table[DCM_SVC_2A_SCHEDULER_SIZE_CONST];
  Dcm_DidMgrDidOpTypeContextType  DidOpTypeContext;
  Dcm_Svc2ASchdItemHandleMemType  NumActiveEntries;
  Dcm_Svc2ASchdItemHandleMemType  NextEntryIdx;
  Dcm_CfgNetPTxObjHandleMemType   MsgTxHandle;
# if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
  Dcm_OpStatusType                OpStatus;
# endif
};
typedef struct DCM_SVC2ASCHEDULERTYPE_TAG Dcm_Svc2ASchedulerType;
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
struct DCM_SVC2AREPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_DidMgrDidInfoContextType    DidInfoContext;
  Dcm_DidMgrDidOpTypeContextType  DidOpTypeContext;
# if(DCM_NET_MULTI_CONNECT_ENABLED == STD_ON)
  Dcm_NetConnRefMemType     ConnId;
# endif
  uint8                     UdsRate;
  boolean                   HasAnySupportedDids;
};
typedef struct DCM_SVC2AREPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc2ARepeaterProxyContextType;

struct DCM_SVC2ACONTEXTTYPE_TAG
{
  Dcm_Svc2ASchedulerType Scheduler;
};
typedef struct DCM_SVC2ACONTEXTTYPE_TAG Dcm_Svc2AContextType;
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/* Define by DID properties */
typedef uint8  Dcm_Svc2CSrcDidOffsetType;
typedef uint8  Dcm_Svc2CSrcDidSizeType;
typedef Dcm_UtiBitSetBaseType  Dcm_Svc2CSrcClassType;

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
struct DCM_SVC2CSRCDIDITEMINFOTYPE_TAG
{
  Dcm_DidMgrDidInfoContextType DidContext;
  Dcm_Svc2CSrcDidOffsetType    Offset;
  Dcm_Svc2CSrcDidSizeType      Size;
};
typedef struct DCM_SVC2CSRCDIDITEMINFOTYPE_TAG Dcm_Svc2CSrcDidItemInfoType;
# endif

# if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
struct DCM_SVC2CSRCMEMITEMINFOTYPE_TAG
{
  Dcm_MemMgrMemBlockType MemBlock;
};
typedef struct DCM_SVC2CSRCMEMITEMINFOTYPE_TAG Dcm_Svc2CSrcMemItemInfoType;
# endif

typedef union
{                                                                                                                                                    /* PRQA S 0750 */ /* MD_Dcm_Optimize_0750 */
# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc2CSrcDidItemInfoType      DidDescriptor;
# endif
# if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc2CSrcMemItemInfoType      MemDescriptor;
# endif
}Dcm_Svc2CDynDidSrcItemType;

typedef P2VAR(Dcm_Svc2CDynDidSrcItemType, TYPEDEF, DCM_VAR_NOINIT) Dcm_Svc2CDynDidSrcItemPtrType;

struct DCM_SVC2CDYNDIDITEMTYPE_TAG
{
  Dcm_CfgNetBufferSizeMemType     Length;
  uint8                           Count;
};
typedef struct DCM_SVC2CDYNDIDITEMTYPE_TAG Dcm_Svc2CDynDidItemType;

struct DCM_SVC2CDYNDIDPROCESSCONTEXTTYPE_TAG
{
  Dcm_DidMgrDidOpTypeContextType       DidOpTypeContext;
  Dcm_CfgDidMgrDynDidSrcItemIdxMemType ItemInProgress;
  Dcm_CfgDidMgrDynDidSrcItemIdxMemType ItemToStop;
};
typedef struct DCM_SVC2CDYNDIDPROCESSCONTEXTTYPE_TAG Dcm_Svc2CDynDidProcessContextType;

struct DCM_SVC2CDYNDIDACCESSCONTEXT_TAG
{
  Dcm_MsgType                       ResData;
  Dcm_Svc2CDynDidProcessContextType ProcessContext[DCM_SVC_2C_NUM_PROCESS_CONTEXTS];
# if (DCM_DIDMGR_DYNDID_ASYNC_SUPPORT_ENABLED == STD_ON)
  Dcm_CfgDidMgrDynDidHandleMemType  DynDidHandleInUse;
# endif
  Dcm_MsgItemType                   Buffer[DCM_SVC_2C_READ_BUFFER_SIZE + DCM_SVC_2C_READ_BUFFER_OVERHEAD];
};
typedef struct DCM_SVC2CDYNDIDACCESSCONTEXT_TAG Dcm_Svc2CDynDidReadAccessContext;
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
struct DCM_SVC2CCONTEXTTYPE_TAG
{
  Dcm_Svc2CDynDidSrcItemType        SrcItems[DCM_NUM_DYNDID_ITEMS_CONST];
# if (DCM_SVC_2C_HYBRID_MODE_ENABLED == STD_ON)
  Dcm_Svc2CSrcClassType             Sequencer[Dcm_UtiGenericBitSetCalcSize(DCM_NUM_DYNDID_ITEMS_CONST)];
# endif
  Dcm_Svc2CDynDidItemType           Items[DCM_NUM_DYNDIDS_CONST];
  Dcm_Svc2CDynDidReadAccessContext  DynDidAccessContext;
};
typedef struct DCM_SVC2CCONTEXTTYPE_TAG Dcm_Svc2CContextType;
struct DCM_SVC2CREPEATERPROXYCONTEXTTYPE_TAG
{
# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc2CDynDidSrcItemPtrType          SrcItemPtr;
# endif
  Dcm_DidMgrDidInfoContextType           DynDidInfoContext;
  Dcm_DidMgrDidOpTypeContextType         DynDidOpTypeContext;
  Dcm_CfgDidMgrDynDidSrcItemIdxMemType   SrcItemIndex;
  Dcm_CfgDidMgrDynDidHandleMemType       DynDidHandle;
  Dcm_CfgNetBufferSizeMemType            MaxAllowedLength;
  Dcm_CfgNetBufferSizeMemType            DynDidLength;
  uint8                                  DynDidItemCount;
  uint8                                  ReqNumOfItems;
};
typedef struct DCM_SVC2CREPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc2CRepeaterProxyContextType;
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
struct DCM_SVC2EREPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_DidMgrDidInfoContextType       DidInfoContext;
  Dcm_DidMgrDidOpTypeContextType     DidOpTypeContext;
};
typedef struct DCM_SVC2EREPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc2ERepeaterProxyContextType;
#endif /* (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
struct DCM_SVC2FCONTEXTTYPE_TAG
{
# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
  Dcm_UtiBitSetBaseType ActiveIoDids[Dcm_UtiGenericBitSetCalcSize(DCM_NUM_IODIDS_CONST)];
  boolean               HasAnyActiveIoDid;
# else
  uint8 spare; /* not used */
# endif
};
typedef struct DCM_SVC2FCONTEXTTYPE_TAG Dcm_Svc2FContextType;
struct DCM_SVC2FREPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_DidMgrDidInfoContextType    DidInfoContext;
  Dcm_DidMgrDidOpTypeContextType  DidOpTypeContext;
  Dcm_DidMgrOpMemType             OpType;
};
typedef struct DCM_SVC2FREPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc2FRepeaterProxyContextType;
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_31_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
struct DCM_SVC31REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_RidMgrRidInfoPtrType RidInfoPtr;
  Dcm_RidMgrOpInfoPtrType  RidOpInfoPtr;
  Dcm_RidMgrOpType         Op;
# if (DCM_RIDMGR_SUPPORT_ROUTINEINFOBYTE_ENABLED == STD_ON)
  Dcm_MsgType              RIBResPtr;
# endif
};
typedef struct DCM_SVC31REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc31RepeaterProxyContextType;
#endif /* (DCM_SVC_31_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
struct DCM_SVC3DREPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_MemMgrMemBlockType  MemBlock;
};
typedef struct DCM_SVC3DREPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc3DRepeaterProxyContextType;
#endif /* (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
struct DCM_SVC85_REPEATERPROXYCONTEXTTYPE_TAG
{
  uint32                             DTCGroup;
  Rte_ModeType_DcmControlDtcSetting  ReqMode;
};
typedef struct DCM_SVC85_REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc85RepeaterProxyContextType;
#endif /* (DCM_SVC_85_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
struct DCM_SVC86REPEATERPROXYCONTEXTTYPE_TAG
{
  Dcm_ExtSvc86RepeaterContextType ExtSvc86RepeaterContext;
};
typedef struct DCM_SVC86REPEATERPROXYCONTEXTTYPE_TAG Dcm_Svc86RepeaterProxyContextType;
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */
/* ----------------------------------------------
 ~&&&   Typedefs Exported Level 1
---------------------------------------------- */
typedef Std_ReturnType Dcm_NetTransmissionResultType;
typedef uint8 Dcm_DiagApplNotificationType;
typedef uint8 Dcm_DiagProcessorFlagType;

struct DCM_STARTUPRESPONSECONTEXTTYPE_TAG
{
  Dcm_ProgConditionsType          ProgConditions; /* dedicated storage in case a parallel request needs the repeater proxy pool */
  Dcm_MsgItemType                 ResBuffer[6];
  boolean                         IsResponseRequired;
  Dcm_NetTransmissionResultType   TxStatus;
  sint8                           SessStateRef; /* no 128 or more sessions are possible -> sint8 is enough */
#if(DCM_NET_MULTI_CONNECT_ENABLED == STD_ON)
  Dcm_NetConnRefMemType           ConnId;
#endif
};
typedef struct DCM_STARTUPRESPONSECONTEXTTYPE_TAG Dcm_DiagStartUpResContextType;

#if(DCM_DIAG_SVC_CONTEXT_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
struct DCM_DIAGSERVICESCONTEXTTYPE_TAG
{
# if(DCM_SVC_27_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc27ContextType          Svc27;
# endif
# if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc2AContextType          Svc2A;
# endif
# if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc2CContextType          Svc2C;
# endif
# if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc2FContextType          Svc2F;
# endif
};
typedef struct DCM_DIAGSERVICESCONTEXTTYPE_TAG Dcm_DiagServicesContextType;
#endif

#if (DCM_DIAG_SYNCH_DATA_SET_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
struct DCM_DIAGSYNCHDATATYPE_TAG
{
# if (DCM_DIAG_TOBJ_QUEUE_ENABLED == STD_ON)
  Dcm_NetTransportObjectPtrType    TranspObj;
#  if (DCM_DIAG_GARB_COL_ENABLED == STD_ON)
  Dcm_TskTaskEvMemType             QueuedTObjects;
#  endif
# endif
# if (DCM_DIAG_PROCESSOR_FLAGS_ENABLED == STD_ON)
  Dcm_DiagProcessorFlagType        Flags;
# endif
};
typedef struct DCM_DIAGSYNCHDATATYPE_TAG Dcm_DiagSynchDataType;
#endif

struct DCM_DIAGCONTEXTTYPE_TAG
{
  Dcm_MsgContextType                MsgContext;
#if (DCM_DIAG_SYNCH_DATA_SET_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
volatile Dcm_DiagSynchDataType      QueuedSet;
#endif
#if(DCM_DIAG_ANY_NOTIFICATION_ENABLED == STD_ON)
  Dcm_DiagPostProcessorContextType  PostProcessorContext;
#endif
#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
  Dcm_DiagStartUpResContextType     StartUpFbl;
#endif
#if(DCM_NET_MULTI_TRANSP_OBJ_ENABLED == STD_ON)
  Dcm_NetTransportObjectPtrType     TranspObj;
#endif
  Dcm_DiagP2TimingsType             P2Timings;
  Dcm_NetTransmissionResultType     TxStatus;
  Dcm_DiagApplNotificationType      ApplNotification;
volatile Dcm_DiagProcessorStateType State;
  Dcm_NegativeResponseCodeType      ErrorRegister;
  uint8                             SidIndex;
#if (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
  uint8                             NumRcrRpTimeouts;
#endif
#if(DCM_DIAG_SVC_CONTEXT_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
  Dcm_DiagServicesContextType       Services;
#endif
#if(DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
  boolean                           IsInternRequest;
#endif
  boolean                            DoSuppressResponse;/* use dedicated flag instead of "NRC 0x11 and func_req trick" because of possible application Confirmation functions! */
};
typedef struct DCM_DIAGCONTEXTTYPE_TAG Dcm_DiagContextType;
/* ----------------------------------------------
 ~&&&   Typedefs
---------------------------------------------- */
typedef union
{                                                                                                                                                    /* PRQA S 0750 */ /* MD_Dcm_Optimize_0750 */
#if (DCM_SVC_01_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc01RepeaterProxyContextType Svc01;
#endif
#if (DCM_SVC_03_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc03RepeaterProxyContextType Svc03;
#endif
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc06RepeaterProxyContextType Svc06;
#endif
#if (DCM_SVC_07_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc07RepeaterProxyContextType Svc07;
#endif
#if (DCM_SVC_08_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc08RepeaterProxyContextType Svc08;
#endif
#if (DCM_SVC_09_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc09RepeaterProxyContextType Svc09;
#endif
#if (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc0ARepeaterProxyContextType Svc0A;
#endif
#if (DCM_SVC_10_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_SUPPORT_ALWAYS TX */
  Dcm_Svc10RepeaterProxyContextType Svc10;
#endif
#if (DCM_SVC_11_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc11RepeaterProxyContextType Svc11;
#endif
#if (DCM_SVC_14_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc14RepeaterProxyContextType Svc14;
#endif
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc19RepeaterProxyContextType Svc19;
#endif
#if (DCM_SVC_22_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc22RepeaterProxyContextType Svc22;
#endif
#if (DCM_SVC_23_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc23RepeaterProxyContextType Svc23;
#endif
#if (DCM_SVC_24_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc24RepeaterProxyContextType Svc24;
#endif
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc27RepeaterProxyContextType Svc27;
#endif
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc28RepeaterProxyContextType Svc28;
#endif
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc2ARepeaterProxyContextType Svc2A;
#endif
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc2CRepeaterProxyContextType Svc2C;
#endif
#if (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc2ERepeaterProxyContextType Svc2E;
#endif
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc2FRepeaterProxyContextType Svc2F;
#endif
#if (DCM_SVC_31_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc31RepeaterProxyContextType Svc31;
#endif
#if (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc3DRepeaterProxyContextType Svc3D;
#endif
#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
  Dcm_Svc85RepeaterProxyContextType Svc85;
#endif
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc86RepeaterProxyContextType Svc86;
#endif
#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
  Dcm_RecoveryInfoType              RecoveryInfo;
#endif
  uint8 reserved; /* just in case no other element is available */
}Dcm_RepeaterProxySvcContextType;

struct DCM_REPEATERPROXYCONTEXTPOOLTYPE_TAG
{
  Dcm_RepeaterProxySvcContextType Context;                                                                                                           /* PRQA S 0759 */ /* MD_Dcm_Optimize_0759 */
  Dcm_OpStatusType                OpStatus;
  Dcm_RepeaterProgressType        Progress;
#if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
  Dcm_RepeaterUserType            User;
#endif
};
typedef struct DCM_REPEATERPROXYCONTEXTPOOLTYPE_TAG Dcm_RepeaterProxyContextPoolType;

struct DCM_REPEATERCONTEXTTYPE_TAG
{
  Dcm_RepeaterProxyFuncType        Callee;
  Dcm_RepeaterProxyContextPoolType Contexts;
};
typedef struct DCM_REPEATERCONTEXTTYPE_TAG Dcm_RepeaterContextType;
typedef P2FUNC(void, DCM_CODE, Dcm_TskTaskFuncType) (Dcm_TskTaskEvOptType, Dcm_TskTaskEvPtrType);

struct DCM_TSKTASKINFOTYPE_TAG
{
  Dcm_TskTaskFuncType      TskFunc;
  Dcm_TskTaskAttributeType TskAtr;
#if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
  Dcm_TskTaskPrioMemType   TskPrio;
#endif
#if (DCM_TSK_TASK_KILL_ENABLED == STD_ON)                                                                                                            /* COV_DCM_UNSUPPORTED XF */
  Dcm_TskTaskEvMemType     NonKillEvents;
#endif
};
typedef struct DCM_TSKTASKINFOTYPE_TAG Dcm_TskTaskInfoType;
typedef P2FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE, Dcm_TmrTimeoutFuncType) (void);
struct DCM_TMRTIMERINFOTYPE_TAG
{
  Dcm_TmrTimeoutFuncType ToFunc;
};
typedef struct DCM_TMRTIMERINFOTYPE_TAG Dcm_TmrTimerInfoType;
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/* Read port operations */
# if (DCM_DIDMGR_OPCLS_READ_SYNC_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadSyncType)(Dcm_MsgType);
# endif
# if (DCM_DIDMGR_OPCLS_READ_ASYNC_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadAsyncType)(Dcm_OpStatusType
                                                                       ,Dcm_MsgType);
# endif
# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadPagedDidType)(Dcm_OpStatusType
                                                                          ,Dcm_MsgType
                                                                          ,Dcm_DidMgrDidLengthPtrType);
# endif
# if (DCM_DIDMGR_OPCLS_READ_RANGE_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadDidRangeType)(uint16
                                                                          ,Dcm_MsgType
                                                                          ,Dcm_OpStatusType
                                                                          ,Dcm_DidMgrDidLengthPtrType
                                                                          ,Dcm_NegativeResponseCodePtrType);
# endif
# if (DCM_DIDMGR_OPCLS_READ_VID_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadVidType)(Dcm_OpStatusType
                                                                     ,Dcm_MsgType
#  if (DCM_DCM_AR_VERSION >= DCM_DCM_AR_VERSION_422)
                                                                     ,Dcm_Uint8VarDataPtrType
#  endif
                                                                     );
# endif

/* Read Length port operations */
# if (DCM_DIDMGR_OPCLS_READ_LENGTH_RANGE_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadDidRangeLengthType)(uint16
                                                                                ,Dcm_OpStatusType
                                                                                ,Dcm_DidMgrDidLengthPtrType);
# endif
# if (DCM_DIDMGR_OPCLS_READ_LENGTH_SYNC_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadLengthSyncType)(Dcm_DidMgrDidLengthPtrType);
# endif
# if (DCM_DIDMGR_OPCLS_READ_LENGTH_ASYNC_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadLengthAsyncType)(Dcm_OpStatusType
                                                                             ,Dcm_DidMgrDidLengthPtrType);
# endif
/* Read CheckCondition port operations */
# if (DCM_DIDMGR_OPCLS_READ_CHECKCOND_SYNC_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadCheckCondSyncType)(Dcm_NegativeResponseCodePtrType);
# endif
# if (DCM_DIDMGR_OPCLS_READ_CHECKCOND_ASYNC_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncReadCheckCondAsyncType)(Dcm_OpStatusType
                                                                                ,Dcm_NegativeResponseCodePtrType);
# endif
/* ScalingInformation port operations */
# if (DCM_DIDMGR_OPCLS_GETSCALINGINFO_SYNC_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncGetScalingInfoSyncType)(Dcm_MsgType
                                                                                ,Dcm_NegativeResponseCodePtrType);
# endif
# if (DCM_DIDMGR_OPCLS_GETSCALINGINFO_ASYNC_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncGetScalingInfoAsyncType)(Dcm_OpStatusType
                                                                                 ,Dcm_MsgType
                                                                                 ,Dcm_NegativeResponseCodePtrType);
# endif
/* Write port operations */
# if (DCM_DIDMGR_OPCLS_WRITE_NLEN_SYNC_NRES_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncWriteNLenSyncNResErrorType)(Dcm_MsgType
                                                                                    ,Dcm_NegativeResponseCodePtrType);
# endif
# if (DCM_DIDMGR_OPCLS_WRITE_NLEN_ASYNC_NRES_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncWriteNLenAsyncNResErrorType)(Dcm_MsgType
                                                                                     ,Dcm_OpStatusType
                                                                                     ,Dcm_NegativeResponseCodePtrType);
# endif
# if (DCM_DIDMGR_OPCLS_WRITE_LEN_SYNC_RES_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncWriteLenSyncResErrorType)(Dcm_ReadOnlyMsgType
                                                                                  ,Dcm_DidMgrDidLengthPtrType
                                                                                  ,Dcm_MsgType
                                                                                  ,Dcm_NegativeResponseCodePtrType);
# endif
# if (DCM_DIDMGR_OPCLS_WRITE_LEN_ASYNC_NRES_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncWriteLenAsyncNResErrorType)(Dcm_MsgType
                                                                                    ,Dcm_DidMgrDidLengthType
                                                                                    ,Dcm_OpStatusType
                                                                                    ,Dcm_NegativeResponseCodePtrType);
# endif
# if (DCM_DIDMGR_OPCLS_WRITE_LEN_SYNC_NRES_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncWriteLenSyncNResErrorType)(Dcm_MsgType
                                                                                   ,Dcm_DidMgrDidLengthType
                                                                                   ,Dcm_NegativeResponseCodePtrType);
# endif
# if (DCM_DIDMGR_OPCLS_WRITE_NLEN_SYNC_NRES_NERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncWriteNLenSyncNResNErrorType)(Dcm_MsgType);                                                  /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif

# if (DCM_DIDMGR_RANGE_SUPPORT_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncWriteDidRangeType)(uint16
                                                                           ,Dcm_MsgType
                                                                           ,Dcm_OpStatusType
                                                                           ,Dcm_DidMgrDidLengthType
                                                                           ,Dcm_NegativeResponseCodePtrType);
#  if (DCM_DIDMGR_OPTYPE_RANGE_ISAVAIL_ENABLED == STD_ON)
/* IsAvailable range DID port operations */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncRangeIsAvailDidType)(uint16
                                                                             ,Dcm_OpStatusType
                                                                             ,P2VAR(Dcm_DidSupportedType, AUTOMATIC, DCM_VAR_NOINIT));
#  endif
# endif

/* IO Control port operations */

/* No CEMR */
# if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_NCEMR_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenSyncNCemrErrorType)(Dcm_NegativeResponseCodePtrType);
# endif
# if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_NCEMR_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenASyncNCemrErrorType)(Dcm_OpStatusType
                                                                                       ,Dcm_NegativeResponseCodePtrType);
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_NCEMR_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenSyncNCemrErrorType)(Dcm_MsgType
                                                                                     ,Dcm_NegativeResponseCodePtrType);
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_NCEMR_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenSyncNCemrErrorType)(Dcm_MsgType
                                                                                    ,Dcm_DidMgrDidLengthType
                                                                                    ,Dcm_NegativeResponseCodePtrType);
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_NCEMR_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenASyncNCemrErrorType)(Dcm_MsgType
                                                                                      ,Dcm_OpStatusType
                                                                                      ,Dcm_NegativeResponseCodePtrType);
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_NCEMR_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenASyncNCemrErrorType)(Dcm_MsgType
                                                                                     ,Dcm_DidMgrDidLengthType
                                                                                     ,Dcm_OpStatusType
                                                                                     ,Dcm_NegativeResponseCodePtrType);
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_RES_NCEMR_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenSyncResNCemrErrorType)(Dcm_ReadOnlyMsgType
                                                                                       ,Dcm_DidMgrDidLengthPtrType
                                                                                       ,Dcm_MsgType
                                                                                       ,Dcm_NegativeResponseCodePtrType);                            /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif

/* CEMR 8Bit */
# if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR8_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenSyncCemr8ErrorType)(uint8, Dcm_NegativeResponseCodePtrType);                      /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR8_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenASyncCemr8ErrorType)(Dcm_OpStatusType
                                                                                       ,uint8
                                                                                       ,Dcm_NegativeResponseCodePtrType);                            /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR8_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenSyncCemr8ErrorType)(Dcm_MsgType
                                                                                     ,uint8
                                                                                     ,Dcm_NegativeResponseCodePtrType);                              /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR8_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenSyncCemr8ErrorType)(Dcm_MsgType
                                                                                    ,Dcm_DidMgrDidLengthType
                                                                                    ,uint8
                                                                                    ,Dcm_NegativeResponseCodePtrType);                               /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR8_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenASyncCemr8ErrorType)(Dcm_MsgType
                                                                                      ,Dcm_OpStatusType
                                                                                      ,uint8
                                                                                      ,Dcm_NegativeResponseCodePtrType);                             /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR8_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenASyncCemr8ErrorType)(Dcm_MsgType
                                                                                     ,Dcm_DidMgrDidLengthType
                                                                                     ,Dcm_OpStatusType
                                                                                     ,uint8
                                                                                     ,Dcm_NegativeResponseCodePtrType);                              /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif

/* CEMR 16Bit */
# if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR16_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenSyncCemr16ErrorType)(uint16, Dcm_NegativeResponseCodePtrType);                    /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR16_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenASyncCemr16ErrorType)(Dcm_OpStatusType
                                                                                       ,uint16
                                                                                       ,Dcm_NegativeResponseCodePtrType);                            /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR16_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenSyncCemr16ErrorType)(Dcm_MsgType
                                                                                     ,uint16
                                                                                     ,Dcm_NegativeResponseCodePtrType);                              /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR16_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenSyncCemr16ErrorType)(Dcm_MsgType
                                                                                    ,Dcm_DidMgrDidLengthType
                                                                                    ,uint16
                                                                                    ,Dcm_NegativeResponseCodePtrType);                               /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR16_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenASyncCemr16ErrorType)(Dcm_MsgType
                                                                                      ,Dcm_OpStatusType
                                                                                      ,uint16
                                                                                      ,Dcm_NegativeResponseCodePtrType);                             /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR16_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenASyncCemr16ErrorType)(Dcm_MsgType
                                                                                     ,Dcm_DidMgrDidLengthType
                                                                                     ,Dcm_OpStatusType
                                                                                     ,uint16
                                                                                     ,Dcm_NegativeResponseCodePtrType);                              /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif

/* CEMR 32Bit */
# if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR32_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenSyncCemr32ErrorType)(uint32, Dcm_NegativeResponseCodePtrType);                    /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR32_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenASyncCemr32ErrorType)(Dcm_OpStatusType
                                                                                        ,uint32
                                                                                        ,Dcm_NegativeResponseCodePtrType);                           /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR32_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenSyncCemr32ErrorType)(Dcm_MsgType
                                                                                      ,uint32
                                                                                      ,Dcm_NegativeResponseCodePtrType);                             /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR32_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenSyncCemr32ErrorType)(Dcm_MsgType
                                                                                     ,Dcm_DidMgrDidLengthType
                                                                                     ,uint32
                                                                                     ,Dcm_NegativeResponseCodePtrType);                              /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR32_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenASyncCemr32ErrorType)(Dcm_MsgType
                                                                                       ,Dcm_OpStatusType
                                                                                       ,uint32
                                                                                       ,Dcm_NegativeResponseCodePtrType);                            /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR32_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenASyncCemr32ErrorType)(Dcm_MsgType
                                                                                      ,Dcm_DidMgrDidLengthType
                                                                                      ,Dcm_OpStatusType
                                                                                      ,uint32
                                                                                      ,Dcm_NegativeResponseCodePtrType);                             /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif

/* CEMR NBit */
# if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMRN_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenSyncCemrNErrorType)(Dcm_MsgType, Dcm_NegativeResponseCodePtrType);                /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMRN_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoNReqNLenASyncCemrNErrorType)(Dcm_OpStatusType
                                                                                       ,Dcm_MsgType
                                                                                       ,Dcm_NegativeResponseCodePtrType);                            /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMRN_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenSyncCemrNErrorType)(Dcm_MsgType
                                                                                     ,Dcm_MsgType
                                                                                     ,Dcm_NegativeResponseCodePtrType);                              /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMRN_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenSyncCemrNErrorType)(Dcm_MsgType
                                                                                    ,Dcm_DidMgrDidLengthType
                                                                                    ,Dcm_MsgType
                                                                                    ,Dcm_NegativeResponseCodePtrType);                               /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMRN_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqNLenASyncCemrNErrorType)(Dcm_MsgType
                                                                                      ,Dcm_OpStatusType
                                                                                      ,Dcm_MsgType
                                                                                      ,Dcm_NegativeResponseCodePtrType);                             /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
# if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMRN_ERROR_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_DidMgrOpFuncIoReqLenASyncCemrNErrorType)(Dcm_MsgType
                                                                                     ,Dcm_DidMgrDidLengthType
                                                                                     ,Dcm_OpStatusType
                                                                                     ,Dcm_MsgType
                                                                                     ,Dcm_NegativeResponseCodePtrType);                              /* PRQA S 0779 */ /* MD_Dcm_Understand_0779 */
# endif
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_RIDMGR_OPTYPE_NONE_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_APPL_CODE, Dcm_RidMgrOpFuncNoParamsType)(Dcm_OpStatusType
                                                                           ,Dcm_NegativeResponseCodePtrType);
# endif

# if (DCM_RIDMGR_OPTYPE_REQ_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_APPL_CODE, Dcm_RidMgrOpFuncReqType)(Dcm_ReadOnlyMsgType
                                                                      ,Dcm_OpStatusType
                                                                      ,Dcm_NegativeResponseCodePtrType);
# endif

# if (DCM_RIDMGR_OPTYPE_REQ_RES_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_APPL_CODE, Dcm_RidMgrOpFuncReqResType)(Dcm_ReadOnlyMsgType
                                                                         ,Dcm_OpStatusType
                                                                         ,Dcm_MsgType
                                                                         ,Dcm_NegativeResponseCodePtrType);
# endif

# if (DCM_RIDMGR_OPTYPE_RES_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_APPL_CODE, Dcm_RidMgrOpFuncResType)(Dcm_OpStatusType
                                                                      ,Dcm_MsgType
                                                                      ,Dcm_NegativeResponseCodePtrType);
# endif

# if (DCM_RIDMGR_OPTYPE_REQ_DYNLEN_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_APPL_CODE, Dcm_RidMgrOpFuncReqDynLenType)(Dcm_ReadOnlyMsgType
                                                                            ,Dcm_OpStatusType
                                                                            ,Dcm_RidMgrRidLengthType
                                                                            ,Dcm_NegativeResponseCodePtrType);
# endif

# if (DCM_RIDMGR_OPTYPE_REQ_DYNLEN_RES_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_APPL_CODE, Dcm_RidMgrOpFuncReqDynLenResType)(Dcm_ReadOnlyMsgType
                                                                               ,Dcm_OpStatusType
                                                                               ,Dcm_MsgType
                                                                               ,Dcm_RidMgrRidLengthType
                                                                               ,Dcm_NegativeResponseCodePtrType);
# endif

# if (DCM_RIDMGR_OPTYPE_REQ_DYNLEN_RES_DYNLEN_ENABLED == STD_ON) || \
     (DCM_RIDMGR_OPTYPE_REQ_RES_DYNLEN_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_APPL_CODE, Dcm_RidMgrOpFuncReqAnyLenResDynLenType)(Dcm_ReadOnlyMsgType
                                                                                     ,Dcm_OpStatusType
                                                                                     ,Dcm_MsgType
                                                                                     ,Dcm_RidMgrRidLengthPtrType
                                                                                     ,Dcm_NegativeResponseCodePtrType);
# endif

# if (DCM_RIDMGR_OPTYPE_RES_DYNLEN_ENABLED == STD_ON)
typedef P2FUNC(Std_ReturnType, DCM_APPL_CODE, Dcm_RidMgrOpFuncResDynLenType)(Dcm_OpStatusType
                                                                            ,Dcm_MsgType
                                                                            ,Dcm_RidMgrRidLengthPtrType
                                                                            ,Dcm_NegativeResponseCodePtrType);
# endif
#endif /* (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON) */
struct DCM_INSTANCECONTEXTTYPE_TAG
{
  /* *** Paged buffer manager *** */
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
  Dcm_PagedBufferContextType    PagedBuffer;
#endif
  /* *** Diagnostic kernel *** */
  Dcm_DiagContextType           Diag;
  /* *** Processor repeater *** */
  Dcm_RepeaterContextType       Repeater;
#if (DCM_DIDMGR_RAM_CONTEXT_ENABLED == STD_ON)                                                                                                       /* COV_DCM_UNSUPPORTED XF */
  /* *** DID manager *** */
  Dcm_DidManagerContextType     DidMgr;
#endif
#if (DCM_MEMMGR_RAM_CONTEXT_ENABLED == STD_ON)                                                                                                       /* COV_DCM_UNSUPPORTED XF */
  /* *** MemoryAccess manager *** */
  Dcm_MemManagerContextType     MemMgr;
#endif
#if (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON)                                                                                                        /* COV_DCM_UNSUPPORTED XF */
  Dcm_ObdDtcManagerContextType  ObdDtcMgr;
#endif
};
typedef struct DCM_INSTANCECONTEXTTYPE_TAG Dcm_InstanceContextType;

struct DCM_SINGLETONCONTEXTTYPE_TAG
{
  /* *** Network manager *** */
  Dcm_NetContextType           Network;
  /* *** Task manager *** */
  Dcm_TskContextType           TaskMgr;
  /* *** Timer manager *** */
  Dcm_TmrContextType           TimerMgr;
  /* *** State manager *** */
  Dcm_StateContextType         StateMgr;
#if (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON)                                                                                                          /* COV_DCM_SUPPORT_ALWAYS TX */
  /* *** Mode manager *** */
  Dcm_ModeContextType          ModeMgr;
#endif
#if (DCM_VARMGR_SUPPORT_ENABLED == STD_ON)
  /* *** VARIANT manager *** */
  Dcm_VarManagerContextType    VarMgr;
#endif
};
typedef struct DCM_SINGLETONCONTEXTTYPE_TAG Dcm_SingletonContextType;
typedef Dcm_CfgStateRefMemPtrType  Dcm_VarRefMemPtrType; /* derived from the execution precondition references */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
typedef uint8 Dcm_Svc19DemSetFilterClassType;
typedef uint8 Dcm_Svc19DemSetFilterMaskUsageType;

struct DCM_SVC19DEMDTCFILTERINFOTYPE_TAG
{
  Dem_DTCKindType             Kind;
  Dem_DTCOriginType           Origin;
  Dem_FilterWithSeverityType  ConsiderSeverity;
};
typedef struct DCM_SVC19DEMDTCFILTERINFOTYPE_TAG Dcm_Svc19DemDtcFilterInfoType;
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_Svc27OpFuncSeedWAdr)(Dcm_MsgType
                                                                 ,Dcm_OpStatusType
                                                                 ,Dcm_MsgType
                                                                 ,Dcm_NegativeResponseCodePtrType);
typedef P2FUNC(Std_ReturnType, DCM_CODE, Dcm_Svc27OpFuncSeedWoAdr)(Dcm_OpStatusType
                                                                  ,Dcm_MsgType
                                                                  ,Dcm_NegativeResponseCodePtrType);
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
/* ----------------------------------------------
 ~&&&   Module internal inlined function declarations
---------------------------------------------- */
#define DCM_START_SEC_CODE
/*lint -save -esym(961, 19.1)*/
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore*/
#if (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_MemMgrInit()
 *********************************************************************************************************************/
/*! \brief          Initialization function.
 *  \details        Initialization of the direct memory access sub-module.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_MemMgrInit(void);
#endif /* (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
# if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgr_F6XX_ReadDidData_SupportedId()
 *********************************************************************************************************************/
/*! \brief          Read operation for a Supported OBD MID
 *  \details        -
 *  \param[in]      ObdMID         Supported OBD Monitor Id
 *  \param[out]     Data           Data buffer
 *  \param[out]     DataLength     Data length
 *  \param[out]     ErrorCode      Negative response code in case return value is DCM_E_NOT_OK
 *  \return         DCM_E_OK       Read operation was successful
 *  \return         DCM_E_NOT_OK   Read operation was not successful
 *  \context        TASK
 *  \reentrant      TRUE
 *  \synchronous    TRUE
 *  \pre            Obd MID is a supported MID (0x00, 0x20, 0x40,..)
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgr_F6XX_ReadDidData_SupportedId(uint8 ObdMID
                                                                                         ,Dcm_MsgType Data
                                                                                         ,Dcm_DidMgrDidLengthPtrType DataLength
                                                                                         ,Dcm_NegativeResponseCodePtrType ErrorCode);
# endif

# if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgr_F6XX_ReadDidData_DataId()
 *********************************************************************************************************************/
/*! \brief          Read operation for a OBD MID
 *  \details        Reads test result for given OBD MID
 *  \param[in]      ObdMID         OBD Monitor Id
 *  \param[out]     Data           Data buffer
 *  \param[out]     DataLength     Data length
 *  \param[out]     ErrorCode      Negative response code in case return value is DCM_E_NOT_OK
 *  \return         DCM_E_OK       Read operation was successful
 *  \return         DCM_E_NOT_OK   Read operation was not successful
 *  \context        TASK
 *  \reentrant      TRUE
 *  \synchronous    TRUE
 *  \pre            Obd MID is not a supported MID (0x00, 0x20, 0x40,..)
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgr_F6XX_ReadDidData_DataId(uint8 ObdMID
                                                                                    ,Dcm_MsgType Data
                                                                                    ,Dcm_DidMgrDidLengthPtrType DataLength
                                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode);
# endif
#endif /* (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)                                                                                                  /* COV_DCM_UNSUPPORTED XF */
# if (DCM_UTI_NVM_READ_ENABLED  == STD_ON) || \
     (DCM_UTI_NVM_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_UtiArEnvNvMGetErrorStatus()
 *********************************************************************************************************************/
/*! \brief          Adapter function for AR 3.XX NvM_GetErrorStatus().
 *  \details        -
 *  \param[in]      blockId    Id of the NvRam block
 *  \param[out]     nvmStatus  Delegates the result from the NvM_GetErrorStatus()
 *  \return         E_OK       This value is always returned.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_UtiArEnvNvMGetErrorStatus(uint16 blockId
                                                        ,P2VAR(NvM_RequestResultType, AUTOMATIC, AUTOMATIC) nvmStatus);
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_UTI_LOOKUP_RANGE_U16_ENABLED == STD_ON)                                                                                                     /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_UtiLookUpRangeUint16()
 *********************************************************************************************************************/
/*! \brief          Searches a word in a table of ranges.
 *  \details        -
 *  \param[in]      lookUpTable    Pointer to the table to be scanned
 *  \param[in]      value          Value to be found
 *  \return         -1             Look up failed (no match)
 *  \return         >=0            Success, index of the matched position
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            Table pointer must not be NULL_PTR. Total number of elements for look up shall be < 32767.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(sint16_least, DCM_CODE) Dcm_UtiLookUpRangeUint16(P2CONST(Dcm_UtiU16RangeType, AUTOMATIC, DCM_CONST) lookUpTable
                                                                      ,uint16 value);
#endif
/**********************************************************************************************************************
 *  Dcm_NetCommon()
 *********************************************************************************************************************/
 /*! \brief         Initialization of the common network related states.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetCommon(void);

/**********************************************************************************************************************
 *  Dcm_NetComMInit()
 *********************************************************************************************************************/
/*! \brief          Initialization of the ComM related states.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetComMInit(void);

/**********************************************************************************************************************
 *  Dcm_NetBufferInit()
 *********************************************************************************************************************/
/*! \brief          Initialization of the buffer related states.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetBufferInit(void);

/**********************************************************************************************************************
 *  Dcm_NetConnectionInit()
 *********************************************************************************************************************/
/*! \brief          Initialization of the connection related states.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetConnectionInit(void);

/**********************************************************************************************************************
 *  Dcm_NetTranspObjInit()
 *********************************************************************************************************************/
/*! \brief          Initialization of the transport object related states.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTranspObjInit(void);

/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgInit()
 *********************************************************************************************************************/
/*! \brief          Initialization of the periodic message related states.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgInit(void);

/**********************************************************************************************************************
 *  Dcm_NetInit()
 *********************************************************************************************************************/
/*! \brief          Initialization of the network sub-module.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetInit(void);

/**********************************************************************************************************************
 *  Dcm_NetRegisterActiveConnection()
 *********************************************************************************************************************/
/*! \brief          Registers an active connection.
 *  \details        Function will be called from Dcm_NetStartOfReception.
 *  \param[in]      pTranspObj    The transport object
 *  \context        ISR1|ISR2
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetRegisterActiveConnection(Dcm_NetTransportObjectPtrType pTranspObj);

#if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)                                                                                                 /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetOnRequestDetection()
 *********************************************************************************************************************/
/*! \brief          Cancels any pending job if detected another ECU to be requested from the same client.
 *  \details        Function will be called from Dcm_NetStartOfReception.
 *  \param[in]      connId        The connection ID of the foreign ECU request
 *  \context        ISR1|ISR2
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetOnRequestDetection(DCM_NETCONNID_PARAMDEF_ONLY);
#endif

#if (DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)                                                                                                       /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetRxPrioritisation()
 *********************************************************************************************************************/
/*! \brief          Prioritization of received requests.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the task Dcm_NetTaskRx
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetRxPrioritisation(Dcm_TskTaskEvOptType ev
                                                             ,Dcm_TskTaskEvPtrType pPostEv);
#endif

#if(DCM_NET_PROTOCOL_SWITCH_NOTIFICATION_ENABLED == STD_ON)                                                                                          /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetExecStartProtocolOp()
 *********************************************************************************************************************/
/*! \brief          Executes a protocol start up.
 *  \details        -
 *  \param[in]      newProtocol    The new protocol ID to be evaluated for starting
 *  \return         TRUE           Proceed with protocol starting
 *  \return         FALSE          Skip any further service processing after return
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetExecStartProtocolOp(Dcm_ProtocolType newProtocol);
#endif

/**********************************************************************************************************************
 *  Dcm_NetComposeAddNegResponse()
 *********************************************************************************************************************/
/*! \brief          Composes a negative response.
 *  \details        -
 *  \param[in]      pTranspObj    The transport object
 *  \param[in]      resType       The response type
 *  \param[in]      nrc           The negative response code
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetComposeAddNegResponse(Dcm_NetTransportObjectPtrType pTranspObj
                                                                  ,Dcm_NetResponseType resType
                                                                  ,Dcm_NegativeResponseCodeType nrc);

#if (DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)                                                                                                       /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetProcessStartProtocol()
 *********************************************************************************************************************/
/*! \brief          Starts a new protocol.
 *  \details        Delegates a new request with a new protocol and terminates the old one.
 *  \param[in]      pTranspObj    The transport object
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetProcessStartProtocol(Dcm_NetTransportObjectPtrType pTranspObj);
#endif

#if (DCM_NET_CONN_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetLockConnection()
 *********************************************************************************************************************/
/*! \brief          Allocates a transport object for a concrete client connection.
 *  \details        -
 *  \param[in]      pTranspObj    The transport object
 *  \return         Allocated transport object
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NetTransportObjectPtrType, DCM_CODE) Dcm_NetLockConnection(DCM_NETCONNID_PARAMDEF_ONLY);
#endif

/**********************************************************************************************************************
 *  Dcm_NetTpRxIndicationNotOk()
 *********************************************************************************************************************/
/*! \brief          Indication of finished reception with no success.
 *  \details        This function is called by Dcm_NetTpRxIndication.
 *  \param[in]      pTranspObj    The transport object
 *  \context        ISR1|ISR2
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpRxIndicationNotOk(Dcm_NetTransportObjectPtrType pTranspObj);

/**********************************************************************************************************************
 *  Dcm_NetTpRxIndicationOk()
 *********************************************************************************************************************/
/*! \brief          Indication of finished reception with success.
 *  \details        This function is called by Dcm_NetTpRxIndication.
 *  \param[in]      pTranspObj    The transport object
 *  \context        ISR1|ISR2
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpRxIndicationOk(Dcm_NetTransportObjectPtrType pTranspObj);
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)                                                                                                  /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetTpTxConfirmation()
 *********************************************************************************************************************/
/*! \brief          Confirmation for a specific TxPduId TP channel.
 *  \details        This function is called by Dcm_TpTxConfirmation.
 *  \param[in]      txPduId    The confirmation TxPDUID of the response
 *  \param[in]      result     Request reception status
 *  \context        ISR1|ISR2
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpTxConfirmation(PduIdType txPduId
                                                             ,Dcm_NetArEnvNotifResultType result);
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)                                                                                                  /* COV_DCM_SUPPORT_PARTIALLY TX tx xf */
/**********************************************************************************************************************
 *  Dcm_NetCopyRxData()
 *********************************************************************************************************************/
/*! \brief          Copies request data from the lower layer.
 *  \details        This function is called by Dcm_CopyRxData.
 *  \param[in]      pTranspObj         The transport object
 *  \param[in]      info               Message context (data and length of the portion)
 *  \param[out]     bufferSizePtr      Available buffer size
 *  \return         BUFREQ_OK          A free buffer is available - start copy data
 *  \return         BUFREQ_E_NOT_OK    No free buffer is available - ignore request
 *  \context        ISR1|ISR2
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetCopyRxData(Dcm_NetTransportObjectPtrType pTranspObj
                                                        ,P2VAR(PduInfoType,   AUTOMATIC, DCM_APPL_DATA) info
                                                        ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) bufferSizePtr);

/**********************************************************************************************************************
 *  Dcm_NetTpRxIndication()
 *********************************************************************************************************************/
/*! \brief          Indication of finished reception.
 *  \details        This function is called by Dcm_TpRxIndication.
 *  \param[in]      rxPduId    The RxPDUID of the request.
 *  \param[in]      result     Transmission result
 *  \context        ISR1|ISR2
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpRxIndication(PduIdType rxPduId
                                                           ,Dcm_NetArEnvNotifResultType result);

/**********************************************************************************************************************
 *  Dcm_NetCopyTxData()
 *********************************************************************************************************************/
/*! \brief          Copies transmit data to the lower layer.
 *  \details        This function is called by Dcm_CopyTxData.
 *  \param[in]      pTranspObj          The transport object
 *  \param[in]      info                Pointer to a PduInfoType, which indicates the number of bytes to be copied
 *                                      (SduLength) and the location where the data have to be copied to (SduDataPtr).
 *                                      An SduLength of 0 is possible in order to poll the available transmit data
 *                                      count. In this case no data are to be copied and SduDataPtr might be invalid.
 *  \param[in]      availableDataPtr    Remaining TX data after completion of this call.
 *  \return         BUFREQ_OK           A free buffer is available - start copy data
 *  \return         BUFREQ_E_NOT_OK     No free buffer is available - ignore request
 *  \context        ISR1|ISR2
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetCopyTxData(Dcm_NetTransportObjectPtrType pTranspObj
                                                     ,P2VAR(PduInfoType,   AUTOMATIC, DCM_APPL_DATA) info
                                                     ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) availableDataPtr);
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_PagedBufferInit()
 *********************************************************************************************************************/
/*! \brief          Initialize paged buffer any time.
 *  \details        Initialization of the paged buffer.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_PagedBufferInit(void);

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferUpdatePage()
 *********************************************************************************************************************/
/*! \brief          Dispatches the UpdatePage call.
 *  \details        Dispatches the UpdatePage call regarding the paged buffer.
 *  \return         DCM_E_OK              All data has been copied - evaluate the out parameters
 *  \return         DCM_E_PENDING         No result yet, retry later
 *  \return         DCM_E_NOT_OK          Something went wrong, stop updating(only in DET situation)
 *  \return         DCM_E_BUFFERTOOLOW    Some data copied but no place, retry later on TP buffer under-run
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_PagedBufferUpdatePage(void);
#endif
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)                                                                                                  /* COV_DCM_UNSUPPORTED XF */
# if(DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferCopyData()
 *********************************************************************************************************************/
/*! \brief          Copy from paged buffer to the TP layer.
 *  \details        -
 *  \param[in,out]  PduInfo   PduR message context
 *  \param[in]      Length    Remained data in the buffer
 *  \return         BUFREQ_OK           A free buffer is available - start copy data
 *  \return         BUFREQ_E_NOT_OK     No free buffer is available - ignore request
 *  \return         BUFREQ_E_BUSY       No free buffer at this time - try later again
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_PagedBufferCopyData(
                                                                   P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) PduInfo
                                                                  ,PduLengthType Length);
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)                                                                                                  /* COV_DCM_SUPPORT_PARTIALLY TX tx xf */
# if(DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferCopyData()
 *********************************************************************************************************************/
/*! \brief          Copy from paged buffer to the TP layer.
 *  \details        -
 *  \param[in]      info                Message context (data and length of the portion)
 *  \param[in]      availableDataPtr    Remaining TX data after completion of this call
 *  \return         BUFREQ_OK           A free buffer is available - start copy data
 *  \return         BUFREQ_E_NOT_OK     No free buffer is available - ignore request
 *  \return         BUFREQ_E_BUSY       No free buffer at this time - try later again
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_PagedBufferCopyData(
                                                      P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info
                                                     ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) availableDataPtr);
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
#if (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON)                                                                                                          /* COV_DCM_SUPPORT_ALWAYS TX */
# if (DCM_MODEMGR_CHECK_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeCheck()
 *********************************************************************************************************************/
/*! \brief          Performs a mode rule check.
 *  \details        -
 *  \param[in]      modeRuleRef    A reference to a mode rule
 *  \return         The NRC
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_ModeCheck(Dcm_CfgModeMgrRuleRefOptType modeRuleRef);
# endif

/**********************************************************************************************************************
 *  Dcm_ModeInit()
 *********************************************************************************************************************/
/*! \brief          Initializes DCM mode manager sub-module.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts must be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_ModeInit(void);
#endif /* (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)                                                                                                  /* COV_DCM_UNSUPPORTED XF */
# if (DCM_MODE_ECU_RESET_ENABLED == STD_ON) || \
     (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchAckEcuReset()
 *********************************************************************************************************************/
/*! \brief          Mode switch acknowledgment for an ECU Reset/RapidPowershutDown command.
 *  \details        -
 *  \return         DCM_E_OK - This value is always returned.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchAckEcuReset(void);
# endif

# if (DCM_MODE_ECU_RESET_ENABLED == STD_ON) || \
     (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchEcuReset()
 *********************************************************************************************************************/
/*! \brief          Mode switching for an ECU Reset/RapidPowershutDown command.
 *  \details        -
 *  \param[in]      mode    The mode
 *  \return         The operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchEcuReset(Dcm_ResetModeType mode);
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)                                                                                                  /* COV_DCM_SUPPORT_PARTIALLY TX tx xf */
# if (DCM_MODE_ECU_RESET_ENABLED == STD_ON)   || \
     (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)                                                                                                         /* COV_DCM_UNSUPPORTED TF tf xf */
/**********************************************************************************************************************
 *  Dcm_ModeSwitchAckResultInterpreter()
 *********************************************************************************************************************/
/*! \brief          Converts a ModeSwitchAck API return value to a DCM standard result.
 *  \details        -
 *  \param[in]      modeSwitchAckResult    The ModeSwitchAck API result
 *  \return         The DCM standard result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchAckResultInterpreter(Std_ReturnType modeSwitchAckResult);
# endif

# if (DCM_MODE_ECU_RESET_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchAckEcuReset()
 *********************************************************************************************************************/
/*! \brief          Mode switch acknowledgment for an ECU reset command.
 *  \details        -
 *  \return         The operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchAckEcuReset(void);
# endif

# if (DCM_MODE_ECU_RESET_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchEcuReset()
 *********************************************************************************************************************/
/*! \brief          Mode switching for an ECU reset command.
 *  \details        -
 *  \param[in]      mode    The mode
 *  \return         The operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchEcuReset(Rte_ModeType_DcmEcuReset mode);
# endif

# if (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)                                                                                                         /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_ModeSwitchAckRapidShutDown()
 *********************************************************************************************************************/
/*! \brief          Mode switch acknowledgment for a rapid power shutdown command.
 *  \details        -
 *  \return         The operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchAckRapidShutDown(void);
# endif

# if (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)                                                                                                         /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_ModeSwitchRapidShutDown()
 *********************************************************************************************************************/
/*! \brief          Mode switching for an ECU reset rapid shut down command.
 *  \details        -
 *  \param[in]      mode    The mode
 *  \return         The operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchRapidShutDown(Rte_ModeType_DcmModeRapidPowerShutDown mode);
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_StateInit()
 *********************************************************************************************************************/
/*! \brief          State initialization.
 *  \details        Initialization of the state manager sub-module.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_StateInit(void);

#if (DCM_STATE_ANY_NOTIFICATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateExecOnStateChangeFunc()
 *********************************************************************************************************************/
/*! \brief          Executes all registered on state change functions if precondition no more fulfilled.
 *  \details        -
 *  \param[in]      notifList        The notification list
 *  \param[in]      formerStateId    The former state
 *  \param[in]      newStateId       The new state
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_StateExecOnStateChangeFunc(Dcm_CfgStateNotificationInfoPtrType notifList
                                                                    ,uint8 formerStateId
                                                                    ,uint8 newStateId);
#endif

#if (DCM_STATE_SECURITY_LOOKUP_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateFindStateIndexFromSecLevel()
 *********************************************************************************************************************/
/*! \brief          Map an external state identifier to an internal state index
 *  \details        -
 *  \param[in]      secLevel    The security level (incl. LOCKED)
 *  \return         -1          Not found
 *  \return         >= 0        Internal state index
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(sint8_least, DCM_CODE) Dcm_StateFindStateIndexFromSecLevel(Dcm_SecLevelType secLevel);
#endif

#if (DCM_STATE_SECURITY_FIXED_BYTES_ENABLED == STD_ON)                                                                                               /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_StateGetSecurityLevelFixedBytes()
 *********************************************************************************************************************/
/*! \brief          Provides fixed bytes set up for a specific security level.
 *  \details        This function provides the fixed bytes for the requested security level.
 *                  A security level without configured fixed bytes will return E_OK and no bytes (bufferSize = 0)
 *  \param[in]      secLevel              The requested security level
 *  \param[out]     fixedBytes            Buffer to receive the fixed byte values
 *  \param[in,out]  bufferSize
 *                  IN                    The provided buffer size
 *                  OUT                   The number of fixed bytes for the requested level
 *  \return         E_OK                  The security bytes were copied to the provided buffer
 *  \return         DCM_E_NOT_OK          The security level is not configured
 *  \return         DCM_E_BUFFERTOOLOW    The buffer was too small, bufferSize will contain the number of bytes needed
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_StateGetSecurityLevelFixedBytes(Dcm_SecLevelType secLevel
                                                                   ,P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) fixedBytes
                                                                   ,P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) bufferSize);
#endif

/**********************************************************************************************************************
 *  Dcm_StateNotifyServiceProcessors()
 *********************************************************************************************************************/
/*! \brief          Notifies all related service processors for a state change (of any state group).
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_StateNotifyServiceProcessors(void);
/**********************************************************************************************************************
 *  Dcm_TskInit()
 *********************************************************************************************************************/
/*! \brief          Task initialization.
 *  \details        Initialization of the task manager sub-module.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskInit(void);

#if (DCM_TSK_TASK_KILL_ENABLED == STD_ON)                                                                                                            /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_TskKillAllTasks()
 *********************************************************************************************************************/
/*! \brief          Kills all killable tasks.
 *  \details        -
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskKillAllTasks(void);
#endif
/**********************************************************************************************************************
 *  Dcm_TmrInit()
 *********************************************************************************************************************/
/*! \brief          Timer initialization.
 *  \details        Initialization of the timer manager sub-module.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TmrInit(void);
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_DidMgrInitMainResources()
 *********************************************************************************************************************/
/*! \brief          Initializes the DID resource handles.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DidMgrInitMainResources(void);

/**********************************************************************************************************************
 *  Dcm_DidMgrInit()
 *********************************************************************************************************************/
/*! \brief          Initializes the DID manager sub-component.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DidMgrInit(void);

# if (DCM_DIDMGR_OPTYPE_RANGE_ISAVAIL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrFilterDidRangeGap()
 *********************************************************************************************************************/
/*! \brief          Verifies whether the DID is supported within a range.
 *  \details        -
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pDidInfoContext    The DID configuration configuration context
 *  \return         DCM_E_OK                    Positive look up result
 *  \return         DCM_E_NOT_OK                Negative look up result
 *  \return         DCM_E_LOOKUP_MATCH_FOUND    DID range match, but found a gap
 *  \return         DCM_E_PENDING               Final result is pending, retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrFilterDidRangeGap(Dcm_OpStatusType          opStatus
                                                                     ,Dcm_DidMgrDidInfoContextPtrType pDidInfoContext);
# endif

# if (DCM_DIDMGR_RANGE_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrDidRangeLookUp()
 *********************************************************************************************************************/
/*! \brief          Searches for the DID in a range to get its corresponding handle (up to 32768 items).
 *  \details        -
 *  \param[in]      opStatus           Current operation status
 *  \param[in,out]  pDidInfoContext    The DID to be found and its context
 *  \param[in]      didOp              The DID operation
 *  \return         DCM_E_OK                    Positive look up result
 *  \return         DCM_E_NOT_OK                Negative look up result
 *  \return         DCM_E_LOOKUP_MATCH_FOUND    DID range match, but found a gap
 *  \return         DCM_E_PENDING               Final result is pending, retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrDidRangeLookUp(Dcm_OpStatusType              opStatus
                                                                      ,Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                                      ,Dcm_DidMgrOpOptType             didOp);
# endif

# if (DCM_DIDMGR_OPTYPE_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrWriteSignal()
 *********************************************************************************************************************/
/*! \brief          Writes a single DID signal for service 0x2E.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pMsgContext        The current request context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     errorCode      The NRC
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrWriteSignal(Dcm_OpStatusType               opStatus
                                                                  ,Dcm_MsgContextPtrType             pMsgContext
                                                                  ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                  ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                  ,Dcm_NegativeResponseCodePtrType   errorCode);
# endif

# if (DCM_DIDMGR_OPTYPE_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrWrite()
 *********************************************************************************************************************/
/*! \brief          Executes the writes of a DID.
 *  \details        Iterates over all signals of a DID.
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pMsgContext        The current request context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     errorCode      The NRC
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrWrite(Dcm_OpStatusType                  opStatus
                                                               ,Dcm_MsgContextPtrType             pMsgContext
                                                               ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                               ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                               ,Dcm_NegativeResponseCodePtrType   errorCode);
# endif

# if (DCM_DIDMGR_OPTYPE_GETSCALINGINFO_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrGetScalingInfoSignal()
 *********************************************************************************************************************/
/*! \brief          Returns a scaling information item of a given DID.
 *  \details        -
 *  \param[in]      opStatus       The operation status
 *  \param[in,out]  pMsgContext    The current request context
 *  \param[in,out]  opFuncInfo     Function pointer info
 *  \param[out]     errorCode      The NRC
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrGetScalingInfoSignal(Dcm_OpStatusType            opStatus
                                                                       ,Dcm_MsgContextPtrType              pMsgContext
                                                                       ,Dcm_DidMgrSignalOpClassInfoPtrType opFuncInfo
                                                                       ,Dcm_NegativeResponseCodePtrType    errorCode);
# endif

# if (DCM_DIDMGR_OPTYPE_GETSCALINGINFO_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrGetScalingInfo()
 *********************************************************************************************************************/
/*! \brief          Returns the scaling information of a given DID.
 *  \details        Iterates over all signals of a DID.
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pMsgContext        The current request context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     errorCode          The NRC
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrGetScalingInfo(Dcm_OpStatusType             opStatus
                                                                  ,Dcm_MsgContextPtrType              pMsgContext
                                                                  ,Dcm_DidMgrDidInfoContextPtrType    pDidInfoContext
                                                                  ,Dcm_DidMgrDidOpTypeContextPtrType  pDidOpTypeContext
                                                                  ,Dcm_NegativeResponseCodePtrType    errorCode);

# endif

# if (DCM_DIDMGR_OPTYPE_IO_ANY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControlSignal()
 *********************************************************************************************************************/
/*! \brief          DID IO control operator
 *  \details        -
 *  \param[in]      opStatus            The operation status
 *  \param[in,out]  pMsgContext         The current request context
 *  \param[in,out]  pDidInfoContext     The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext   The context of the DID operation
 *  \param[out]     errorCode           The NRC
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrIoControlSignal(Dcm_OpStatusType           opStatus
                                                                  ,Dcm_MsgContextPtrType             pMsgContext
                                                                  ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                  ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                  ,Dcm_NegativeResponseCodePtrType   errorCode);
# endif

# if (DCM_DIDMGR_OPTYPE_IO_ANY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControl()
 *********************************************************************************************************************/
/*! \brief          DID IO control operator
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pMsgContext        The current request context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     errorCode          The NRC
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrIoControl(Dcm_OpStatusType                  opStatus
                                                                   ,Dcm_MsgContextPtrType             pMsgContext
                                                                   ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                   ,Dcm_NegativeResponseCodePtrType   errorCode);
# endif

# if (DCM_DIDMGR_OPCLS_IO_ANY_WITH_INT_CEMR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControlWithMask()
 *********************************************************************************************************************/
/*! \brief          DID IO control with control enable mask record support operator.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pMsgContext        The current request context
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     errorCode          The NRC
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrIoControlWithMask(Dcm_OpStatusType         opStatus
                                                                  ,Dcm_MsgContextPtrType             pMsgContext
                                                                  ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                  ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                  ,Dcm_NegativeResponseCodePtrType   errorCode);
# endif

# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControlRtrnCtrl2EcuSignal()
 *********************************************************************************************************************/
/*! \brief          Optimized function for ReturnControlToEcu only!
 *  \details        -
 *  \param[in]      opInfoRef    Operation information
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DidMgrIoControlRtrnCtrl2EcuSignal(
                                                                       Dcm_CfgDidMgrSignalOpClassRefOptType opInfoRef);
# endif

# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControlRtrnCtrl2Ecu()
 *********************************************************************************************************************/
/*! \brief          Optimized function for ReturnControlToEcu only!
 *  \details        -
 *  \param[in]      opInfoRef    Operation information
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DidMgrIoControlRtrnCtrl2Ecu(Dcm_CfgDidMgrDidOpClassHandleOptType opInfoRef);
# endif

# if (DCM_DIDMGR_OPTYPE_READ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignal()
 *********************************************************************************************************************/
/*! \brief          Reads a signal of a DID.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[out]     data               The current request context
 *  \param[in,out]  pAvailLen          The remaining buffer space
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \param[out]     errorCode          The NRC
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignal(Dcm_OpStatusType                  opStatus
                                                                    ,Dcm_MsgType                       pData
                                                                    ,Dcm_CfgNetBufferSizePtrType       pAvailLen
                                                                    ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                    ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                    ,Dcm_NegativeResponseCodePtrType   errorCode);
# endif

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON) && \
     (DCM_DIDMGR_MSIG_OPTYPE_READ_GAP_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadGap()
 *********************************************************************************************************************/
/*! \brief          Reads a gap signal of a DID.
 *  \details        -
 *  \param[in,out]  pAvailLen          The remaining buffer space
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadGap(Dcm_CfgNetBufferSizePtrType       pAvailLen
                                                                 ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                 ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext);
# endif

# if (DCM_DIDMGR_OPTYPE_READ_LENGTH_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadLengthSignal()
 *********************************************************************************************************************/
/*! \brief          Returns the length of a signal.
 *  \details        Reads the length of a specific signal of a DID.
 *  \param[in]      opStatus           The operation status
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[out]     pResLength         The returned length
 *  \param[out]     errorCode          The error code
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadLengthSignal(Dcm_OpStatusType                opStatus
                                                                       ,Dcm_DidMgrDidInfoContextPtrType    pDidInfoContext
                                                                       ,Dcm_DidMgrDidLengthPtrType         pResLength
                                                                       ,Dcm_NegativeResponseCodePtrType    errorCode);
# endif

# if (DCM_DIDMGR_OPTYPE_READ_CHECKCOND_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadCheckCondSignal()
 *********************************************************************************************************************/
/*! \brief          Reads the check condition of a specific signal of a DID.
 *  \details        -
 *  \param[in]      opStatus      The operation status
 *  \param[in,out]  opFuncInfo    Function pointer info
 *  \param[out]     errorCode     The errorCode to be returned
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadCheckCondSignal(Dcm_OpStatusType              opStatus
                                                                        ,Dcm_DidMgrSignalOpClassInfoPtrType opFuncInfo
                                                                        ,Dcm_NegativeResponseCodePtrType    errorCode);
# endif

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrGetSignalLength()
 *********************************************************************************************************************/
/*! \brief          Returns the length of the current signal.
 *  \details        -
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgNetBufferSizeOptType, DCM_CODE) Dcm_DidMgrGetSignalLength(
                                                                Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                               ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext);
# endif

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON) && \
     (DCM_DIDMGR_MSIG_OPTYPE_READ_GAP_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrGetGapRemainingLen()
 *********************************************************************************************************************/
/*! \brief          Returns the length of the current gap signal.
 *  \details        -
 *  \param[in,out]  pDidInfoContext    The context of the DID configuration
 *  \param[in,out]  pDidOpTypeContext  The context of the DID operation
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgNetBufferSizeOptType, DCM_CODE) Dcm_DidMgrGetGapRemainingLen(
                                                                      Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                     ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext);
# endif

/**********************************************************************************************************************
 *  Dcm_DidMgrFilterDidLookUp()
 *********************************************************************************************************************/
/*! \brief          Verifies whether a supported DID is currently enabled for a specific DID operation.
 *  \details        -
 *  \param[in]      pDidInfoContext    The DID configuration information
 *  \param[in]      didOp          The lookup DID operation context
 *  \return         DCM_E_OK       Positive look up result
 *  \return         DCM_E_NOT_OK   Negative look up result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrFilterDidLookUp(
                                                                        Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                                       ,Dcm_DidMgrOpOptType             didOp);

/**********************************************************************************************************************
 *  Dcm_DidMgrConcreteDidLookUp()
 *********************************************************************************************************************/
/*! \brief          Look up for a concrete DID number (no range)
 *  \details        -
 *  \param[in]      pDidInfoContext    The DID configuration configuration context
 *  \param[in]      didOp              The lookup DID operation context
 *  \return         DCM_E_OK      Positive look up result
 *  \return         DCM_E_NOT_OK  Negative look up result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrConcreteDidLookUp(
                                                                        Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                                       ,Dcm_DidMgrOpOptType             didOp);

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON) && \
     (DCM_DIDMGR_MSIG_OPTYPE_READ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadPagedMultiSignal()
 *********************************************************************************************************************/
/*! \brief          Reads all signals for a specific DID using the paged buffer.
 *  \details        -
 *  \param[out]     data               The current request context
 *  \param[in,out]  pAvailLen          The remaining buffer space
 *  \param[in,out]  pDidInfoContext    The DID configuration configuration context
 *  \param[in,out]  pDidOpTypeContext  The DID operation context
 *  \param[out]     errorCode          The NRC
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadPagedMultiSignal(Dcm_MsgType           pData
                                                                  ,Dcm_CfgNetBufferSizePtrType       pAvailLen
                                                                  ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                  ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                  ,Dcm_NegativeResponseCodePtrType   errorCode);
# endif
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_RidMgrExecuteRoutine()
 *********************************************************************************************************************/
/*! \brief          Executes a routine operation.
 *  \details        -
 *  \param[in]      opStatus       The operations status
 *  \param[in]      pMsgContext    Current message context
 *  \param[out]     errorCode      The NRC
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_RidMgrExecuteRoutine(Dcm_OpStatusType opStatus
                                                                        ,Dcm_MsgContextPtrType pMsgContext
                                                                        ,Dcm_NegativeResponseCodePtrType errorCode);

/**********************************************************************************************************************
 *  Dcm_RidMgrGetOpInfo()
 *********************************************************************************************************************/
/*! \brief          Returns the operation descriptor of a RID operation.
 *  \details        -
 *  \param[in]      pRidInfo    The RID info object
 *  \param[in]      ridOp       The requested operation
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_RidMgrOpInfoPtrType, DCM_CODE) Dcm_RidMgrGetOpInfo(Dcm_RidMgrRidInfoPtrType pRidInfo
                                                                            ,Dcm_RidMgrOpType ridOp);

/**********************************************************************************************************************
 *  Dcm_RidMgrRidLookUp()
 *********************************************************************************************************************/
/*! \brief          Looks for the RID to get its corresponding RID information reference.
 *  \details        -
 *  \param[in]      opStatus        The operations status
 *  \param[in]      rid             The RID to be found
 *  \param[in,out]  pRidInfo        The RID information - this must be a reference to a global RAM object!
 *  \return         DCM_E_NOT_OK    No RID has been found
 *  \return         DCM_E_OK        Look up success
 *  \return         DCM_E_PENDING   Look up result is pending, try again
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_RidMgrRidLookUp(Dcm_OpStatusType opStatus
                                                                   ,uint16 rid
                                                                   ,P2VAR(Dcm_RidMgrRidInfoPtrType, AUTOMATIC, DCM_VAR_NOINIT) pRidInfo);

/**********************************************************************************************************************
 *  Dcm_RidMgrRidLookUpFilter()
 *********************************************************************************************************************/
/*! \brief          A RID look up result filter.
 *  \details        -
 *  \param[in]      rid             The RID to be found
 *  \param[in,out]  pRidInfo        The RID information
 *  \return         DCM_E_NOT_OK    No RID has been found
 *  \return         DCM_E_OK        Look up success
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_RidMgrRidLookUpFilter(uint16 rid
                                                                         ,Dcm_RidMgrRidInfoPtrType pRidInfo);
#endif /* (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_DiagInit()
 *********************************************************************************************************************/
/*! \brief          Initializes DCM diagnostic sub-module.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts must be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagInit(void);

/**********************************************************************************************************************
 *  Dcm_DiagAcceptNewRequest()
 *********************************************************************************************************************/
/*! \brief          Checks whether a new request will be accepted.
 *  \details        -
 *  \param[in]      pTranspObj    Currently active DCM TP connection
 *  \return         TRUE          New request is accepted
 *  \return         FALSE         New request is not accepted
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_DiagAcceptNewRequest(Dcm_NetTransportObjectPtrType pTranspObj);

/**********************************************************************************************************************
 *  Dcm_DiagOnTxFinished()
 *********************************************************************************************************************/
/*! \brief          Notifies the diagnostic sub-module that an ongoing transmission just finished.
 *  \details        Called by the TP once an ongoing transmission is finished.
 *  \param[in]      pTranspObj    Currently active DCM TP connection
 *  \param[in]      txStatus      Transmission result
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagOnTxFinished(Dcm_NetTransportObjectPtrType pTranspObj
                                                          ,Dcm_NetTransmissionResultType txStatus);

/**********************************************************************************************************************
 *  Dcm_DiagStartServiceExecution()
 *********************************************************************************************************************/
/*! \brief          Prepares execution of the requested diagnostic service processor.
 *  \details        -
 *  \return         DCM_E_LOOP          Start service processor execution immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Variable Dcm_InstanceContext.Diag.SidIndex must be set.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagStartServiceExecution(Dcm_MsgContextPtrType pMsgContext);

#if(DCM_DIAG_ANY_NOTIFICATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagExecConfirmationFunc()
 *********************************************************************************************************************/
/*! \brief          Executes a confirmation callback and evaluates its return values.
 *  \details        -
 *  \param[in]      notifList     The diagnostic request confirmation list to be executed
 *  \param[in]      confStatus    The post-processing status
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagExecConfirmationFunc(Dcm_CfgDiagNotificationInfoPtrType notifList
                                                                  ,Dcm_ConfirmationStatusType confStatus);
#endif

/**********************************************************************************************************************
 *  Dcm_DiagGetPostProcessResult()
 *********************************************************************************************************************/
/*! \brief          Calculates the Dcm_ConfirmationType value for the post processors.
 *  \details        -
 *  \return         The confirmation status
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_ConfirmationStatusType, DCM_CODE) Dcm_DiagGetPostProcessResult(void);

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_DiagProvideRecoveryStates()
 *********************************************************************************************************************/
/*! \brief          Takes the restored DCM state over.
 *  \details        Takes the external stored and recovered DCM state over.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagProvideRecoveryStates(
                                                   P2VAR(Dcm_RecoveryInfoType, AUTOMATIC, DCM_APPL_DATA) RecoveryInfo);
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_DiagProcessRecoveryInfo()
 *********************************************************************************************************************/
/*! \brief          Takes the restored DCM state over.
 *  \details        Takes the external stored and recovered DCM state over.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagProcessRecoveryInfo(
                                                P2CONST(Dcm_RecoveryInfoType, AUTOMATIC, DCM_VAR_NOINIT) RecoveryInfo);
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_DiagSafeProcessRecoveryInfo()
 *********************************************************************************************************************/
/*! \brief          Checks and takes the restored DCM state over.
 *  \details        Checks and takes the external stored and recovered DCM state over.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagSafeProcessRecoveryInfo(
                                                P2CONST(Dcm_RecoveryInfoType, AUTOMATIC, DCM_VAR_NOINIT) RecoveryInfo);
#endif

#if (DCM_NET_PROCESSING_CANCELLATION_ENABLED == STD_ON)                                                                                              /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoCancelProcessing()
 *********************************************************************************************************************/
/*! \brief          Performs diagnostic job cancellation.
 *  \details        If a diagnostic job is ongoing the appropriate action will be taken to close it deterministically.
 *  \param[in]      ev         The active event(s) of the Dcm_DiagTaskWorker task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_DiagTaskWorker task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_DiagTaskWorker task.
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagWorkerDoCancelProcessing(Dcm_TskTaskEvOptType ev
                                                                                      ,Dcm_TskTaskEvPtrType pPostEv);
#endif

/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoPostProcessing()
 *********************************************************************************************************************/
/*! \brief          Performs post processing of currently finished request.
 *  \details        -
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerDoPostProcessing(void);

/**********************************************************************************************************************
 *  Dcm_DiagWorkerSetDefSessionExtern()
 *********************************************************************************************************************/
/*! \brief          Performs session transition to the default session on external request.
 *  \details        Synchronizes an external session change request with the internal DCM state. If a diagnsotic job is
 *                  still in processing, the session change request will be posponed till the job is finished. This is
 *                  required in order to guarantee clean sequence flow on session change and active diagnostic jobs.
 *  \param[in]      ev         The active event(s) of the Dcm_DiagTaskWorker task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_DiagTaskWorker task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_DiagTaskWorker task.
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagWorkerSetDefSessionExtern(Dcm_TskTaskEvOptType ev
                                                                                       ,Dcm_TskTaskEvPtrType pPostEv);

/**********************************************************************************************************************
 *  Dcm_DiagWorkerProcessNewRequest()
 *********************************************************************************************************************/
/*! \brief          Initiates diagnostic service processing once a new request is received.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the Dcm_DiagTaskWorker task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_DiagTaskWorker task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_DiagTaskWorker task.
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagWorkerProcessNewRequest(Dcm_TskTaskEvOptType ev
                                                                                     ,Dcm_TskTaskEvPtrType pPostEv);

/**********************************************************************************************************************
 *  Dcm_DiagWorkerProcessRcrRpTxEnd()
 *********************************************************************************************************************/
/*! \brief          Prepares for application notification after enforced RCR-RP transmission.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the Dcm_DiagTaskWorker task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_DiagTaskWorker task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_DiagTaskWorker task.
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagWorkerProcessRcrRpTxEnd(Dcm_TskTaskEvOptType ev
                                                                                     ,Dcm_TskTaskEvPtrType pPostEv);

/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoRepeat()
 *********************************************************************************************************************/
/*! \brief          Triggers a scheduled diagnsotic job activity.
 *  \details        Each registered diagnostic job activity will be called out from this point.
 *  \param[in]      ev         The active event(s) of the Dcm_DiagTaskWorker task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_DiagTaskWorker task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_DiagTaskWorker task.
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagWorkerDoRepeat(Dcm_TskTaskEvOptType ev
                                                                            ,Dcm_TskTaskEvPtrType pPostEv);

#if (DCM_TSK_NUM_DIAG_FBLRES > 0)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoGetProgCond()
 *********************************************************************************************************************/
/*! \brief          Gets the programming conditions from FBL/Application.
 *  \details        Checks and takes the external stored and recovered DCM state over.
 *  \param[in]      ev         The active event(s) of the Dcm_DiagTaskFblRes task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_DiagTaskFblRes task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_DiagTaskFblRes task.
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagFblResDoGetProgCond(Dcm_TskTaskEvOptType ev
                                                                                 ,Dcm_TskTaskEvPtrType pPostEv);
#endif

#if (DCM_TSK_NUM_DIAG_FBLRES > 0)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoWaitTxComm()
 *********************************************************************************************************************/
/*! \brief          Waits until the ComM has processed the DCM communication request.
 *  \details        Waits for either P2Star timeout of ComM acknowledge of channel wake up.
 *  \param[in]      ev         The active event(s) of the Dcm_DiagTaskFblRes task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_DiagTaskFblRes task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_DiagTaskFblRes task.
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagFblResDoWaitTxComm(Dcm_TskTaskEvOptType ev
                                                                                ,Dcm_TskTaskEvPtrType pPostEv);
#endif

#if (DCM_TSK_NUM_DIAG_FBLRES > 0)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoResetFlags()
 *********************************************************************************************************************/
/*! \brief          Resets all FBL flags.
 *  \details        Resets all FBL related flags so at next power-on/reset no final response to be sent.
 *  \param[in]      ev         The active event(s) of the Dcm_DiagTaskFblRes task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_DiagTaskFblRes task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_DiagTaskFblRes task.
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagFblResDoResetFlags(Dcm_TskTaskEvOptType ev
                                                                                ,Dcm_TskTaskEvPtrType pPostEv);
#endif

#if (DCM_TSK_NUM_DIAG_FBLRES > 0)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoProcessTxConfirmation()
 *********************************************************************************************************************/
/*! \brief          Performs a session transition after a final positive response.
 *  \details        If the final response was for SID 0x10, the corresponding session transition is performed here.
 *  \param[in]      ev         The active event(s) of the Dcm_DiagTaskFblRes task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_DiagTaskFblRes task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_DiagTaskFblRes task.
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagFblResDoProcessTxConfirmation(Dcm_TskTaskEvOptType ev
                                                                                           ,Dcm_TskTaskEvPtrType pPostEv);
#endif
#if (DCM_VARMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VarMgrInit()
 *********************************************************************************************************************/
/*! \brief          Initialization function.
 *  \details        Initialization of variant manager sub-module.
 *  \param[in]      configPtr    Pointer to a concrete configuration root
 *  \return         TRUE         Configuration root pointer is valid
 *  \return         FALSE        Configuration root pointer is invalid
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_VarMgrInit(Dcm_ConfigPtrType configPtr);
#endif

#if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON) && \
    (DCM_DEV_RAM_SHREDDER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VarMgrRamShredder()
 *********************************************************************************************************************/
/*! \brief          Destroys default global memory content by a pattern for test purposes.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            Global interrupts shall be disabled.
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_VarMgrRamShredder(void);
#else
# define Dcm_VarMgrRamShredder()                                     /* not used */
#endif
#if (DCM_SVC_02_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc02ReadPidData()
 *********************************************************************************************************************/
/*! \brief          Reads a single valid PID data.
 *  \details        -
 *  \param[in]      pid          The PID which data shall be read.
 *  \param[in,out]  pMsgContext  The message context.
 *  \param[in]      maskValue    AID mask value
 *  \return         1            PID successfully read.
 *  \return         0            PID reading failed/skipped.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(uint8, DCM_CODE) Dcm_Svc02ReadPidData(uint8 pid, Dcm_MsgContextPtrType pMsgContext, uint32 maskValue);
#endif /* (DCM_SVC_02_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON)                                                 /* COV_DCM_UNSUPPORTED XF xf xf */
/**********************************************************************************************************************
 *  Dcm_Service06Process_SupportedMid()
 *********************************************************************************************************************/
/*! \brief          Process handling of Supported MIDs (0x00, 0x20, 0x40...)
 *  \details        -
 *  \param[in,out]  pMsgContext             The current request context
 *  \param[out]     errorCode               Negative response code
 *  \context        TASK
 *  \reentrant      TRUE
 *  \synchronous    TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Service06Process_SupportedMid(Dcm_MsgContextPtrType pMsgContext
                                                                       ,Dcm_NegativeResponseCodePtrType errorCode);

/**********************************************************************************************************************
 *  Dcm_Service06Process_SingleMid()
 *********************************************************************************************************************/
/*! \brief          Process handling of single MID reuqest
 *  \details        -
 *  \param[in,out]  pMsgContext             The current request context
 *  \param[out]     errorCode               Negative response code
 *  \context        TASK
 *  \reentrant      TRUE
 *  \synchronous    TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Service06Process_SingleMid(Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType errorCode);
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON) */
#if (DCM_SVC_22_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_DIDMGR_22_ACCESS_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *   Dcm_Svc22IsDidAccessible()
 *********************************************************************************************************************/
/*! \brief          Checks whether service 0x22 is accessible.
 *  \details        Checks whether the service 0x22 functionality is locked by service 0x2A or 0x2C.
 *  \param[in,out]  pDidInfoContext    The context of the DID
 *  \return         TRUE     Service 0x22 functionality is free
 *  \return         FALSE    Service 0x22 functionality is not free
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_Svc22IsDidAccessible(Dcm_DidMgrDidInfoContextPtrType pDidInfoContext);
# endif

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_OFF)
/**********************************************************************************************************************
 *  Dcm_Svc22CopyLinearData()
 *********************************************************************************************************************/
/*! \brief          Manages the data collection for service 0x22.
 *  \details        Collects the data related to service 0x22 from the application by using the linear buffer.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_FORCE_RCRRP       Force NRC 0x78
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22CopyLinearData(Dcm_OpStatusType opStatus
                                                                       ,Dcm_MsgContextPtrType pMsgContext);
# endif

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc22CopyPagedDataInit()
 *********************************************************************************************************************/
/*! \brief          Initializes the data collection for service 0x22.
 *  \details        Initializes the data related to service 0x22 from the application by using the paged buffer.
 *  \param[in,out]  pData                 Pointer to the response data
 *  \param[in,out]  pAvailData            Pointer to the the available buffer size
 *  \param[in,out]  pCurrAvailLen         Pointer to the the current available buffer size
 *  \return         DCM_E_OK              All data has been copied
 *  \return         DCM_E_PENDING         No result yet, retry later
 *  \return         DCM_E_BUFFERTOOLOW    Some data copied but no place, retry later on TP buffer under-run
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22CopyPagedDataInit(Dcm_MsgType pData
                                                                          ,Dcm_CfgNetBufferSizePtrType pAvailLen
                                                                          ,Dcm_CfgNetBufferSizePtrType pCurrAvailLen);
# endif

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc22ReadDidPaged()
 *********************************************************************************************************************/
/*! \brief          Reads a single paged DID for service 0x22.
 *  \details        -
 *  \param[in,out]  pData                 Pointer to the response data
 *  \param[in,out]  pAvailData            Pointer to the the available buffer size
 *  \param[in,out]  pCurrAvailLen         Pointer to the the current available buffer size
 *  \return         DCM_E_OK              All data has been copied
 *  \return         DCM_E_PENDING         No result yet, retry later
 *  \return         DCM_E_BUFFERTOOLOW    Some data copied but no place, retry later on TP buffer under-run
 *  \return         DCM_E_NOT_OK          The DID reading has failed for some reason. NRC is already set.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22ReadDidPaged(Dcm_MsgType pData
                                                                     ,Dcm_CfgNetBufferSizePtrType pAvailLen
                                                                     ,Dcm_CfgNetBufferSizePtrType pCurrAvailLen);
# endif
#endif /* (DCM_SVC_22_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27UtiGetAttemptCntr()
 *********************************************************************************************************************/
/*! \brief          Utility function to restore the attempt counter values from the application.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in,out]  levelMask               Pointer to a security level mask.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27UtiGetAttemptCntr(Dcm_OpStatusType opStatus
                                                                ,P2VAR(uint32, AUTOMATIC, DCM_VAR_NOINIT) levelMask);
# endif

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27ReadAttemptCounter()
 *********************************************************************************************************************/
/*! \brief          Manages reading of an attempt counter value.
 *  \details        If a diagnostic job is ongoing the appropriate action will be taken to close it deterministically.
 *  \param[in]      ev         The active event(s) of the Dcm_Svc27Task task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_Svc27Task task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_Svc27Task task.
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_Svc27ReadAttemptCounter(Dcm_TskTaskEvOptType ev
                                                                                 ,Dcm_TskTaskEvPtrType pPostEv);
# endif

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27WriteAttemptCounter()
 *********************************************************************************************************************/
/*! \brief          Manages writing of an attempt counter value.
 *  \details        If a diagnostic job is ongoing the appropriate action will be taken to close it deterministically.
 *  \param[in]      ev         The active event(s) of the Dcm_Svc27Task task
 *  \param[in,out]  pPostEv    The event(s) to be processed next Dcm_Svc27Task task activation
 *  \context        TASK
 *  \return         Next event step (if needed) within the same or next cycle of the Dcm_Svc27Task task.
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_Svc27WriteAttemptCounter(Dcm_TskTaskEvOptType ev
                                                                                  ,Dcm_TskTaskEvPtrType pPostEv);
# endif
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc28ApplyCommControl()
 *********************************************************************************************************************/
/*! \brief          Apply concrete operation on network channel(s).
 *  \details        -
 *  \param[in]      network    The network handle
 *  \param[in]      mode       The communication mode
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc28ApplyCommControl(Dcm_CfgNetNetIdRefMemType networkRef
                                                               ,Dcm_CommunicationModeType mode);
#endif /* (DCM_SVC_28_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/* --- public members ---------------------------------------------------------------------------------------------- */
/**********************************************************************************************************************
 *  Dcm_Service2ASchedulerInit()
 *********************************************************************************************************************/
/*! \brief          Initialization function.
 *  \details        Initializes the periodic DID scheduler.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Service2ASchedulerInit(void);

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdAddItemByDid()
 *********************************************************************************************************************/
/*! \brief          Inserts a new item to the scheduler without activating it.
 *  \details        -
 *  \param[in,out]  pDidInfoContext    The context of the DID
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdAddItemByDid(Dcm_DidMgrDidInfoContextPtrType pDidInfoContext);

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdCommit()
 *********************************************************************************************************************/
/*! \brief          Commits already inserted items to be scheduled with a given rate.
 *  \details        -
 *  \param[in]      rate    The scheduling rate
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdCommit(Dcm_Svc2ASchedRateMemType rate);

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdDiscard()
 *********************************************************************************************************************/
/*! \brief          Discards all inserted items.
 *  \details        -
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdDiscard(void);

/**********************************************************************************************************************
 *  Dcm_Svc2AOnStateChanged()
 *********************************************************************************************************************/
/*! \brief          Stops all scheduled DIDs no more allowed by the new states.
 *  \details        Stops all scheduled DIDs that are nor more allowed after the state has been changed.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2AOnStateChanged(void);

/* --- private members --------------------------------------------------------------------------------------------- */
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdFindFreeOrInUseItemByDid()
 *********************************************************************************************************************/
/*! \brief          Tries to find already used DID entry slot. If not, returns the last free found.
 *  \details        -
 *  \param[in]      did    The did
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(sint16_least, DCM_CODE) Dcm_Svc2ASchdFindFreeOrInUseItemByDid(uint16 did);

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdUpdateTimers()
 *********************************************************************************************************************/
/*! \brief          Updates all active scheduled item timers.
 *  \details        -
 *  \return         TRUE     Activate processor task
 *  \return         FALSE    Don't activate processor task
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_Svc2ASchdUpdateTimers(void);

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdNextEntryIdxInc()
 *********************************************************************************************************************/
/*! \brief          Scheduler item iterator increment.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdNextEntryIdxInc(void);

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdProcessEntry()
 *********************************************************************************************************************/
/*! \brief          A single PDID processing step.
 *  \details        Performs PDID reading and sending on expired PDID slots.
 *  \param[in]      pSchedTableEntry    The scheduler entry to be processed
 *  \return         DCM_E_OK        Continue processing
 *  \return         DCM_E_PENDING   Processing was posponed
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ASchdProcessEntry(Dcm_Svc2ASchdEntryPtrType pSchedTableEntry);
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc2ADoScheduleDids()
 *********************************************************************************************************************/
/*! \brief          Updates the scheduler content.
 *  \details        -
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADoScheduleDids(Dcm_MsgContextPtrType pMsgContext);

/**********************************************************************************************************************
 *  Dcm_Svc2AStopScheduledDids()
 *********************************************************************************************************************/
/*! \brief          Stops requested DIDs.
 *  \details        -
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AStopScheduledDids(Dcm_MsgContextPtrType pMsgContext);
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrInit()
 *********************************************************************************************************************/
/*! \brief          Initialization function.
 *  \details        Service 0x2C DID definition manager initializer.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2CDefMgrInit(void);

/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrReadSrcItems()
 *********************************************************************************************************************/
/*! \brief          Performs reading on a single DynDID source item (DID or memory area).
 *  \details        -
 *  \param[in]      opStatus   Current DynDID read operation status.
 *  \return         DCM_E_OK         Read of all source items finished with success.
 *  \return         DCM_E_PENDING    One of the source items needs more time to return final result, call again.
 *  \return         DCM_E_NOT_OK     One of the source items returned an error.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CDefMgrReadSrcItems(Dcm_OpStatusType opStatus);

/**********************************************************************************************************************
 *  Dcm_Svc2COnStateChanged()
 *********************************************************************************************************************/
/*! \brief          Clears all no more allowed DynDIDs in the new states.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2COnStateChanged(void);

# if (DCM_DIDMGR_DYNDID_SRCITEM_CHECK_STATE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CStateCheckSrcItems()
 *********************************************************************************************************************/
/*! \brief          Check state and mode group preconditions of each source item.
 *  \details        -
 *  \param[in]      dynDidHandle    DynDID reference to be checked
 *  \return         The NRC
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_Svc2CStateCheckSrcItems(
                                                                        Dcm_CfgDidMgrDynDidHandleOptType dynDidHandle);
# endif

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C01DefMgrRead()
 *********************************************************************************************************************/
/*! \brief          Reads a single DID source item.
 *  \details        -
 *  \param[in]      opStatus        Current DID sourceItem operation status.
 *  \param[out]     pCopyOffset     Returns the start offset of read data into the service 0x2C temp buffer to copy from.
 *  \param[out]     pCopyLength     Returns the data count of read data into the service 0x2C temp buffer to copy from.
 *  \return         DCM_E_OK        Reading finished with success.
 *  \return         DCM_E_PENDING   Reading needs some additional time. Call again.
 *  \return         DCM_E_NOT_OK    Reading finished with failed.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C01DefMgrRead(Dcm_OpStatusType opStatus
                                                                     ,Dcm_CfgNetBufferSizePtrType pCopyOffset
                                                                     ,Dcm_CfgNetBufferSizePtrType pCopyLength);
# endif

# if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C02DefMgrRead()
 *********************************************************************************************************************/
/*! \brief          Reads a single Memory source item.
 *  \details        -
 *  \param[in]      opStatus        Current Memory sourceItem operation status.
 *  \param[out]     pCopyOffset     Returns the start offset of read data into the service 0x2C temp buffer to copy from.
 *  \param[out]     pCopyLength     Returns the data count of read data into the service 0x2C temp buffer to copy from.
 *  \return         DCM_E_OK            Reading finished with success.
 *  \return         DCM_E_FORCE_RCRRP   Send RCR-RP response. Once sent, call again.
 *  \return         DCM_E_PENDING       Reading needs some additional time. Call again.
 *  \return         DCM_E_NOT_OK        Reading finished with failed.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C02DefMgrRead(Dcm_OpStatusType opStatus
                                                                     ,Dcm_CfgNetBufferSizePtrType pCopyOffset
                                                                     ,Dcm_CfgNetBufferSizePtrType pCopyLength);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrReadCheckAccessAndInit()
 *********************************************************************************************************************/
/*! \brief          Reads a single Memory source item.
 *  \details        -
 *  \param[in]      dynDidHandle    Current dynDid handle to be read.
 *  \param[in,out]  opStatus        Current and modified operation status.
 *  \return         DCM_E_OK            Check succeeded, proceed with read.
 *  \return         DCM_E_PENDING       The DynDID is still in usage, try later
 *  \return         DCM_E_NOT_OK        Check failed, leave the DynDID reading.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CDefMgrReadCheckAccessAndInit(
                                                              Dcm_CfgDidMgrDynDidHandleMemType dynDidHandle
                                                             ,P2VAR(Dcm_OpStatusType, AUTOMATIC, AUTOMATIC) pOpStatus);
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc2FReturnControlToEcu()
 *********************************************************************************************************************/
/*! \brief          Reset all active IO controls.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FReturnControlToEcu(void);

/**********************************************************************************************************************
 *  Dcm_Svc2FOnStateChanged()
 *********************************************************************************************************************/
/*! \brief          Reset all active IO controls no more supported in the active DCM state.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FOnStateChanged(void);

# if (DCM_DIDMGR_OPCLS_IO_ANY_WITH_EXT_CEMR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FExtractCEMR()
 *********************************************************************************************************************/
/*! \brief          Extracts the CEMR from the request.
 *  \details        Extracts the CEMR from a byte stream into a 32bit variable. If CEMRsize > 4 -> value is 0.
 *  \param[in]      cemrStream   Points to the beginning of the CEMR in the request
 *  \param[in]      cemrSize     Specifies the CEMR total length
 *  \return         0            If the CEMR size > 4 or no bit has been set. This value is invalid and will only
 *                               be used as initialization of the CEMR, but not passed to the application for NBit CEMR.
 *  \return         >0           Extracted CEMR. Note: For 3Byte CEMR the result is MSB bound!

 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(uint32, DCM_CODE) Dcm_Svc2FExtractCEMR(Dcm_ReadOnlyMsgType                 cemrStream
                                                            ,Dcm_CfgDidMgrIoDidCemrLengthMemType cemrSize);
# endif

# if (DCM_DIDMGR_IO_MASKRECORD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FProcessCEMR()
 *********************************************************************************************************************/
/*! \brief          Processes CEMR of IO DID request if the IO DID supports CEMR.
 *  \details        On IO DIDs with CEMR the CEMR will be extracted and verified for non-zero value.
 *  \param[in,out]  pMsgContext        The current request context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FProcessCEMR(Dcm_MsgContextPtrType pMsgContext);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2FCalculateExpectedReqLength()
 *********************************************************************************************************************/
/*! \brief          Calculates the expected request length including DID data and CEMR.
 *  \details        -
 *  \param[out]     expLengthMin        Returns the expected request minimum length.
 *  \param[out]     expLengthMin        Returns the expected request maximum length.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FCalculateExpectedReqLength(Dcm_DidMgrDidLengthPtrType expLengthMin
                                                                         ,Dcm_DidMgrDidLengthPtrType expLengthMax);

/**********************************************************************************************************************
 *  Dcm_Svc2FCheckReqLength()
 *********************************************************************************************************************/
/*! \brief          Verifies the request length.
 *  \details        Verifies that the request length is valid for the concrete DID and IO operation incl. CEMR.
 *  \param[in,out]  pMsgContext        The current request context
 *  \return         DCM_E_POSITIVERESPONSE            Request length is valid.
 *  \return         !=DCM_E_POSITIVERESPONSE          A validation error has occured.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_Svc2FCheckReqLength(Dcm_MsgContextPtrType pMsgContext);

/**********************************************************************************************************************
 *  Dcm_Svc2FIoDidOperationProcessor()
 *********************************************************************************************************************/
/*! \brief          Process a concrete IODID and its requested operation.
 *  \details        -
 *  \param[in]      pMsgContext      Pointer to current message context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FIoDidOperationProcessor(Dcm_MsgContextPtrType pMsgContext);
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
/*lint -save -esym(961, 19.1)*/
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore*/
/* ----------------------------------------------
 ~&&&   Module internal function declarations
---------------------------------------------- */
#define DCM_START_SEC_CODE
/*lint -save -esym(961, 19.1)*/
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore*/
#if (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_MemMgrValidateAlfid()
 *********************************************************************************************************************/
/*! \brief          Validates the request memory ALFID.
 *  \details        -
 *  \param[in]      streamData                Requested memory data starting with the ALFID byte.
 *  \param[in,out]  pStreamLength
 *                  IN                        Contains the complete stream length.
 *                  OUT                       Returns the left part of the stream (i.e. without protocol header)
 *  \return         DCM_E_POSITIVERESPONSE    If no error found
 *  \return         DCM_E_ANYX                Corresponding NRC to the error detected
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_MemMgrValidateAlfid(Dcm_MsgType streamData
                                                                              ,Dcm_MsgLenPtrType pStreamLength);

/**********************************************************************************************************************
 *  Dcm_MemMgrParseMemStream()
 *********************************************************************************************************************/
/*! \brief          Validates the request memory ALFID.
 *  \details        -
 *  \param[in]      alfid         Requested ALFID byte
 *  \param[in]      streamData    The memory address and size byte stream
 *  \param[out]     pMemBlock     Interpreted memory block information
 *  \return         Position in the byte stream after the parsed memory block information
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_MsgType, DCM_CODE) Dcm_MemMgrParseMemStream(uint8 alfid
                                                              ,Dcm_MsgType streamData
                                                              ,Dcm_MemMgrMemBlockPtrType pMemBlock);

/**********************************************************************************************************************
 *  Dcm_MemMgrCheckMemBlock()
 *********************************************************************************************************************/
/*! \brief          Checks a specific memory block.
 *  \details        -
 *  \param[in]      pMemBlock    The memory block descriptor for validation
 *  \param[in]      memOp        The memory block operation type
 *  \return         Result of analysis
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_MemMgrCheckMemBlock(Dcm_MemMgrMemBlockPtrType pMemBlock
                                                                              ,Dcm_MemMgrMemoryOpType memOp);

/**********************************************************************************************************************
 *  Dcm_MemMgrExecuteMemoryOperation()
 *********************************************************************************************************************/
/*! \brief          Executes a specific memory operation.
 *  \details        -
 *  \param[in]      memOpFunc     Memory operation function
 *  \param[in]      opStatus      Current operation status
 *  \param[in]      pMemBlock     The memory block descriptor for validation
 *  \param[in]      data          data buffer
 *  \param[in,out]  ErrorCode     Negative Response Code
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_MemMgrExecuteMemoryOperation(Dcm_MemMgrOpFuncType memOpFunc
                                                                         ,Dcm_OpStatusType opStatus
                                                                         ,Dcm_MemMgrMemBlockPtrType pMemBlock
                                                                         ,Dcm_MsgType data
                                                                         ,Dcm_NegativeResponseCodePtrType ErrorCode);
#endif /* (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
# if (DCM_SVC_22_OBD_CALIBRATION_ENABLED == STD_ON) || \
     (DCM_SVC_31_OBD_CALIBRATION_ENABLED == STD_ON) || \
     (DCM_OBDUDSIDMGR_CALIBRATION_ENABLED   == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrIsIdEnabled()
 *********************************************************************************************************************/
/*! \brief          Returns the calibrated state of an OBD ID.
 *  \details        -
 *  \param[in]      obdId              The OBD ID to be verified.
 *  \param[in]      pMaskData    A pointer to the OBD ID availability range mask list
 *  \return         TRUE               OBD ID is still enabled
 *  \return         FALSE              OBD ID was calibrated to be disabled
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(boolean, DCM_CODE) Dcm_ObdIdMgrIsIdEnabled(uint8 obdId
                                             ,P2CONST(Dcm_ObdIdMgrMaskValueTableType, AUTOMATIC, DCM_CONST) pMaskData);
# endif
#endif /* (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                         /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrGetAvailabilityMask()
 *********************************************************************************************************************/
/*! \brief          A utility to provide a lookup result of an OBD ID and returning the corresponding AID mask value.
 *  \details        For a given OBD ID, returns the lookup result considering any variant handling/calibration. On
 *                  valid OBD ID value, the corresponding AID mask value will be returned too (also on non AID OBD IDs).
 *  \param[in]      id                  The OBD ID to look for
 *  \param[in]      lookUpTable         The look up table to search in
 *  \param[in]      lookUpFilterTable   The look up table filter (variant dependencies)
 *  \param[in]      pMaskData           The generated 32bit mask value (variant independent/calibratable)
 *  \return         >=0            Valid index of the look up table if OBD ID supported/enabled (in variant)
 *  \return         <0             Invalid look up table index for unsupported/disabled (in variant) OBD ID
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_ObdIdMgrGetAvailabilityMask(uint8 id
                                                                      ,Dcm_Uint8ConstDataPtrType lookUpTable
                                                                      ,Dcm_VarRefMemPtrType lookUpFilterTable
                                                                      ,Dcm_ObdMaskConstDataPtrType pMaskData
                                                                      ,P2VAR(uint32, AUTOMATIC, AUTOMATIC) pMaskValue);
# if (DCM_OBDIDMGR_REQ_PARSER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrParseReqAndPrepRes()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        Processes a list of IDs and in case of availability ID request writes the response data.
 *  \param[in,out]  idDescPtr
 *                  IN             idListSize
 *                  OUT            idDescList size
 *  \param[in,out]  pMsgContext    Current request context
 *  \return         TRUE           Mixed availability and data PIDs
 *  \return         FASLE          Only one kind of PIDs
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_ObdIdMgrParseReqAndPrepRes(Dcm_ObdIdMgrDescPtrType idDescPtr
                                                                                   ,Dcm_MsgContextPtrType pMsgContext);
# endif
#endif /* (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_UTI_LOOKUP_U16_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_UtiLookUpUint16()
 *********************************************************************************************************************/
/*! \brief          Searches a word table for an element.
 *  \details        -
 *  \param[in]      lookUpTable    Pointer to the table to be scanned (first element is table-size!)
 *  \param[in]      value          Value to be found
 *  \return         -1             Look up failed (no match)
 *  \return         >=0            Success, index of the matched position
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            Table pointer must not be NULL_PTR. Total number of elements for look up shall be < 32767.
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_UtiLookUpUint16(P2CONST(uint16, AUTOMATIC, DCM_CONST) lookUpTable
                                                          ,uint16 value);
#endif

/**********************************************************************************************************************
 *  Dcm_UtiGetBitPosition()
 *********************************************************************************************************************/
/*! \brief          Returns the position of the most left set bit in a bit set.
 *  \details        -
 *  \param[in]      bitSet    A bit-set with only one bit set in it.
 *  \return         Returns the position of the set bit
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            bitSet shall contain exactly one bit set!
 *********************************************************************************************************************/
DCM_LOCAL FUNC(uint8, DCM_CODE) Dcm_UtiGetBitPosition(uint32 bitSet);

#if (DCM_UTI_NVM_READ_ENABLED  == STD_ON) || \
    (DCM_UTI_NVM_WRITE_ENABLED == STD_ON)                                                                                                            /* COV_DCM_UNSUPPORTED XF xf xf */
/**********************************************************************************************************************
 *  Dcm_UtiNvMGetErrorStatus()
 *********************************************************************************************************************/
/*! \brief          Poll the error status from the NvM.
 *  \details        -
 *  \param[in]      blockId    Id of the NvRam block
 *  \return         DCM_E_OK       Operation finished with success.
 *  \return         DCM_E_NOT_OK   Operation finished with failure.
 *  \return         DCM_E_PENDING  Operation needs more time to be accomplished.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_UtiNvMGetErrorStatus(uint16 blockId);
#endif
/**********************************************************************************************************************
 *  Dcm_NetUnRegisterAllComMActivity()
 *********************************************************************************************************************/
/*! \brief          Tries to unregister all ComM channels activities.
 *  \details        -
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUnRegisterAllComMActivity(void);

/**********************************************************************************************************************
 *  Dcm_NetUnRegisterComMActivity()
 *********************************************************************************************************************/
/*! \brief          Tries to unregister a ComM channel activity.
 *  \details        -
 *  \param[in]      connId    The connection which has finished its job
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUnRegisterComMActivity(DCM_NETCONNID_PARAMDEF_ONLY);

/**********************************************************************************************************************
 *  Dcm_NetRegisterComMActivity()
 *********************************************************************************************************************/
/*! \brief          Tries to register a ComM channel activity.
 *  \details        -
 *  \param[in]      pTranspObj    The transport object which starts diagnostic job
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetRegisterComMActivity(Dcm_NetTransportObjectPtrType pTranspObj);

/**********************************************************************************************************************
 *  Dcm_NetTransmitUsdtResponse()
 *********************************************************************************************************************/
/*! \brief          Start transmission on this connection.
 *  \details        Start an USDT transmission over a specific connection.
 *  \param[in]      pTranspObj            The transport object to be used during the transmission.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            All the items of the structure must be validly initialized:
 *                  hBuffer               Shall be the TxBuffer handle
 *                  pduInfo.SduDataPtr    Shall point to the TxBuffer
 *                  pduInfo.SduLength     Shall contain the length of the data to be sent
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTransmitUsdtResponse(Dcm_NetTransportObjectPtrType pTranspObj);

/**********************************************************************************************************************
 *  Dcm_NetUsdtTxConfirmation()
 *********************************************************************************************************************/
/*! \brief          Transport object transmission finalization.
 *  \details        Finalization of a transmitted USDT message.
 *  \param[in]      pTranspObj    The transport object used during transmission
 *  \param[in]      result        The transmission result
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUsdtTxConfirmation(Dcm_NetTransportObjectPtrType pTranspObj
                                                        ,Dcm_NetTransmissionResultType result);

#if(DCM_NET_TRANSP_OBJ_DYN_ALLOC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetAllocateOrGetTranspObject()
 *********************************************************************************************************************/
/*! \brief          Transport object allocation.
 *  \details        Allocates a transport object for a concrete client connection.
 *  \param[in]      connId    The connection identifier
 *  \return         Allocated transport object handle
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_CfgNetTObjHandleMemType, DCM_CODE) Dcm_NetAllocateOrGetTranspObject(DCM_NETCONNID_PARAMDEF_ONLY);
#endif

/**********************************************************************************************************************
 *  Dcm_NetTranspObjRelease()
 *********************************************************************************************************************/
/*! \brief          Release transport object resource.
 *  \details        Releases a given transport object.
 *  \param[in]      pTranspObj    The transport object to be released
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetTranspObjRelease(Dcm_NetTransportObjectPtrType pTranspObj);

/**********************************************************************************************************************
 *  Dcm_NetGetConnIdByTesterAddress()
 *********************************************************************************************************************/
/*! \brief          Tries to find the corresponding connection of a diagnostic client.
 *  \details        -
 *  \param[in]      testerAddress    The diagnostic client address to look for
 *  \return         < DCM_NET_INVALID_CONNID    Valid connection id found.
 *  \return         DCM_NET_INVALID_CONNID      No connection found for the source address.
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NetConnRefMemType, DCM_CODE) Dcm_NetGetConnIdByTesterAddress(uint16 testerAddress);

/**********************************************************************************************************************
 *  Dcm_NetUnRegisterActiveConnection()
 *********************************************************************************************************************/
/*! \brief          Unregister a connection.
 *  \details        Unregister an active connection referenced by the given transport object.
 *  \param[in]      pTranspObj    The transport object to be released
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUnRegisterActiveConnection(Dcm_NetTransportObjectPtrType pTranspObj);

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgAllocate()
 *********************************************************************************************************************/
/*! \brief          Periodic message allocation.
 *  \details        Allocates a resource for a periodic message.
 *  \return         DCM_NET_INVALID_PTXOBJ_HANDLE      No free resource found
 *  \return         < DCM_NET_INVALID_PTXOBJ_HANDLE    A concrete valid handle is returned
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_CfgNetPTxObjHandleMemType, DCM_CODE) Dcm_NetPeriodicMsgAllocate(void);
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgRelease()
 *********************************************************************************************************************/
/*! \brief          Releases a concrete periodic message resource.
 *  \details        -
 *  \param[in]      handle    The periodic response message resource handle to be released
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgRelease(DCM_NET_PTXOBJ_PARAMDEF_ONLY);
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgTransmit()
 *********************************************************************************************************************/
/*! \brief          Transmits a periodic message.
 *  \details        -
 *  \param[in]      handle    The periodic response message resource handle to be sent
 *  \param[in]      length    The periodic response message length
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgTransmit(DCM_NET_PTXOBJ_PARAMDEF_FIRST
                                                          PduLengthType length);
#endif
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)                                                                                                  /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetProvideRxBuffer()
 *********************************************************************************************************************/
/*! \brief          Request reception data manager.
 *  \details        This function is called by Dcm_ProvideRxBuffer.
 *  \param[in]      DcmRxPduId      The RxPduId on the current request transmission
 *  \param[in]      TpSduLength     The required data length from the lower layer
 *  \param[out]     PduInfoPtr      Pointer to the request buffer pointer and buffer size
 *  \param[in]      addTObjFlags    Additional transport object flags from caller.
 *  \return         0               BUFREQ_OK
 *  \return         >0              Failed for some reason
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE for different PduIds
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetProvideRxBuffer(PduIdType DcmRxPduId
                                                              ,PduLengthType TpSduLength
                                                              ,P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) *PduInfoPtr
                                                              ,Dcm_NetTransportObjectFlagType addTObjFlags);
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)                                                                                                  /* COV_DCM_SUPPORT_PARTIALLY TX tx xf */
/**********************************************************************************************************************
 *  Dcm_NetStartOfReception()
 *********************************************************************************************************************/
/*! \brief          Start of new request reception.
 *  \details        This function is called by Dcm_StartOfReception.
 *  \param[in]      rxPduId            The RxPDUID of the request
 *  \param[in]      tpSduLength        The total length of the TP message
 *  \param[out]     bufferSizePtr      Available buffer size
 *  \param[in]      addTObjFlags       Additional transport object flags from caller
 *  \return         BUFREQ_OK          A free buffer is available - start copy data
 *  \return         BUFREQ_E_NOT_OK    No free buffer is available - ignore request
 *  \return         BUFREQ_E_OVFL      The request message is too long for the configured buffer
 *  \context        ISR1|ISR2
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetStartOfReception(PduIdType rxPduId
                                                          ,PduLengthType tpSduLength
                                                          ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) bufferSizePtr
                                                          ,Dcm_NetTransportObjectFlagType addTObjFlags);

/**********************************************************************************************************************
 *  Dcm_NetSetComModeEntered()
 *********************************************************************************************************************/
/*! \brief          Internal utility for updating the new communication state.
 *  \details        -
 *  \param[in]      networkId      The communication channel on which this state is now active
 *  \param[in]      newComState    The new state of the communication channel
 *  \context        ISR1|ISR2
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetSetComModeEntered(NetworkHandleType networkId
                                                       ,Dcm_NetComMStateType newComState);
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferCancel()
 *********************************************************************************************************************/
/*! \brief          Dispatches the CancelPage call.
 *  \details        Dispatches the CancelPage call regarding the paged buffer.
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_PagedBufferCancel(void);
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferDataPadding()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        This function is used for data padding.
 *  \param[in,out]  pData                 Pointer to the response data
 *  \param[in,out]  pAvailData            Pointer to the the available buffer size
 *  \return         DCM_E_BUFFERTOOLOW    Enforce transmission of the current part
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_PagedBufferDataPadding(Dcm_MsgType pData
                                                                   ,Dcm_CfgNetBufferSizePtrType pAvailData);
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferStart()
 *********************************************************************************************************************/
/*! \brief          Activate paged buffer write process.
 *  \details        -
 *  \param[in]      updateFunc    Specifies the function to be called to update the page data
 *  \param[in]      cancelFunc    Specifies the function to be called to cancel the page buffer.
 *  \param[in]      resDataLen    Specifies how many bytes will be copied using the update page function.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_PagedBufferStart(Dcm_PagedBufferUpdateFuncType updateFunc
                                                   ,Dcm_PagedBufferCancelFuncType cancelFunc
                                                   ,Dcm_MsgLenType resDataLen);
#endif
/**********************************************************************************************************************
 *  Dcm_RepeaterDeadEnd()
 *********************************************************************************************************************/
/*! \brief          To be used for any "wait for anything" repeater proxies.
 *  \details        In normal case this function will never be called.
 *  \param[in]      opStatus       The operation status
 *  \param[in,out]  pMsgContext    The current request context
 *  \return         DCM_E_OK       This value is always returned
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_RepeaterDeadEnd(Dcm_OpStatusType opStatus
                                                            ,Dcm_MsgContextPtrType pMsgContext);

/**********************************************************************************************************************
 *  Dcm_RepeaterExecute()
 *********************************************************************************************************************/
/*! \brief          Starts polling a repeater proxy.
 *  \details        -
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_RepeaterExecute(void);
#if (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON)                                                                                                          /* COV_DCM_SUPPORT_ALWAYS TX */
# if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchDtcSetting()
 *********************************************************************************************************************/
/*! \brief          Mode management on control DTC setting.
 *  \details        -
 *  \param[in]      newMode    The mode
 *  \param[in]      DTCGroup   The affected DTC group of changed setting
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_ModeSwitchDtcSetting(Rte_ModeType_DcmControlDtcSetting newMode, uint32 DTCGroup);
# endif

# if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchCommControl()
 *********************************************************************************************************************/
/*! \brief          Mode management on communication control.
 *  \details        -
 *  \param[in]      network    The network handle
 *  \param[in]      newMode    The mode
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_ModeSwitchCommControl(Dcm_CfgNetNetIdRefOptType networkRef
                                                        ,Dcm_CommunicationModeType newMode);
# endif
#endif /* (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_StateCheck()
 *********************************************************************************************************************/
/*! \brief          Performs a state rule check.
 *  \details        -
 *  \param[in]      stateRef    Reference to the state precondition table
 *  \param[in]      chkLevel    State level check
 *  \return         The NRC
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_StateCheck(Dcm_CfgStateRefOptType stateRef
                                                                     ,Dcm_DiagCheckLvlType chkLevel);

/**********************************************************************************************************************
 *  Dcm_StateSetSession()
 *********************************************************************************************************************/
/*! \brief          Performs a session state transition.
 *  \details        -
 *  \param[in]      stateRef    The state order number.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_StateSetSession(Dcm_StateIndexOptType stateRef);

#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateSetSecurity()
 *********************************************************************************************************************/
/*! \brief          Performs a security state transition.
 *  \details        -
 *  \param[in]      stateRef    The state order number.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_StateSetSecurity(Dcm_StateIndexOptType stateRef);
#endif
/**********************************************************************************************************************
 *  Dcm_TskScheduler()
 *********************************************************************************************************************/
/*! \brief          Task scheduling.
 *  \details        Scheduling of the task manager sub-module.
 *  \param[in]      tskPrio    The tasks priority to be processed
 *  \context        TASK
 *  \reentrant      TRUE only in case split task is supported.
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_TskScheduler(Dcm_TskTaskPrioMemType tskPrio);

#if (DCM_TSK_TASK_COMPLEX_KILL_ENABLED == STD_ON)                                                                                                    /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_TskScheduler()
 *********************************************************************************************************************/
/*! \brief          Revives all killed tasks.
 *  \details        -
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_TskReviveAllTasks(void);
#else
# define Dcm_TskReviveAllTasks()                                     /* not used */
#endif
/* --- Timer Tasks ------------------------------------------------------------------------------------------------- */
/**********************************************************************************************************************
 *  Dcm_TimerTask()
 *********************************************************************************************************************/
/*! \brief          Timer task scheduling.
 *  \details        Scheduling of the timer manager sub-module.
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_TimerTask(Dcm_TskTaskEvOptType ev
                                            ,Dcm_TskTaskEvPtrType pPostEv);

/* --- PagedBuffer Tasks ------------------------------------------------------------------------------------------- */
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferTask()
 *********************************************************************************************************************/
/*! \brief          Lo priority TX task of the paged buffer sub-module.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_PagedBufferTask(Dcm_TskTaskEvOptType ev
                                                  ,Dcm_TskTaskEvPtrType pPostEv);
#endif

/* --- Diagnostic Tasks -------------------------------------------------------------------------------------------------- */
/**********************************************************************************************************************
 *  Dcm_DiagTaskRx()
 *********************************************************************************************************************/
/*! \brief          Hi priority RX task of the network sub-module.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskRx(Dcm_TskTaskEvOptType ev
                                             ,Dcm_TskTaskEvPtrType pPostEv);

/**********************************************************************************************************************
 *  Dcm_DiagTaskWorker()
 *********************************************************************************************************************/
/*! \brief          Low priority task of the diagnostic sub-module.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskWorker(Dcm_TskTaskEvOptType ev
                                                 ,Dcm_TskTaskEvPtrType pPostEv);

#if (DCM_TSK_NUM_DIAG_GARB_COL > 0)                                                                                                                  /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_DiagTaskGarbageCollector()
 *********************************************************************************************************************/
/*! \brief          High priority task of the diagnostic sub-module.
 *  \details        Releases all obsolete transport objects after prioritization.
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskGarbageCollector(Dcm_TskTaskEvOptType ev
                                                           ,Dcm_TskTaskEvPtrType pPostEv);
#endif

#if (DCM_TSK_NUM_DIAG_FBLRES > 0)
/**********************************************************************************************************************
 *  Dcm_DiagTaskFblRes()
 *********************************************************************************************************************/
/*! \brief          Low priority task of the diagnostic sub-module.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskFblRes(Dcm_TskTaskEvOptType ev
                                                 ,Dcm_TskTaskEvPtrType pPostEv);
#endif

/**********************************************************************************************************************
 *  Dcm_DiagTaskTx()
 *********************************************************************************************************************/
/*! \brief          Hi priority TX task of the diagnostic sub-module.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskTx(Dcm_TskTaskEvOptType ev
                                             ,Dcm_TskTaskEvPtrType pPostEv);

/* --- Net Tasks --------------------------------------------------------------------------------------------------- */
/**********************************************************************************************************************
 *  Dcm_NetTaskTx()
 *********************************************************************************************************************/
/*! \brief          Hi priority task of the network sub-module for transmissions.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetTaskTx(Dcm_TskTaskEvOptType ev
                                            ,Dcm_TskTaskEvPtrType pPostEv);

#if (DCM_NET_TASK_RX_ENABLED == STD_ON)                                                                                                              /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetTaskRx()
 *********************************************************************************************************************/
/*! \brief          Hi priority task of the network sub-module for request prioritization.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetTaskRx(Dcm_TskTaskEvOptType ev
                                            ,Dcm_TskTaskEvPtrType pPostEv);
#endif

#if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)                                                                                                 /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetTaskTaMonitor()
 *********************************************************************************************************************/
/*! \brief          Hi priority task of the network sub-module for request processing suppression.
 *  \details        This function is used to prevent a request processing or to cancel an ongoing request processing.
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetTaskTaMonitor(Dcm_TskTaskEvOptType ev
                                                   ,Dcm_TskTaskEvPtrType pPostEv);
#endif

/* --- ModeManager monitoring task --------------------------------------------------------------------------------- */
#if (DCM_TSK_NUM_MODE_MONITOR > 0)
/**********************************************************************************************************************
 *  Dcm_ModeTaskMonitor()
 *********************************************************************************************************************/
/*! \brief          Lo priority monitoring task of the Mode manager sub-module.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_ModeTaskMonitor(Dcm_TskTaskEvOptType ev
                                                  ,Dcm_TskTaskEvPtrType pPostEv);
#endif

#if (DCM_TSK_NUM_SVC2A_SCHEDULER > 0)                                                                                                                /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdTaskProcess()
 *********************************************************************************************************************/
/*! \brief          Low priority task.
 *  \details        Task for service 0x2A scheduling.
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdTaskProcess(Dcm_TskTaskEvOptType ev
                                                       ,Dcm_TskTaskEvPtrType pPostEv);
#endif

#if (DCM_TSK_NUM_SVC27 > 0)                                                                                                                          /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc27Task()
 *********************************************************************************************************************/
/*! \brief          Low priority task.
 *  \details        Task for service 0x27.
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc27Task(Dcm_TskTaskEvOptType ev
                                            ,Dcm_TskTaskEvPtrType pPostEv);
#endif

#if (DCM_TSK_NUM_DIAG_RECOVERY > 0)                                                                                                                  /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_DiagTaskRecovery()
 *********************************************************************************************************************/
/*! \brief          Low priority task of the diagnostic sub-module to recover an external stored DCM state.
 *  \details        -
 *  \param[in]      ev         The active event(s) of the task
 *  \param[in,out]  pPostEv    The event(s) to be processed next task activation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskRecovery(Dcm_TskTaskEvOptType ev
                                                   ,Dcm_TskTaskEvPtrType pPostEv);
#endif
/* --- Timer notification functions -------------------------------------------------------------------------------- */
/**********************************************************************************************************************
 *  Dcm_OnTimeoutP2()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        This function will be called when a P2 timeout occurs.
 *  \return         Returns always 0 -> no reload
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutP2(void);

/**********************************************************************************************************************
 *  Dcm_OnTimeoutS3()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        This function will be called when a S3 timeout occurs.
 *  \return         Returns always 0 -> no reload
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutS3(void);

#if (DCM_TMR_NUM_FBLRES > 0)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutFblRes()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        TODO
 *  \return         Returns always 0 -> no reload
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutFblRes(void);
#endif

#if (DCM_TMR_NUM_SECURITY_0 > 0)                                                                                                                     /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_OnTimeoutSecurityAccess_0()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        This function will be called when a security access timeout occurs.
 *  \return         Number of reload ticks
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutSecurityAccess_0(void);
#endif

#if (DCM_TMR_NUM_SECURITY_1 > 0)                                                                                                                     /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_OnTimeoutSecurityAccess_1()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        This function will be called when a security access timeout occurs.
 *  \return         Number of reload ticks
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutSecurityAccess_1(void);
#endif

#if (DCM_TMR_NUM_PERIODIC_TX > 0)                                                                                                                    /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_OnTimeoutPeriodicTx()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        The periodic transmission timeout is reached
 *  \return         Number of reload ticks
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutPeriodicTx(void);
#endif

#if (DCM_TMR_NUM_SVC2A_SCHEDULER > 0)                                                                                                                /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_OnTimeoutSvc2AScheduler()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        This function will be called when a service 0x2A scheduler timeout occurs.
 *  \return         Number of reload ticks
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutSvc2AScheduler(void);
#endif

#if (DCM_TMR_NUM_KEEP_ALIVE > 0)                                                                                                                     /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_OnTimeoutKeepAlive()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        This function will be called when a keep alive timeout occurs.
 *  \return         Number of reload ticks
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutKeepAlive(void);
#endif
#if (DCM_DEMAPIMGR_SUPPORT_ENABLED == STD_ON)
# if (DCM_DEMAPI_RETVAL_TO_NRC_MAP_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DemApiGetNrcForDemRetValue()
 *********************************************************************************************************************/
/*! \brief          Converts a DEM API return value to a concret NRC
 *  \details        -
 *  \param[in]      demResult                 DEM API returned value
 *  \param[in]      demResult2NrcMap          Pointer to a DEM API specific map
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
static FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_DemApiGetNrcForDemRetValue(uint8 demResult, Dcm_Uint8ConstDataPtrType demResult2NrcMap);
# endif

# if (DCM_DEMAPI_GETNEXTFILTEREDITEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DemApiConvDemRsltGetNextFilteredItem()
 *********************************************************************************************************************/
/*! \brief          Converts a DEM API return value to a concret DCM return value
 *  \details        -
 *  \param[in]      demResult                 DEM API returned value
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
static FUNC(Std_ReturnType, DCM_CODE) Dcm_DemApiConvDemRsltGetNextFilteredItem(Dcm_DemReturnGetNextFilteredItemType demResult);
# endif
#endif /* (DCM_DEMAPIMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_DIDMGR_CANCEL_OP_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrCancelOperation()
 *********************************************************************************************************************/
/*! \brief          Cancels an ongoing DID operation.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DidMgrCancelOperation(void);
# endif

# if (DCM_DIDMGR_MULTISIGNAL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrOpTypeHandlerInit()
 *********************************************************************************************************************/
/*! \brief          Initialization function.
 *  \details        Prepare DID for multi signal processing for a specific operation type (i.e. Read, ReadCheckCond,
 *                  Write, etc.)
 *  \param[in]      pDidInfoContext    The DID configuration information
 *  \param[in]      pDidOpTypeContext  The DID operation context
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DidMgrOpTypeHandlerInit(Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                          ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext);
# endif

# if (DCM_DIDMGR_OPTYPE_READ_LENGTH_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadLength()
 *********************************************************************************************************************/
/*! \brief          Returns the length of a specific DID.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in]      pDidInfoContext    The DID configuration information
 *  \param[out]     errorCode          The error code
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadLength(Dcm_OpStatusType                opStatus
                                                             ,Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                             ,Dcm_NegativeResponseCodePtrType errorCode);
# endif

# if (DCM_DIDMGR_OPTYPE_READ_CHECKCOND_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadCheckCond()
 *********************************************************************************************************************/
/*! \brief          Returns the check condition of a specific DID.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[in]      pDidInfoContext    The DID configuration configuration context
 *  \param[in]      pDidOpTypeContext  The DID operation context
 *  \param[out]     errorCode          The errorCode to be returned
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadCheckCond(Dcm_OpStatusType                  opStatus
                                                                ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                ,Dcm_NegativeResponseCodePtrType   errorCode);
# endif

/**********************************************************************************************************************
 *  Dcm_DidMgrGetDidInfo()
 *********************************************************************************************************************/
/*! \brief          Returns some information of a specific DID.
 *  \details        Looks for the DID to get its corresponding DidInfo and DidOpInfo (up to 32767 items).
 *  \param[in]      opStatus             The current operation status
 *  \param[in,out]  pDidInfoContext      Contains DID Information
 *  \param[in,out]  pDidOpTypeContext    Contains DID operation state
 *  \param[in]      didOp                The lookup DID operation context
 *  \return         DCM_E_OK                Positive look up result
 *  \return         DCM_E_NOT_OK            Negative look up result
 *  \return         DCM_E_PENDING           Final result is pending, retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            The DID number must be set by the caller (pDidInfoContext->Did is valid).
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrGetDidInfo(Dcm_OpStatusType                  opStatus
                                                             ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                             ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                             ,Dcm_DidMgrOpOptType               didOp);

/**********************************************************************************************************************
 *  Dcm_DidMgrGetDidOpInfo()
 *********************************************************************************************************************/
/*! \brief          Returns the operation handle of a DID.
 *  \details        -
 *  \param[in]      pDidInfoContext    The DID configuration configuration context
 *  \param[in]      didOp              The required DID operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DidMgrGetDidOpInfo(Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                     ,Dcm_DidMgrOpOptType             didOp);

/**********************************************************************************************************************
 *  Dcm_DidMgrGetOpClassInfo()
 *********************************************************************************************************************/
/*! \brief          Returns the operation type of a DID.
 *  \details        -
 *  \param[in]      pDidInfoContext    The DID configuration information
 *  \param[in]      opType             Operation type
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DidMgrGetOpClassInfo(Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                       ,Dcm_DidMgrOpCallOptType         opType);

# if (DCM_DIDMGR_DYNDID_DEEP_CHECK_ON_READ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrDynDidStateCheck()
 *********************************************************************************************************************/
/*! \brief          Checks the state of a specific DID.
 *  \details        Checks a DID operation info considering DynDID content.
 *  \param[in]      pDidInfoContext    The DID configuration configuration context
 *  \return         The negative response code
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_DidMgrDynDidStateCheck(
                                                                       Dcm_DidMgrDidInfoContextPtrType pDidInfoContext);
# else
/* a function like macro is used for optimal code size */
# endif

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_OFF)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadLinear()
 *********************************************************************************************************************/
/*! \brief          Reads a DID for service 0x22 using the linear buffer.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[out]     data               The current request context
 *  \param[in,out]  pAvailLen          The remaining buffer space
 *  \param[in,out]  pDidInfoContext    The DID configuration information context
 *  \param[in,out]  pDidOpTypeContext  The DID operation context
 *  \param[out]     errorCode          The NRC
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadLinear(Dcm_OpStatusType                  opStatus
                                                             ,Dcm_MsgType                       pData
                                                             ,Dcm_CfgNetBufferSizePtrType       pAvailLen
                                                             ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                             ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                             ,Dcm_NegativeResponseCodePtrType   errorCode);
# endif

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadPaged()
 *********************************************************************************************************************/
/*! \brief          Reads a DID for service 0x22 using the paged buffer.
 *  \details        -
 *  \param[in]      opStatus           The operation status
 *  \param[out]     data               The current request context
 *  \param[in,out]  pAvailLen          The remaining buffer space
 *  \param[in,out]  pDidInfoContext    The DID configuration configuration context
 *  \param[in,out]  pDidOpTypeContext  The DID configuration operation context
 *  \param[out]     errorCode          The NRC
 *  \return         The result of the operation
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadPaged(Dcm_OpStatusType                  opStatus
                                                            ,Dcm_MsgType                       pData
                                                            ,Dcm_CfgNetBufferSizePtrType       pAvailLen
                                                            ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                            ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                            ,Dcm_NegativeResponseCodePtrType   errorCode);
# endif
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON)                                                                                                        /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrReadDtcByStatusMask()
 *********************************************************************************************************************/
/*! \brief          Processes a DTC read by status mask service for OBD.
 *  \details        -
 *  \param[in]      pReadDtcContext         The service specific context
 *  \param[in,out]  pMsgContext             Current request context
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdDtcMgrReadDtcByStatusMask(
                                                                     Dcm_ObdDtcMgrReadDtcContextPtrType pReadDtcContext
                                                                    ,Dcm_MsgContextPtrType pMsgContext);

/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrDemGetNumFltrdDtc()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        Calls the GetNumberOfFilteredDTC function.
 *  \param[in]      opStatus                The operation status
 *  \param[in,out]  pMsgContext             Current request context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdDtcMgrDemGetNumFltrdDtc(Dcm_OpStatusType opStatus
                                                                       ,Dcm_MsgContextPtrType pMsgContext);

/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrCpyDemGetNxtFltrdDtc()
 *********************************************************************************************************************/
/*! \brief          Data processor of service (0x03/0x07/0x0A).
 *  \details        Calls the GetNextFilteredDTC function.
 *  \param[in,out]  dataPtr                   Pointer to the response data
 *  \param[in,out]  availLenPtr               Pointer to the the available buffer size
 *  \return         DCM_E_OK                  All data copied
 *  \return         DCM_E_PENDING             Retry later
 *  \return         DCM_E_BUFFERTOOLOW        Retry later, because of no available room any more
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdDtcMgrCpyDemGetNxtFltrdDtc(Dcm_MsgType pData
                                                                          ,Dcm_CfgNetBufferSizePtrType pAvailLen);

# if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_OFF)
/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrCopyLinearData()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        Copies some linear data.
 *  \param[in]      opStatus                The operation status
 *  \param[in,out]  pMsgContext             Current request context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdDtcMgrCopyLinearData(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext);
# endif
#endif /* (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_DiagRcrRpTxFinished()
 *********************************************************************************************************************/
/*! \brief          Performs post processing of currently finished RCR-RP transmission.
 *  \details        -
 *  \param[in]      pTranspObj    Currently active DCM TP connection
 *  \param[in]      txStatus      Transmission result
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagRcrRpTxFinished(Dcm_NetTransportObjectPtrType pTranspObj
                                                      ,Dcm_NetTransmissionResultType txStatus);

/**********************************************************************************************************************
 *  Dcm_DiagSetP2Timings()
 *********************************************************************************************************************/
/*! \brief          Sets the adjusted P2 timings.
 *  \details        -
 *  \param[in]      sesStateIdx    The index of the current session.
 *  \param[in]      protocolIdx    The index of the current protocol.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagSetP2Timings(Dcm_StateIndexMemType    sesStateIdx,
                                                    Dcm_CfgNetProtRefMemType protocolIdx);

/**********************************************************************************************************************
 *  Dcm_DiagRxIndication()
 *********************************************************************************************************************/
/*! \brief          Called once an incoming reception is finished.
 *  \details        -
 *  \param[in]      pTranspObj    Currently active DCM external/internal connection
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagRxIndication(Dcm_NetTransportObjectPtrType pTranspObj);

/**********************************************************************************************************************
 *  Dcm_DiagDispatcher()
 *********************************************************************************************************************/
/*! \brief          Dispatcher of the requested service identifier.
 *  \details        -
 *  \param[in]      opStatus                The operation status
 *  \param[in,out]  pMsgContext             Current request context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagDispatcher(Dcm_OpStatusType opStatus
                                                           ,Dcm_MsgContextPtrType pMsgContext);

/**********************************************************************************************************************
 *  Dcm_SetNegResponse()
 *********************************************************************************************************************/
/*! \brief          Registers a NRC to the request in progress if no other NRC already set.
 *  \details        -
 *  \param[in]      nrc    The error code to be registered
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_SetNegResponse(Dcm_NegativeResponseCodeType nrc);

/**********************************************************************************************************************
 *  Dcm_ProcessingDone()
 *********************************************************************************************************************/
/*! \brief          Finalizes the service job processing.
 *  \details        -
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_ProcessingDone(void);

/**********************************************************************************************************************
 *  Dcm_DiagLookUpFilter()
 *********************************************************************************************************************/
/*! \brief          Performs a lookup result filtering.
 *  \details        -
 *  \param[in]      lookUpResult         The original result of the lookup
 *  \param[in]      lookUpFilterTable    List of filters
 *  \param[in]      stateRef             Reference to the state precondition table
 *  \param[out]     errorCode            The error code to be returned
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_DiagLookUpFilter(sint16_least lookUpResult
                                                           ,Dcm_VarRefMemPtrType lookUpFilterTable
                                                           ,Dcm_DiagCheckLvlType chkLevel
                                                           ,Dcm_NegativeResponseCodePtrType errorCode);
#if (DCM_DIAG_SF_ONLY_SERVICE_ENABLED == STD_ON)                                                                                                     /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DiagSvcWithOnlySubFuncReqLengthGetter()
 *********************************************************************************************************************/
/*! \brief          Default sub-function length getter.
 *  \details        Always returns length of 1 byte (sub-function byte only expected)
 *  \param[in]      sfRef                The sub-function zero-based index.
 *  \return         Expected sub-function specific length (1 byte only)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_DiagSvcWithOnlySubFuncReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef);
#endif

#if (DCM_DIAG_ANY_SERVICE_WITH_SF_ENABLED == STD_ON)                                                                                                 /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DiagVerifyServiceWithSubFunction()
 *********************************************************************************************************************/
/*! \brief          Verifies a service with sub-function.
 *  \details        Implements the ISO14229-1:2013 algorithm for sub-function validation
 *  \param[in,out]  pMsgContext          Current request context
 *  \param[in]      lookUpResult         The sub-service lookup table
 *  \param[in]      lookUpFilterTable    List of sub-service related filters
 *  \param[in]      svcLengthGetter      Functor for accessing a sub-service specific length
 *  \param[out]     pSubSvcRef           A zero-based sub-service index for further processing
 *  \return         DCM_E_POSITIVERESPONSE - validation passed
 *  \return         any other NRC          - validation failed with the returned NRC
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_DiagVerifyServiceWithSubFunction(
                                                                 Dcm_MsgContextPtrType                pMsgContext
                                                                ,Dcm_Uint8ConstDataPtrType            lookUpTable
                                                                ,Dcm_VarRefMemPtrType                 lookUpFilterTable
                                                                ,Dcm_DiagServiceLengthGetterFuncType  svcLengthGetter
                                                                ,Dcm_DiagSubServiceRefOptPtrType      pSubSvcRef);
#endif

#if(DCM_DIAG_ANY_NOTIFICATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagExecIndicationFunc()
 *********************************************************************************************************************/
/*! \brief          Executes an indication callback and evaluates its return values.
 *  \details        -
 *  \param[in]      sid                 The requested SID
 *  \param[in]      notificationType    The notification kind (OEM, SYS)
 *  \param[in]      notifList           The request indication list to be executed
 *  \return         TRUE                Proceed with service validation after return
 *  \return         FALSE               Skip any further service processing after return - call Dcm_ProcessingDone
 *                                      immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            The notification list shall contain at least one element and shall not be NULL_PTR.
 *********************************************************************************************************************/
DCM_LOCAL FUNC(boolean, DCM_CODE) Dcm_DiagExecIndicationFunc(Dcm_MsgItemType sid
                                                            ,Dcm_DiagApplNotificationType notificationType
                                                            ,Dcm_CfgDiagNotificationInfoPtrType notifList);
#endif

/**********************************************************************************************************************
 *  Dcm_DiagTxFinalization()
 *********************************************************************************************************************/
/*! \brief          Timeout notification function.
 *  \details        -
 *  \param[in]      pTranspObj    Currently active DCM TP connection
 *  \param[in]      txStatus      Transmission result
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTxFinalization(Dcm_NetTransportObjectPtrType pTranspObj
                                                     ,Dcm_NetTransmissionResultType txStatus);

#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagOnFblResTxFinished()
 *********************************************************************************************************************/
/*! \brief          Called by the TP once an ongoing transmission is finished.
 *  \details        -
 *  \param[in]      pTranspObj    Currently active DCM TP connection
 *  \param[in]      txStatus      Transmission result
 *  \context        ISR1|ISR2|TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagOnFblResTxFinished(Dcm_NetTransportObjectPtrType pTranspObj
                                                         ,Dcm_NetTransmissionResultType txStatus);
#endif

#if (DCM_NET_PROCESSING_CANCELLATION_ENABLED == STD_ON)                                                                                              /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_DiagCancelProcessing()
 *********************************************************************************************************************/
/*! \brief          Cancel any ongoing job.
 *  \details        This function cancels any ongoing service processing.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagCancelProcessing(void);
#endif
#if(DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_VarMgrLookUpFilter()
 *********************************************************************************************************************/
/*! \brief          Performs a lookup result filtering.
 *  \details        Checks whether a diagnostic object is supported in the active variant.
 *  \param[in]      lookUpResult         The original result of the lookup
 *  \param[in]      lookUpFilterTable    List of filters
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_VarMgrLookUpFilter(sint16_least lookUpResult
                                                             ,Dcm_VarRefMemPtrType lookUpFilterTable);
#else
# define Dcm_VarMgrLookUpFilter(oldResult, filterRefTbl)             (oldResult)                                                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)                                                                                               /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_VarMgrIsEnabledInActiveVariants()
 *********************************************************************************************************************/
/*! \brief          Checks if a diagnostic object is active in at least one variant.
 *  \details        -
 *  \param[in]      cfgVariantRef    Reference to the variant configuration
 *  \return         TRUE             Diagnostic object is active in at least one variant
 *  \return         FALSE            Diagnostic object is not active
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(boolean, DCM_CODE) Dcm_VarMgrIsEnabledInActiveVariants(Dcm_CfgStateRefOptType cfgVariantRef);
#else
# define Dcm_VarMgrIsEnabledInActiveVariants(cfgVariantRef)          ((boolean)Dcm_VarMgrBitSetTestBit(Dcm_PbCfgVarMgrDiagVariantFilter[(cfgVariantRef)], Dcm_SingletonContext.VarMgr.ActiveCfgVariantId)) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif
#if (DCM_SVC_01_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc01GetAvailabilityMask()
 *********************************************************************************************************************/
/*! \brief          Returns the calibrated state of an OBD PID.
 *  \details        -
 *  \param[in]      id                 The OBD PID to be verified.
 *  \param[out]     pMaskValue         A pointer to the OBD PID availability range mask list
 *  \return         >=0                Valid index from the lookup engine.
 *  \return         <0                 OBD PID is not supported (disabled | in variant)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_Svc01GetAvailabilityMask(uint8 id, P2VAR(uint32, AUTOMATIC, AUTOMATIC) pMaskValue);
#endif /* (DCM_SVC_01_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_04_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc04_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*! \brief          Service 0x04 worker.
 *  \details        Calls the ClearDTC function.
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc04_XX_RepeaterProxy(Dcm_OpStatusType      opStatus
                                                                   ,Dcm_MsgContextPtrType pMsgContext);
#endif /* (DCM_SVC_04_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON)                                                 /* COV_DCM_UNSUPPORTED XF xf xf */
/**********************************************************************************************************************
 *  Dcm_Svc06GetAvailabilityMask()
 *********************************************************************************************************************/
/*! \brief          Returns the calibrated state of an OBD MID.
 *  \details        -
 *  \param[in]      id                 The OBD MID to be verified.
 *  \param[out]     pMaskValue         A pointer to the OBD MID availability range mask list
 *  \return         >=0                Valid index from the lookup engine.
 *  \return         <0                 OBD MID is not supported (disabled | in variant)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_Svc06GetAvailabilityMask(uint8 id, P2VAR(uint32, AUTOMATIC, AUTOMATIC) pMaskValue);
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON) */
#if (DCM_SVC_08_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc08GetAvailabilityMask()
 *********************************************************************************************************************/
/*! \brief          Returns the calibrated state of an OBD TID.
 *  \details        -
 *  \param[in]      id                 The OBD TID to be verified.
 *  \param[out]     pMaskValue         A pointer to the OBD TID availability range mask list
 *  \return         >=0                Valid index from the lookup engine.
 *  \return         <0                 OBD MID is not supported (disabled | in variant)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_Svc08GetAvailabilityMask(uint8 id, P2VAR(uint32, AUTOMATIC, AUTOMATIC) pMaskValue);
#endif /* (DCM_SVC_08_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_09_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc09_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*! \brief          Service 0x09 worker
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc09_XX_RepeaterProxy(Dcm_OpStatusType opStatus
                                                                   ,Dcm_MsgContextPtrType pMsgContext);

/**********************************************************************************************************************
 *  Dcm_Svc08GetAvailabilityMask()
 *********************************************************************************************************************/
/*! \brief          Returns the calibrated state of an OBD VID.
 *  \details        -
 *  \param[in]      id                 The OBD VID to be verified.
 *  \param[out]     pMaskValue         A pointer to the OBD VID availability range mask list
 *  \return         >=0                Valid index from the lookup engine.
 *  \return         <0                 OBD VID is not supported (disabled | in variant)
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_Svc09GetAvailabilityMask(uint8 id, P2VAR(uint32, AUTOMATIC, AUTOMATIC) pMaskValue);
#endif /* (DCM_SVC_09_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_10_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_SUPPORT_ALWAYS TX */
# if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc10_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*! \brief          Service 0x10 repeater proxy.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10_XX_RepeaterProxy(Dcm_OpStatusType opStatus
                                                                   ,Dcm_MsgContextPtrType pMsgContext);
# endif
#endif /* (DCM_SVC_10_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_11_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_SVC_11_ECU_RESET_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc11_EcuRst_WaitForAck()
 *********************************************************************************************************************/
/*! \brief          Service 0x11 repeater.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11_EcuRst_WaitForAck(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext);
# endif

# if (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc11_RapPwrDwn_WaitForAck()
 *********************************************************************************************************************/
/*! \brief          Service 0x11 repeater.
 *  \details        -
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11_RapPwrDwn_WaitForAck(Dcm_OpStatusType opStatus
                                                                       ,Dcm_MsgContextPtrType pMsgContext);
# endif

# if (DCM_SVC_11_ECU_RESET_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc11_ProcessEcuReset()
 *********************************************************************************************************************/
/*! \brief          Service 0x11 EcuReset mode switching management
 *  \details        Manages the mode switches for service 0x11. If something goes wrong, an appropriate NRC will be sent.
 *  \param[in]      mode                The ECU reset mode to be switched into
 *  \return         DCM_E_PROCESSINGDONE    Send response (negative)
 *  \return         DCM_E_LOOP              Process immediately with next step
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11_ProcessEcuReset(Dcm_ModeMgrArEnvModeEcuResetType mode);
# endif

# if (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc11_ProcessRapPwrDwn()
 *********************************************************************************************************************/
/*! \brief          Service 0x11 RapidPowerShutDown mode switching management
 *  \details        Manages the mode switches for service 0x11. If something goes wrong, an appropriate NRC will be sent.
 *  \param[in]      mode                The ECU reset mode to be switched into
 *  \return         DCM_E_PROCESSINGDONE    Send response (negative)
 *  \return         DCM_E_LOOP              Process immediately with next step
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11_ProcessRapPwrDwn(Dcm_ModeMgrArEnvModeRapidPowerShutDownType mode);
# endif
#endif /* (DCM_SVC_11_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_14_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc04_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*! \brief          Service 0x14 worker.
 *  \details        Calls the ClearDTC function.
 *  \param[in]      opStatus                The operations status
 *  \param[in]      pMsgContext             Current message context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc14_XX_RepeaterProxy(Dcm_OpStatusType      opStatus
                                                                   ,Dcm_MsgContextPtrType pMsgContext);
#endif /* (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19ReqLengthGetter()
 *********************************************************************************************************************/
/*! \brief          Service 0x19 sub-function length getter.
 *  \details        Always returns the sub-function specific length.
 *  \param[in]      sfRef                The sub-function zero-based index.
 *  \return         Expected sub-function specific length.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc19ReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef);
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_19_08_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetNxtFltrdSeverity()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        Calls the GetNextFilteredDTCAndSeverity function.
 *  \param[in,out]  pData                 Pointer to the response data
 *  \param[in,out]  pAvailLen             Pointer to the the available buffer size
 *  \return         DCM_E_OK              All data copied
 *  \return         DCM_E_PENDING         Retry later
 *  \return         DCM_E_BUFFERTOOLOW    Retry later, because of no available room any more
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetNxtFltrdSeverity(Dcm_MsgType pData
                                                                              ,Dcm_CfgNetBufferSizePtrType pAvailLen);
# endif

# if (DCM_SVC_19_08_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetNxtFltrdSeverity()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        TODO
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \return         DCM_E_OK       Stop polling
 *  \return         DCM_E_LOOP     Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetNxtFltrdSeverity(Dcm_OpStatusType opStatus
                                                                           ,Dcm_MsgContextPtrType pMsgContext);
# endif

# if (DCM_SVC_19_42_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiWwhObdCpyDemGetNxtFltrdSeverity()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        Calls the GetNextFilteredDTCAndSeverity function.
 *  \param[in,out]  pData                 Pointer to the response data
 *  \param[in,out]  pAvailLen             Pointer to the the available buffer size
 *  \return         DCM_E_OK              All data copied
 *  \return         DCM_E_PENDING         Retry later
 *  \return         DCM_E_BUFFERTOOLOW    Retry later, because of no available room any more
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiWwhObdCpyDemGetNxtFltrdSeverity(Dcm_MsgType pData
                                                                               ,Dcm_CfgNetBufferSizePtrType pAvailLen);
# endif

# if (DCM_SVC_19_42_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiWwhObdDemGetNxtFltrdSeverity()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        TODO
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \return         DCM_E_OK       Stop polling
 *  \return         DCM_E_LOOP     Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiWwhObdDemGetNxtFltrdSeverity(Dcm_OpStatusType opStatus
                                                                                 ,Dcm_MsgContextPtrType pMsgContext);
# endif

# if (DCM_SVC_19_03_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetNxtFltrdRecord()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        TODO
 *  \param[in,out]  pData                 Pointer to the response data
 *  \param[in,out]  pAvailLen             Pointer to the the available buffer size
 *  \return         DCM_E_OK              All data copied
 *  \return         DCM_E_PENDING         Retry later
 *  \return         DCM_E_BUFFERTOOLOW    Retry later, because of no available room any more
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetNxtFltrdRecord(Dcm_MsgType pData
                                                                            ,Dcm_CfgNetBufferSizePtrType pAvailLen);
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetNxtFltrdDtc()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        TODO
 *  \param[in,out]  pData                 Pointer to the response data
 *  \param[in,out]  pAvailLen             Pointer to the the available buffer size
 *  \return         DCM_E_OK              All data copied
 *  \return         DCM_E_PENDING         Retry later
 *  \return         DCM_E_BUFFERTOOLOW    Retry later, because of no available room any more
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetNxtFltrdDtc(Dcm_MsgType pData
                                                                         ,Dcm_CfgNetBufferSizePtrType pAvailLen);
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetNxtFltrdDtc()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        TODO
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \return         DCM_E_OK       All data copied
 *  \return         DCM_E_LOOP     Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetNxtFltrdDtc(Dcm_OpStatusType opStatus
                                                                      ,Dcm_MsgContextPtrType pMsgContext);
# endif

# if (DCM_DEMAPI_SVC_19_GETEXTRECORD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetNxtFltrdDtc()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        TODO
 *  \param[in,out]  pData                 Pointer to the response data
 *  \param[in,out]  pAvailLen             Pointer to the the available buffer size
 *  \return         DCM_E_OK              All data copied
 *  \return         DCM_E_PENDING         Retry later
 *  \return         DCM_E_BUFFERTOOLOW    Retry later, because of no available room any more
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
 DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetExtRecord(Dcm_MsgType pData
                                                                        ,Dcm_CfgNetBufferSizePtrType pAvailLen);
# endif

# if (DCM_DEMAPI_SVC_19_GETFFRECORD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetFFRecord()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        TODO
 *  \param[in,out]  pData                 Pointer to the response data
 *  \param[in,out]  pAvailLen             Pointer to the the available buffer size
 *  \return         DCM_E_OK              All data copied
 *  \return         DCM_E_PENDING         Retry later
 *  \return         DCM_E_BUFFERTOOLOW    Retry later, because of no available room any more
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetFFRecord(Dcm_MsgType                 pData
                                                                      ,Dcm_CfgNetBufferSizePtrType pAvailLen);
# endif

# if (DCM_DEMAPI_SVC_19_GETNUMFILTEREDDTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetNumFltrdDtc()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        TODO
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetNumFltrdDtc(Dcm_OpStatusType      opStatus
                                                                      ,Dcm_MsgContextPtrType pMsgContext);
# endif

# if (DCM_DEMAPI_SVC_19_GETSEVERITYOFDTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetSeverityOfDtc()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        TODO
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetSeverityOfDtc(Dcm_OpStatusType opStatus
                                                                        ,Dcm_MsgContextPtrType pMsgContext);
# endif

# if (DCM_DEMAPI_SVC_19_GETSTATUSOFDTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetStatusOfDtc()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        TODO
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetStatusOfDtc(Dcm_OpStatusType opStatus
                                                                      ,Dcm_MsgContextPtrType pMsgContext);
# endif

# if (DCM_DEMAPI_SVC_19_GETSIZEOFFFRECORD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetSizeOfFFRecord()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        TODO
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_OK                Let the page-buffer do the job
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetSizeOfFFRecord(Dcm_OpStatusType opStatus
                                                                         ,Dcm_MsgContextPtrType pMsgContext);
# endif

# if (DCM_DEMAPI_SVC_19_GETSIZEOFEXTRECORD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetSizeOfExtRecord()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        TODO
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_OK                Let the page-buffer do the job
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetSizeOfExtRecord(Dcm_OpStatusType opStatus
                                                                          ,Dcm_MsgContextPtrType pMsgContext);
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_CNT_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiPutNumFilteredDtc()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        TODO
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_PROCESSINGDONE    This value is always returned
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiPutNumFilteredDtc(Dcm_OpStatusType opStatus
                                                                      ,Dcm_MsgContextPtrType pMsgContext);
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_CNT_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportNumDtcByStatusMaskData()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        TODO
 *  \param[in]      dsfClass                DEM SetFilter class type
 *  \param[in]      dtcStatusMask           DTC status mask
 *  \param[in]      dtcSeverity             If severity specific search - define the severity level
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportNumDtcByStatusMaskData(
                                                                                Dcm_Svc19DemSetFilterClassType dsfClass
                                                                               ,uint8 dtcStatusMask
                                                                               ,Dem_DTCSeverityType dtcSeverity
                                                                               ,Dcm_MsgContextPtrType pMsgContext);
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportDtcByStatusMaskData()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        TODO
 *  \param[in]      dsfClass                DEM SetFilter class type
 *  \param[in]      maskUsage               Specifies how to treat the requested status mask (if any)
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_OK                Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportDtcByStatusMaskData(Dcm_Svc19DemSetFilterClassType dsfClass
                                                                          ,Dcm_Svc19DemSetFilterMaskUsageType maskUsage
                                                                          ,Dcm_MsgContextPtrType pMsgContext);
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_EXT_DATA_BY_DTC_NUM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportExtDataRecordByDtcNum()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        TODO
 *  \param[in]      dtcOrigin               The DTC origin to process
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportExtDataRecordByDtcNum(Dem_DTCOriginType dtcOrigin
                                                                                ,Dcm_MsgContextPtrType pMsgContext);
# endif

# if (DCM_SVC_19_14_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetNxtFltrdFDC()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        TODO
 *  \param[in,out]  pData                 Pointer to the response data
 *  \param[in,out]  pAvailLen             Pointer to the the available buffer size
 *  \return         DCM_E_OK              All data copied
 *  \return         DCM_E_PENDING         Retry later
 *  \return         DCM_E_BUFFERTOOLOW    Retry later, because of no available room any more
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetNxtFltrdFDC(Dcm_MsgType pData
                                                                         ,Dcm_CfgNetBufferSizePtrType pAvailLen);
# endif

# if (DCM_SVC_19_14_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetNxtFltrdFDC()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        TODO
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \return         DCM_E_OK       Stop polling
 *  \return         DCM_E_LOOP     Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetNxtFltrdFDC(Dcm_OpStatusType opStatus
                                                                      ,Dcm_MsgContextPtrType pMsgContext);
# endif

# if (DCM_DEMAPI_SVC_19_ANYABLERECORDUPDATE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemDisableRecordUpdate()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        TODO
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemDisableRecordUpdate(Dcm_OpStatusType opStatus
                                                                           ,Dcm_MsgContextPtrType pMsgContext);
# endif

# if (DCM_SVC_19_COPY_LINEAR_DATA_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyLinearData()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        Utility to copy linear data.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyLinearData(Dcm_OpStatusType opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext);
# endif

# if (DCM_SVC_19_COPY_LINEAR_DATA_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiStartLinearCopy()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        Utility to start to copy linear data.
 *  \param[in]      copyFunc                TODO
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc19UtiStartLinearCopy(Dcm_PagedBufferUpdateFuncType copyFunc);
# endif

# if (DCM_SVC_19_CHAINING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiChainStart()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        TODO
 *  \param[in]      funcChain     The function chain
 *  \return         DCM_E_LOOP    Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiChainStart(
                                                   P2CONST(Dcm_RepeaterProxyFuncType, AUTOMATIC, DCM_CONST) funcChain);
# endif

# if (DCM_SVC_19_CHAINING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiChainNext()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        TODO
 *  \return         DCM_E_LOOP    Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiChainNext(void);
# endif

# if (DCM_SVC_19_CHAIN_END_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiChainEnd()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        TODO
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_PROCESSINGDONE    Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiChainEnd(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext);
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_OCCUR_TIME_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportNumDtcByOccurenceTime()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        TODO
 *  \param[in]      dtcOrigin               The DTC origin to process
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportNumDtcByOccurenceTime(Dem_DTCRequestType dtcReqType
                                                                                ,Dcm_MsgContextPtrType pMsgContext);
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_FFR_BY_DTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportDtcFFRByDtc()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of readDtcInfo.
 *  \details        TODO
 *  \param[in]      dtcOrigin      The DTC origin to process
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \return         DCM_E_LOOP     Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportDtcFFRByDtc(Dem_DTCOriginType dtcOrigin
                                                                      ,Dcm_MsgContextPtrType pMsgContext);
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_22_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_DIDMGR_22_ACCESS_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc22CheckAccess()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x22.
 *  \details        Checks the service 0x22 access.
 *  \param[in]      opStatus         Current operation status
 *  \param[in]      pMsgContext      Pointer to current message context
 *  \return         DCM_E_LOOP       Repeat immediately
 *  \return         DCM_E_PENDING    Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22CheckAccess(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext);
# endif

# if (DCM_DIDMGR_OPTYPE_READ_CHECKCOND_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc22CheckCondition()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x22.
 *  \details        Checks the conditions of a requested DID.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22CheckCondition(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc22GetLength()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x22.
 *  \details        Reads the length of a requested DID.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22GetLength(Dcm_OpStatusType opStatus
                                                           ,Dcm_MsgContextPtrType pMsgContext);

/**********************************************************************************************************************
 *  Dcm_Svc22ReadData()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x22.
 *  \details        Reads the data of a requested DID.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_FORCE_RCRRP       Force RCR-RP
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22ReadData(Dcm_OpStatusType opStatus
                                                          ,Dcm_MsgContextPtrType pMsgContext);

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc22CopyPagedData()
 *********************************************************************************************************************/
/*! \brief          Manages the data collection for service 0x22.
 *  \details        Collects the data related to service 0x22 from the application by using the paged buffer.
 *  \param[in,out]  pData                 Pointer to the response data
 *  \param[in,out]  pAvailData            Pointer to the the available buffer size
 *  \return         DCM_E_OK              All data has been copied
 *  \return         DCM_E_PENDING         No result yet, retry later
 *  \return         DCM_E_BUFFERTOOLOW    Some data copied but no place, retry later on TP buffer under-run
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22CopyPagedData(Dcm_MsgType pData
                                                               ,Dcm_CfgNetBufferSizePtrType pAvailLen);
# endif

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc22CopyCancellation()
 *********************************************************************************************************************/
/*! \brief          Cancels the copying process related to service 0x22.
 *  \details        Cancels the page buffer based data exchange between Dcm and application.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc22CopyCancellation(void);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc22DidLookUp()
 *********************************************************************************************************************/
/*! \brief          A generic DID look-up for SID 0x22.
 *  \details        Performs a lookup for a specific DID on any request.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_LOOP              Go to next step
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22DidLookUp(Dcm_OpStatusType      opStatus
                                                           ,Dcm_MsgContextPtrType pMsgContext);
#endif /* (DCM_SVC_22_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_23_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc23CheckAccess()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x23.
 *  \details        Checks the service 0x23 access.
 *  \param[in]      opStatus         Current operation status
 *  \param[in]      pMsgContext      Pointer to current message context
 *  \return         DCM_E_LOOP       Repeat immediately
 *  \return         DCM_E_PENDING    Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc23CheckAccess(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc23ReadMemory()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x23.
 *  \details        Reads the data from the memory.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_FORCE_RCRRP       Force RCR-RP
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc23ReadMemory(Dcm_OpStatusType opStatus
                                                            ,Dcm_MsgContextPtrType pMsgContext);
#endif /* (DCM_SVC_23_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_24_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc24ExecuteOp()
 *********************************************************************************************************************/
/*! \brief          Service 0x24 operation execution unit.
 *  \details        Executes a specific service 0x24 operation.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_OK                Stop polling
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc24ExecuteOp(Dcm_OpStatusType opStatus
                                                           ,Dcm_MsgContextPtrType pMsgContext);

/**********************************************************************************************************************
 *  Dcm_Svc24DidLookUp()
 *********************************************************************************************************************/
/*! \brief          Service 0x24 DID look up client.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_OK                Stop polling
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc24DidLookUp(Dcm_OpStatusType opStatus, Dcm_MsgContextPtrType pMsgContext);
#endif /* (DCM_SVC_24_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_SVC_27_SEED_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27SeedRepeater()
 *********************************************************************************************************************/
/*! \brief          Service 0x27 get seed service port accessor.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_OK                Stop polling
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27SeedRepeater(Dcm_OpStatusType opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext);
# endif

# if (DCM_SVC_27_KEY_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27KeyRepeater()
 *********************************************************************************************************************/
/*! \brief          Service 0x27 send key service port accessor
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_OK                Stop polling
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27KeyRepeater(Dcm_OpStatusType opStatus
                                                                 ,Dcm_MsgContextPtrType pMsgContext);
# endif

# if (DCM_SVC_27_KEY_SUPPORT_ENABLED == STD_ON) && \
     (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27CheckAttemptsExceededRepeater()
 *********************************************************************************************************************/
/*! \brief          Checks whether the number of allowed attempts were reached.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_OK                Stop polling
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27CheckAttemptsExceededRepeater(Dcm_OpStatusType opStatus
                                                                                   ,Dcm_MsgContextPtrType pMsgContext);
# endif

# if (DCM_SVC_27_KEY_SUPPORT_ENABLED == STD_ON) && \
     (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON) && \
     (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27SetAttemptCntrRepeater()
 *********************************************************************************************************************/
/*! \brief          Service 0x27 set attempt counter service port accessor.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_OK                Stop polling
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27SetAttemptCntrRepeater(Dcm_OpStatusType opStatus
                                                                            ,Dcm_MsgContextPtrType pMsgContext);
# endif

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27UtiSetAttemptCntr()
 *********************************************************************************************************************/
/*! \brief          Utility function to notify the application about changed attempt counter values.
 *  \details        -
 *  \param[in]      opStatus                Current operation status
 *  \param[in,out]  levelMask               Pointer to a security level mask.
 *  \return         DCM_E_OK                Stop polling
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc27UtiSetAttemptCntr(Dcm_OpStatusType opStatus
                                                         ,P2VAR(uint32, AUTOMATIC, DCM_VAR_NOINIT) levelMask);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc27ReqLengthGetter()
 *********************************************************************************************************************/
/*! \brief          Service 0x27 sub-function length getter.
 *  \details        Always returns the sub-function specific length.
 *  \param[in]      sfRef                The sub-function zero-based index.
 *  \return         Expected sub-function specific length.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc27ReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef);
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc28EnableCommunication()
 *********************************************************************************************************************/
/*! \brief          Enable communication on all affected channels.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc28EnableCommunication(void);

/**********************************************************************************************************************
 *  Dcm_Svc28ReqLengthGetter()
 *********************************************************************************************************************/
/*! \brief          Service 0x28 sub-function length getter.
 *  \details        Always returns the sub-function specific length.
 *  \param[in]      sfRef                The sub-function zero-based index.
 *  \return         Expected sub-function specific length.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc28ReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef);
#endif /* (DCM_SVC_28_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/* --- public members ---------------------------------------------------------------------------------------------- */
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdStopAll()
 *********************************************************************************************************************/
/*! \brief          Stops all scheduled DIDs.
 *  \details        -
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdStopAll(void);

# if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdCancelReadByHandle()
 *********************************************************************************************************************/
/*! \brief          Stops a single scheduled item.
 *  \details        -
 *  \param[in]      schdHandle    The handle
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdCancelReadByHandle(Dcm_Svc2ASchdItemHandleOptType schdHandle);
# endif

# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON) && \
     (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdCancelReadByDid()
 *********************************************************************************************************************/
/*! \brief          Cancels the reading of a single scheduled item.
 *  \details        -
 *  \param[in]      did    The did
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdCancelReadByDid(uint16 did);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdStopItemByHandle()
 *********************************************************************************************************************/
/*! \brief          Stops a single scheduled item.
 *  \details        -
 *  \param[in]      schdHandle    The handle
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdStopItemByHandle(Dcm_Svc2ASchdItemHandleOptType schdHandle);

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdStopItemByDid()
 *********************************************************************************************************************/
/*! \brief          Cancels the reading of a single scheduled item.
 *  \details        -
 *  \param[in]      did    The did
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdStopItemByDid(uint16 did);

/* --- private members --------------------------------------------------------------------------------------------- */
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdGetItemByDid()
 *********************************************************************************************************************/
/*! \brief          Look up for a scheduled DID.
 *  \details        -
 *  \param[in]      did    The did
 *  \return         Operation result
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_Svc2ASchdGetItemByDid(uint16 did);

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdFinishEntryProcessing()
 *********************************************************************************************************************/
/*! \brief          Finalizes scheduler entry processing (with or without response).
 *  \details        Resets all global states after a scheduler entry was processed. Initiates response transmission
 *                  or releases UUDT message.
 *  \param[in]      doSendResponse    Specifies whether a response shall be sent or not
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdFinishEntryProcessing(boolean doSendResponse);
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc2ADidLookUp()
 *********************************************************************************************************************/
/*! \brief          A generic DID look-up for SID 0x2A.
 *  \details        Performs a lookup for a specific DID on any request.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_LOOP              Go to next step
 *  \return         DCM_E_OK                Found a DID, make next step
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADidLookUp(Dcm_OpStatusType      opStatus
                                                           ,Dcm_MsgContextPtrType pMsgContext);

/**********************************************************************************************************************
 *  Dcm_Svc2AScheduledDidLookUp()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2A.
 *  \details        Performs a lookup for a specific DID on scheduling requests.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_LOOP              Go to next step
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AScheduledDidLookUp(Dcm_OpStatusType      opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext);
/**********************************************************************************************************************
 *  Dcm_Svc2AStoppedDidLookUp()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2A.
 *  \details        Performs a lookup for a specific DID on stop DID requests.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_LOOP              Go to next step
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AStoppedDidLookUp(Dcm_OpStatusType      opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext);

# if (DCM_DIDMGR_PERIODICDID_CHK_COND_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2ADidCheckCondition()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2A.
 *  \details        Checks the conditions of a requested DID.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_OK                Go on with next DID
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADidCheckCondition(Dcm_OpStatusType opStatus
                                                                   ,Dcm_MsgContextPtrType pMsgContext);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2ADidGetLength()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2A.
 *  \details        Returns the length of a requested DID.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_OK                Go on with next DID
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADidGetLength(Dcm_OpStatusType opStatus
                                                              ,Dcm_MsgContextPtrType pMsgContext);
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_SVC_2C_CLEAR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrClear()
 *********************************************************************************************************************/
/*! \brief          Clear all DDID definitions.
 *  \details        Clears all previously defined DDIDs.
 *  \param[in]      dynDidHandle    DynDID reference to be cleared
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2CDefMgrClear(Dcm_CfgDidMgrDynDidHandleMemType dynDidHandle);
# endif
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C_01SrcDidLookUp()
 *********************************************************************************************************************/
/*! \brief          Processes the source items of service 0x2C 0x01.
 *  \details        Performs a lookup for a specific source DID.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C_01SrcDidLookUp(Dcm_OpStatusType opStatus
                                                                 ,Dcm_MsgContextPtrType pMsgContext);
# endif

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON) && \
     (DCM_DIDMGR_OPTYPE_READ_CHECKCOND_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C_01SrcDidCheckCondition()
 *********************************************************************************************************************/
/*! \brief          Processes the source items of service 0x2C 0x01.
 *  \details        Checks the condition of a specific source DID.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C_01SrcDidCheckCondition(Dcm_OpStatusType opStatus
                                                                         ,Dcm_MsgContextPtrType pMsgContext);
# endif

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C_01SrcDidGetLength()
 *********************************************************************************************************************/
/*! \brief          Processes the source items of service 0x2C 0x01.
 *  \details        Returns the length of a specific source DID.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C_01SrcDidGetLength(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2CReqLengthGetter()
 *********************************************************************************************************************/
/*! \brief          Service 0x2C sub-function length getter.
 *  \details        Always returns length of 0 byte to show that the requests have dynamic length and the concrete length
 *                  will be checked later.
 *  \param[in]      sfRef                The sub-function zero-based index.
 *  \return         Expected sub-function specific length.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc2CReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef);

/**********************************************************************************************************************
 *  Dcm_Svc2CParseAndCheckDynDid()
 *********************************************************************************************************************/
/*! \brief          Parses and validates the DynDID to be defined.
 *  \details        -
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \return         The operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CParseAndCheckDynDid(Dcm_OpStatusType      opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext);

/**********************************************************************************************************************
 *  Dcm_Svc2CCheckNumOfItems()
 *********************************************************************************************************************/
/*! \brief          Check DynDID has enough room to keep all requested definitions.
 *  \details        -
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \return         The NRC
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_Svc2CCheckNumOfItems(Dcm_MsgContextPtrType pMsgContext);

# if (DCM_SVC_2C_03_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C_03DidLookUp()
 *********************************************************************************************************************/
/*! \brief          Servie 0x2C 0x03 dedicated DID look up client.
 *  \details        -
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \return         The operation result
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C_03DidLookUp(Dcm_OpStatusType      opStatus
                                                              ,Dcm_MsgContextPtrType pMsgContext);
# endif
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_DIDMGR_2E_ACCESS_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2ECheckAccess()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2E.
 *  \details        Checks the service 0x2E access.
 *  \param[in]      opStatus         Current operation status
 *  \param[in]      pMsgContext      Pointer to current message context
 *  \return         DCM_E_LOOP       Repeat immediately
 *  \return         DCM_E_PENDING    Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ECheckAccess(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2EExecuteOp()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2E.
 *  \details        Executes a specific service 0x2E operation.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2EExecuteOp(Dcm_OpStatusType opStatus
                                                           ,Dcm_MsgContextPtrType pMsgContext);
#endif /* (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_DIDMGR_2F_ACCESS_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FCheckAccess()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2F.
 *  \details        Checks the service 0x2F access.
 *  \param[in]      opStatus         Current operation status
 *  \param[in]      pMsgContext      Pointer to current message context
 *  \return         DCM_E_LOOP       Repeat immediately
 *  \return         DCM_E_PENDING    Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FCheckAccess(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2FExecuteOp()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2F.
 *  \details        Executes a specific service 0x2F operation.
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \return         Next action to perform
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FExecuteOp(Dcm_OpStatusType opStatus
                                                           ,Dcm_MsgContextPtrType pMsgContext);

# if (DCM_SVC_2F_READ_RES_DATA_LEN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FGetLength()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2F.
 *  \details        Reads the length of a requested DID.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FGetLength(Dcm_OpStatusType opStatus
                                                           ,Dcm_MsgContextPtrType pMsgContext);
# endif

# if(DCM_DIDMGR_IODID_READ_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FReadData()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x2F.
 *  \details        -
 *  \param[in]      opStatus       Current operation status
 *  \param[in]      pMsgContext    Pointer to current message context
 *  \return         Next action to perform
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FReadData(Dcm_OpStatusType opStatus
                                                          ,Dcm_MsgContextPtrType pMsgContext);
# endif
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_31_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc31ExecuteOp()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x31.
 *  \details        Executes a specific service 0x31 operation.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_OK                Stop polling
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_FORCE_RCRRP       Force RCR-RP
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc31ExecuteOp(Dcm_OpStatusType opStatus
                                                           ,Dcm_MsgContextPtrType pMsgContext);
#endif /* (DCM_SVC_31_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc3DCheckAccess()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x3D.
 *  \details        Checks the service 0x3D access.
 *  \param[in]      opStatus         Current operation status
 *  \param[in]      pMsgContext      Pointer to current message context
 *  \return         DCM_E_LOOP       Repeat immediately
 *  \return         DCM_E_PENDING    Retry later
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc3DCheckAccess(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc3DWriteMemory()
 *********************************************************************************************************************/
/*! \brief          A sub-function utility of SID 0x3D.
 *  \details        Writes the data to the memory.
 *  \param[in]      opStatus                Current operation status
 *  \param[in]      pMsgContext             Pointer to current message context
 *  \return         DCM_E_OK                Success
 *  \return         DCM_E_PROCESSINGDONE    Send response
 *  \return         DCM_E_LOOP              Repeat immediately
 *  \return         DCM_E_PENDING           Retry later
 *  \return         DCM_E_FORCE_RCRRP       Force RCR-RP
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc3DWriteMemory(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext);
#endif /* (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc85EnableDtcSetting()
 *********************************************************************************************************************/
/*! \brief          Service 0x85 enabler.
 *  \details        Calls the EnableDtcSetting function.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc85EnableDtcSetting(void);

# if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)                                                                                                     /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc85DisableDtcSetting()
 *********************************************************************************************************************/
/*! \brief          Service 0x85 disabler.
 *  \details        Calls the DisableDtcSetting function.
 *  \context        TASK
 *  \reentrant      FALSE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc85DisableDtcSetting(uint32 DTCGroup);
# endif

/**********************************************************************************************************************
 *  Dcm_Svc85ReqLengthGetter()
 *********************************************************************************************************************/
/*! \brief          Service 0x85 sub-function length getter.
 *  \details        Always returns length of 1 or 4 byte depending on whether the optional DTC group is supported.
 *  \param[in]      sfRef                The sub-function zero-based index.
 *  \return         Expected sub-function specific length.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc85ReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef);
#endif /* (DCM_SVC_85_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc86ReqLengthGetter()
 *********************************************************************************************************************/
/*! \brief          Service 0x86 sub-function length getter.
 *  \details        Always returns the sub-function specific length.
 *  \param[in]      sfRef                The sub-function zero-based index.
 *  \return         Expected sub-function specific length.
 *  \context        TASK
 *  \reentrant      TRUE
 *  \pre            -
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc86ReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef);
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
/*lint -save -esym(961, 19.1)*/
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore*/
/* ----------------------------------------------
 ~&&&   Uninitialized RAM of unspecified size
---------------------------------------------- */
#define DCM_START_SEC_VAR_NO_INIT_UNSPECIFIED
/*lint -save -esym(961, 19.1)*/
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore*/
static VAR(Dcm_InstanceContextType, DCM_VAR_NOINIT)  Dcm_InstanceContext;
static VAR(Dcm_SingletonContextType, DCM_VAR_NOINIT) Dcm_SingletonContext;
#define DCM_STOP_SEC_VAR_NO_INIT_UNSPECIFIED
/*lint -save -esym(961, 19.1)*/
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore*/
/* ----------------------------------------------
 ~&&&   Initialized RAM 8-Bit
---------------------------------------------- */
#define DCM_START_SEC_VAR_INIT_8
/*lint -save -esym(961, 19.1)*/
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore*/
DCM_LOCAL VAR(uint8, DCM_VAR_INIT)                                   Dcm_DebugInitState = DCM_DEBUG_UNINITPATTERN;
#define DCM_STOP_SEC_VAR_INIT_8
/*lint -save -esym(961, 19.1)*/
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore*/
/* ----------------------------------------------
 ~&&&   ROM 8-Bit
---------------------------------------------- */
#define DCM_START_SEC_CONST_8
/*lint -save -esym(961, 19.1)*/
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore*/
#if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
/* Converts AR default mode order into the RTE sorted order, keeping the symbolic name representation */
static CONST(Dcm_CommunicationModeType, DCM_CONST) Dcm_ModeComCtrlModeMap[12]=                                                                       /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
   10u /* Dcm->Rte Mode Name: DCM_ENABLE_RX_TX_NORM */
  , 7u /* Dcm->Rte Mode Name: DCM_ENABLE_RX_DISABLE_TX_NORM */
  , 1u /* Dcm->Rte Mode Name: DCM_DISABLE_RX_ENABLE_TX_NORM */
  , 4u /* Dcm->Rte Mode Name: DCM_DISABLE_RX_TX_NORMAL */
  , 9u /* Dcm->Rte Mode Name: DCM_ENABLE_RX_TX_NM */
  , 6u /* Dcm->Rte Mode Name: DCM_ENABLE_RX_DISABLE_TX_NM */
  , 0u /* Dcm->Rte Mode Name: DCM_DISABLE_RX_ENABLE_TX_NM */
  , 3u /* Dcm->Rte Mode Name: DCM_DISABLE_RX_TX_NM */
  ,11u /* Dcm->Rte Mode Name: DCM_ENABLE_RX_TX_NORM_NM */
  , 8u /* Dcm->Rte Mode Name: DCM_ENABLE_RX_DISABLE_TX_NORM_NM */
  , 2u /* Dcm->Rte Mode Name: DCM_DISABLE_RX_ENABLE_TX_NORM_NM */
  , 5u /* Dcm->Rte Mode Name: DCM_DISABLE_RX_TX_NORM_NM */
};
#endif /* (DCM_MODE_COMMCTRL_ENABLED == STD_ON) */
static CONST(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_StateSessionNrcs[DCM_NUM_DIAG_CHK_LVLS]=                                                    /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_E_SERVICENOTSUPPORTEDINACTIVESESSION /* on SID level */
 ,DCM_E_REQUESTOUTOFRANGE /* on Parameter (DID, RID, etc.) level */
 ,DCM_E_SUBFUNCTIONNOTSUPPORTEDINACTIVESESSION /* on SubFunction level */
};
#if (DCM_DEMAPIMGR_SUPPORT_ENABLED == STD_ON)
# if (DCM_DEMAPI_SVC_19_SETDTCFILTER_ENABLED == STD_ON) || \
     (DCM_DEMAPI_SVC_19_SETFFRECORDFILTER_ENABLED == STD_ON) || \
     (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON)                                                                                                       /* COV_DCM_SUPPORT_PARTIALLY TF tf tf xf */
static CONST(uint8, DCM_CONST) Dcm_DemApiNrcMapSetDTCFilter[3]=                                                                                      /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DEM_WRONG_FILTER, DCM_E_REQUESTOUTOFRANGE,
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETNUMFILTEREDDTC_ENABLED == STD_ON) || \
     (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON)                                                                                                       /* COV_DCM_SUPPORT_PARTIALLY TF tf xf */
static CONST(uint8, DCM_CONST) Dcm_DemApiNrcMapGetNumberOfFilteredDTC[3]=                                                                            /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DEM_NUMBER_FAILED, DCM_E_CONDITIONSNOTCORRECT,
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif
#endif /* (DCM_DEMAPIMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
static CONST(Dcm_RidMgrOpType, DCM_CONST) Dcm_RidMgrSubFunc2OpMap[4]=                                                                                /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  0x00u /* no operation */
 ,DCM_RIDMGR_OP_START
 ,DCM_RIDMGR_OP_STOP
 ,DCM_RIDMGR_OP_REQRSLTS
};
#endif /* (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON) */
static CONST(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_DiagObjNotFoundNrcs[DCM_NUM_DIAG_CHK_LVLS]=                                                 /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_E_SERVICENOTSUPPORTED /* on SID level */
 ,DCM_E_REQUESTOUTOFRANGE /* on Parameter (DID, RID, etc.) level */
 ,DCM_E_SUBFUNCTIONNOTSUPPORTED /* on SubFunction level */
};
#if (DCM_SVC_04_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
static CONST(uint8, DCM_CONST) Dcm_Svc04NrcMapClearDTC[]=                                                                                            /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_DEM_RET_CLEAR_W_DTC,        DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_CLEAR_FAILED,       DCM_E_CONDITIONSNOTCORRECT,
# if defined(DCM_DEM_RET_CLEAR_BUSY)
  DCM_DEM_RET_CLEAR_BUSY,         DCM_E_CONDITIONSNOTCORRECT,
# endif
# if defined (DCM_DEM_RET_CLEAR_MEMORY_ERROR)
  DCM_DEM_RET_CLEAR_MEMORY_ERROR, DCM_E_CONDITIONSNOTCORRECT,
# endif
  /* DCM_DEM_RET_CLEAR_W_ORIGIN,  DCM_E_PANIC_NRC  - shall not occur since DCM sets the origin -> enforce DET */
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
#endif /* (DCM_SVC_04_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_14_SUPPORT_ENABLED == STD_ON)
static CONST(uint8, DCM_CONST) Dcm_Svc14NrcMapClearDTC[]=                                                                                            /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_DEM_RET_CLEAR_W_DTC,        DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_CLEAR_FAILED,       DCM_E_CONDITIONSNOTCORRECT,
# if defined(DCM_DEM_RET_CLEAR_BUSY)                                                                                                                 /* COV_DCM_SUPPORT_ALWAYS TX */
  DCM_DEM_RET_CLEAR_BUSY,         DCM_E_CONDITIONSNOTCORRECT,
# endif
# if defined (DCM_DEM_RET_CLEAR_MEMORY_ERROR)                                                                                                        /* COV_DCM_SUPPORT_ALWAYS TX */
  DCM_DEM_RET_CLEAR_MEMORY_ERROR, DCM_E_GENERALPROGRAMMINGFAILURE,
# endif
  /* DCM_DEM_RET_CLEAR_W_ORIGIN,  DCM_E_PANIC_NRC  - shall not occur since DCM sets the origin -> enforce DET */
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
#endif /* (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
# if (DCM_DEMAPI_SVC_19_READ_DTC_EXT_DATA_BY_DTC_NUM_ENABLED == STD_ON)
static CONST(uint8, DCM_CONST) Dcm_Svc19ExtDataRecords[DCM_SVC_19_EXTDATA_RECID_SIZE]=                                                               /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if (DCM_SVC_19_NUM_EXTDATA_RECID > 0)                                                                                                             /* COV_DCM_SUPPORT_ALWAYS TX */
 DCM_SVC_19_LST_EXTDATA_RECID,
#  endif
 DCM_SVC_19_RECLIST_END /* end marker */
};
# endif

# if (DCM_SVC_19_OBD_EXT_RECORD_ENABLED == STD_ON)                                                                                                   /* COV_DCM_UNSUPPORTED XF */
static CONST(uint8, DCM_CONST) Dcm_Svc19ExtDataRecordsObd[DCM_SVC_19_OBD_EXTDATA_RECID_SIZE]=                                                        /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if (DCM_SVC_19_NUM_OBD_EXTDATA_RECID > 0)
 DCM_SVC_19_LST_OBD_EXTDATA_RECID,
#  endif
 DCM_SVC_19_RECLIST_END /* end marker */
};
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_FFR_BY_DTC_ENABLED == STD_ON)
static CONST(uint8, DCM_CONST) Dcm_Svc19FFDataRecords[DCM_SVC_19_FRZFRAME_RECID_SIZE]=                                                               /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
#  if (DCM_SVC_19_NUM_FRZFRAME_RECID > 0)                                                                                                            /* COV_DCM_SUPPORT_ALWAYS TX */
 DCM_SVC_19_LST_FRZFRAME_RECID,
#  endif
 DCM_SVC_19_RECLIST_END /* end marker */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETDTCSAM_ENABLED == STD_ON) || \
     (DCM_DEMAPI_SVC_19_GETDTCSEVAM_ENABLED == STD_ON)
static CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapStdReturnType[3]=                                                                                      /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  E_NOT_OK, DCM_E_CONDITIONSNOTCORRECT,
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETDTCOCCURTIME_ENABLED == STD_ON)
static CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetDTCByOccurrenceTime[3]=                                                                             /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DEM_OCCURR_NOT_AVAILABLE, DCM_E_POSITIVERESPONSE,
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_SVC_19_05_SUPPORT_ENABLED == STD_ON)
static CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetOBDFreezeFrameData[1]=                                                                              /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_ANYABLERECORDUPDATE_ENABLED == STD_ON)
static CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapAnyAbleRecordUpdate[5]=                                                                                /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DEM_DISABLE_DTCRECUP_WRONG_DTCORIGIN, DCM_E_REQUESTOUTOFRANGE,
  DEM_DISABLE_DTCRECUP_WRONG_DTC,       DCM_E_REQUESTOUTOFRANGE,
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETSTATUSOFDTC_ENABLED == STD_ON)
static CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetStatusOfDTC[7]=                                                                                     /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DEM_STATUS_WRONG_DTC,       DCM_E_REQUESTOUTOFRANGE,
  DEM_STATUS_FAILED,          DCM_E_CONDITIONSNOTCORRECT,
  DEM_STATUS_WRONG_DTCORIGIN, DCM_E_CONDITIONSNOTCORRECT,
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETSEVERITYOFDTC_ENABLED == STD_ON)
static CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetSeverityOfDTC[3]=                                                                                   /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DEM_GET_SEVERITYOFDTC_WRONG_DTC, DCM_E_REQUESTOUTOFRANGE,
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETSEVERITYOFDTC_ENABLED == STD_ON)
static CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetFunctionalUnitOfDTC[3]=                                                                             /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DEM_GET_FUNCTIONALUNITOFDTC_WRONG_DTC, DCM_E_REQUESTOUTOFRANGE,
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETSIZEOFEXTRECORD_ENABLED == STD_ON)
static CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetSizeOfExtendedDataRecordByDTC[7]=                                                                   /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_DEM_RET_SIZEOFEDR_W_DTC,    DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_SIZEOFEDR_W_RNUM,   DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_SIZEOFEDR_W_ORIGIN, DCM_E_REQUESTOUTOFRANGE,
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETSIZEOFFFRECORD_ENABLED == STD_ON)
static CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetSizeOfFreezeFrameByDTC[7]=                                                                          /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_DEM_RET_SIZEOFFFR_W_DTC,    DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_SIZEOFFFR_W_RNUM,   DCM_E_REQUESTOUTOFRANGE,
  DCM_DEM_RET_SIZEOFFFR_W_ORIGIN, DCM_E_REQUESTOUTOFRANGE,
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETFFRECORD_ENABLED == STD_ON)
static CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetFreezeFrameDataByDTC[7]=                                                                            /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DEM_GET_FFDATABYDTC_WRONG_DTC,          DCM_E_REQUESTOUTOFRANGE,
  DEM_GET_FFDATABYDTC_WRONG_DTCORIGIN,    DCM_E_REQUESTOUTOFRANGE,
  DEM_GET_FFDATABYDTC_WRONG_RECORDNUMBER, DCM_E_REQUESTOUTOFRANGE,
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif

# if (DCM_DEMAPI_SVC_19_GETEXTRECORD_ENABLED == STD_ON)
static CONST(uint8, DCM_CONST) Dcm_Svc19NrcMapGetExtendedDataRecordByDTC[7]=                                                                         /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DEM_RECORD_WRONG_DTC,          DCM_E_REQUESTOUTOFRANGE,
  DEM_RECORD_WRONG_DTCORIGIN,    DCM_E_REQUESTOUTOFRANGE,
  DEM_RECORD_WRONG_NUMBER,       DCM_E_REQUESTOUTOFRANGE,
  E_OK /* end marker  - E_OK shall never be used as an error code */
};
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
static CONST(Dcm_DidMgrOpMemType, DCM_CONST) Dcm_Svc2FCtrlOp2DidOpTypeMap[4]=                                                                        /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU
 ,DCM_DIDMGR_OPTYPE_IO_RST2DEF
 ,DCM_DIDMGR_OPTYPE_IO_FRZCURSTATE
 ,DCM_DIDMGR_OPTYPE_IO_SHRTTRMADJ
};
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CONST_8
/*lint -save -esym(961, 19.1)*/
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore*/
/* ----------------------------------------------
 ~&&&   ROM of unspecified size
---------------------------------------------- */
#define DCM_START_SEC_CONST_UNSPECIFIED
/*lint -save -esym(961, 19.1)*/
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore*/
static CONST(Dcm_TskTaskInfoType, DCM_CONST) Dcm_TskTaskInfo[DCM_TSK_NUM_TASKS]=                                                                     /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  /* first to be processed */
#if (DCM_TSK_NUM_DIAG_RECOVERY > 0)                                                                                                                  /* COV_DCM_UNSUPPORTED XF */
  DCM_TSK_INIT_INFO(Dcm_DiagTaskRecovery,         (DCM_TSK_ATR_EXEC_MULTI | DCM_TSK_ATR_KILL_NEVER ), DCM_TSK_PRIO_LOW,  0) /* Task to recover an external stored DCM state. */
#endif
#if (DCM_TSK_NUM_NET_TA_MONITOR > 0)                                                                                                                 /* COV_DCM_UNSUPPORTED XF */
  DCM_TSK_INIT_INFO(Dcm_NetTaskTaMonitor,         (DCM_TSK_ATR_EXEC_ONCE  | DCM_TSK_ATR_KILL_NEVER ), DCM_TSK_PRIO_HIGH, 0) /* Requests with a foreign N_TA will be handled here */
#endif
#if (DCM_TSK_NUM_NET_RX > 0)                                                                                                                         /* COV_DCM_UNSUPPORTED XF */
  DCM_TSK_INIT_INFO(Dcm_NetTaskRx,                (DCM_TSK_ATR_EXEC_ONCE  | DCM_TSK_ATR_KILL_NEVER ), DCM_TSK_PRIO_HIGH, 0) /* The P2 timer will be started here - put this task prior timer task. NetRx task must always work */
#endif
  DCM_TSK_INIT_INFO(Dcm_TimerTask,                (DCM_TSK_ATR_EXEC_ONCE  | DCM_TSK_ATR_KILL_NEVER ), DCM_TSK_PRIO_HIGH, 0) /* process timers first, the tasks will do their job according to the event priorities. Never kill timer task! */
  DCM_TSK_INIT_INFO(Dcm_DiagTaskRx,               (DCM_TSK_ATR_EXEC_ONCE  | DCM_TSK_ATR_KILL_ALWAYS), DCM_TSK_PRIO_HIGH, (DCM_TSK_EV_DIAG_RX_TMR_P2_TO | DCM_TSK_EV_DIAG_RX_NEW_REQ))
#if (DCM_TSK_NUM_MODE_MONITOR > 0)
  DCM_TSK_INIT_INFO(Dcm_ModeTaskMonitor,          (DCM_TSK_ATR_EXEC_MULTI | DCM_TSK_ATR_KILL_NEVER ), DCM_TSK_PRIO_LOW , 0) /* let monitors work in the background */
#endif
#if (DCM_TSK_NUM_DIAG_FBLRES > 0)
  DCM_TSK_INIT_INFO(Dcm_DiagTaskFblRes,           (DCM_TSK_ATR_EXEC_MULTI | DCM_TSK_ATR_KILL_NEVER ), DCM_TSK_PRIO_LOW , 0)/* let FBL work in the background till end */
#endif
#if (DCM_TSK_NUM_SVC27 > 0)                                                                                                                          /* COV_DCM_UNSUPPORTED XF */
  DCM_TSK_INIT_INFO(Dcm_Svc27Task,                (DCM_TSK_ATR_EXEC_ONCE  | DCM_TSK_ATR_KILL_NEVER ), DCM_TSK_PRIO_LOW , 0) /* Collects the attempt counter values. */
#endif
  DCM_TSK_INIT_INFO(Dcm_DiagTaskWorker,           (DCM_TSK_ATR_EXEC_MULTI | DCM_TSK_ATR_KILL_ALWAYS), DCM_TSK_PRIO_LOW , (DCM_TSK_EV_DIAG_WORK_KILL_JOBS|DCM_TSK_EV_DIAG_WORK_INT_SET2DEF|DCM_TSK_EV_DIAG_WORK_NEW_REQ|DCM_TSK_EV_DIAG_WORK_TX_END_FINAL))
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
  DCM_TSK_INIT_INFO(Dcm_PagedBufferTask,          (DCM_TSK_ATR_EXEC_MULTI | DCM_TSK_ATR_KILL_ALWAYS), DCM_TSK_PRIO_LOW , 0)
#endif
#if (DCM_TSK_NUM_ROE > 0)                                                                                                                            /* COV_DCM_UNSUPPORTED XF */
  DCM_TSK_INIT_INFO(Dcm_ExtSvc86Task,             (DCM_TSK_ATR_ROE_EXEC   | DCM_TSK_ATR_KILL_NEVER ), DCM_TSK_PRIO_LOW , 0) /* let RoE work in the background - if RoE triggered the client prioritization will take place */
#endif
#if (DCM_TSK_NUM_DIAG_GARB_COL > 0)                                                                                                                  /* COV_DCM_UNSUPPORTED XF */
  DCM_TSK_INIT_INFO(Dcm_DiagTaskGarbageCollector, (DCM_TSK_ATR_EXEC_ONCE | DCM_TSK_ATR_KILL_NEVER),  DCM_TSK_PRIO_HIGH, 0)
#endif
  DCM_TSK_INIT_INFO(Dcm_DiagTaskTx,               (DCM_TSK_ATR_EXEC_MULTI | DCM_TSK_ATR_KILL_ALWAYS), DCM_TSK_PRIO_HIGH, DCM_TSK_EV_DIAG_TX_SEND_RCRRP)
#if (DCM_TSK_NUM_SVC2A_SCHEDULER > 0)                                                                                                                /* COV_DCM_UNSUPPORTED XF */
  DCM_TSK_INIT_INFO(Dcm_Svc2ASchdTaskProcess,     (DCM_TSK_ATR_EXEC_ONCE  | DCM_TSK_ATR_KILL_NEVER ), DCM_TSK_PRIO_LOW , 0)/* let 0x2A work in the background if needed to be stopped -> the stop all API shall be used */
#endif
  DCM_TSK_INIT_INFO_LAST(Dcm_NetTaskTx,           (DCM_TSK_ATR_EXEC_MULTI | DCM_TSK_ATR_KILL_NEVER ), DCM_TSK_PRIO_HIGH, 0)
  /* last to be processed */
};
static CONST(Dcm_TmrTimerInfoType, DCM_CONST) Dcm_TmrTimerInfo[DCM_TMR_NUM_TIMERS] =                                                                 /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  {Dcm_OnTimeoutP2}
 ,{Dcm_OnTimeoutS3}
#if (DCM_TMR_NUM_FBLRES > 0)
 ,{Dcm_OnTimeoutFblRes}
#endif
#if (DCM_TMR_NUM_SECURITY_0 > 0)                                                                                                                     /* COV_DCM_UNSUPPORTED XF */
 ,{Dcm_OnTimeoutSecurityAccess_0}
#endif
#if (DCM_TMR_NUM_SECURITY_1 > 0)                                                                                                                     /* COV_DCM_UNSUPPORTED XF */
 ,{Dcm_OnTimeoutSecurityAccess_1}
#endif
#if (DCM_TMR_NUM_PERIODIC_TX > 0)                                                                                                                    /* COV_DCM_UNSUPPORTED XF */
 ,{Dcm_OnTimeoutPeriodicTx}
#endif
#if (DCM_TMR_NUM_SVC2A_SCHEDULER > 0)                                                                                                                /* COV_DCM_UNSUPPORTED XF */
 ,{Dcm_OnTimeoutSvc2AScheduler}
#endif
#if (DCM_TMR_NUM_SVC86_INTERMESSAGETIME > 0)                                                                                                         /* COV_DCM_UNSUPPORTED XF */
 ,{Dcm_ExtOnTimeoutSvc86InterMessageTime}
#endif
#if (DCM_TMR_NUM_KEEP_ALIVE > 0)                                                                                                                     /* COV_DCM_UNSUPPORTED XF */
 ,{Dcm_OnTimeoutKeepAlive}
#endif
};
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_19_SETDTCFILTER_INFO_CLASS_ENABLED == STD_ON)
static CONST(Dcm_Svc19DemDtcFilterInfoType, DCM_CONST) Dcm_Svc19DemDtcFilterInfo[DCM_SVC_19_DEM_SETFILTER_NUM_CLASSES]=                              /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  {DEM_DTC_KIND_ALL_DTCS,           DEM_DTC_ORIGIN_PRIMARY_MEMORY,   DEM_FILTER_WITH_SEVERITY_NO}  /* SF 0x01, 0x02, 0x0A */
 ,{DEM_DTC_KIND_ALL_DTCS,           DEM_DTC_ORIGIN_PRIMARY_MEMORY,   DEM_FILTER_WITH_SEVERITY_YES} /* SF 0x07 */
 ,{DEM_DTC_KIND_ALL_DTCS,           DEM_DTC_ORIGIN_MIRROR_MEMORY,    DEM_FILTER_WITH_SEVERITY_NO}  /* SF 0x11, 0x0F  */
 ,{DEM_DTC_KIND_EMISSION_REL_DTCS,  DEM_DTC_ORIGIN_PRIMARY_MEMORY,   DEM_FILTER_WITH_SEVERITY_NO}  /* SF 0x12, 0x13 */
 ,{DEM_DTC_KIND_ALL_DTCS,           DEM_DTC_ORIGIN_PERMANENT_MEMORY, DEM_FILTER_WITH_SEVERITY_NO}  /* SF 0x15 */
 ,{DEM_DTC_KIND_ALL_DTCS,           DEM_DTC_ORIGIN_SECONDARY_MEMORY, DEM_FILTER_WITH_SEVERITY_NO}  /* SF 0x17 */
};
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_OCCUR_TIME_ENABLED == STD_ON) || \
     (DCM_SVC_19_05_SUPPORT_ENABLED             == STD_ON)
static CONST(Dcm_RepeaterProxyFuncType, DCM_CONST) Dcm_Svc19DemChainGetDtcStatusEnd[2]=                                                              /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  Dcm_Svc19UtiDemGetStatusOfDtc
 ,Dcm_Svc19UtiChainEnd
};
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_FFR_BY_DTC_ENABLED == STD_ON)
static CONST(Dcm_RepeaterProxyFuncType, DCM_CONST) Dcm_Svc19DemChainReadFFRByDtc[3]=                                                                 /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  Dcm_Svc19UtiDemDisableRecordUpdate
 ,Dcm_Svc19UtiDemGetStatusOfDtc
 ,Dcm_Svc19UtiDemGetSizeOfFFRecord
};
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_EXT_DATA_BY_DTC_NUM_ENABLED == STD_ON)
static CONST(Dcm_RepeaterProxyFuncType, DCM_CONST) Dcm_Svc19DemChainReadExtRecords[3]=                                                               /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  Dcm_Svc19UtiDemDisableRecordUpdate
 ,Dcm_Svc19UtiDemGetStatusOfDtc
 ,Dcm_Svc19UtiDemGetSizeOfExtRecord
};
# endif

# if (DCM_SVC_19_09_SUPPORT_ENABLED == STD_ON)
static CONST(Dcm_RepeaterProxyFuncType, DCM_CONST) Dcm_Svc19_09DemChain[3]=                                                                          /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  Dcm_Svc19UtiDemGetSeverityOfDtc
 ,Dcm_Svc19UtiDemGetStatusOfDtc
 ,Dcm_Svc19UtiChainEnd
};
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_CNT_BY_STATUS_MASK_ENABLED == STD_ON)
static CONST(Dcm_RepeaterProxyFuncType, DCM_CONST) Dcm_Svc19DemChainDtcCount[2]=                                                                     /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  Dcm_Svc19UtiDemGetNumFltrdDtc
 ,Dcm_Svc19UtiPutNumFilteredDtc
};
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED == STD_ON)
static CONST(Dcm_RepeaterProxyFuncType, DCM_CONST) Dcm_Svc19DemChainReadDtcByStatus[2]=                                                              /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
 Dcm_Svc19UtiDemGetNumFltrdDtc /* let this API to be called also in linear-buffer case in order to check for the last time if any DEM state error has occured. */
,Dcm_Svc19UtiDemGetNxtFltrdDtc
};
# endif

# if (DCM_SVC_19_08_SUPPORT_ENABLED == STD_ON)
static CONST(Dcm_RepeaterProxyFuncType, DCM_CONST) Dcm_Svc19_08DemChain[2]=                                                                          /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  Dcm_Svc19UtiDemGetNumFltrdDtc
 ,Dcm_Svc19UtiDemGetNxtFltrdSeverity
};
# endif

# if (DCM_SVC_19_14_SUPPORT_ENABLED == STD_ON)
static CONST(Dcm_RepeaterProxyFuncType, DCM_CONST) Dcm_Svc19_14DemChain[2]=                                                                          /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  Dcm_Svc19UtiDemGetNumFltrdDtc
 ,Dcm_Svc19UtiDemGetNxtFltrdFDC
};
# endif
# if (DCM_SVC_19_42_SUPPORT_ENABLED == STD_ON)
static CONST(Dcm_RepeaterProxyFuncType, DCM_CONST) Dcm_Svc19_42DemChain[2]=                                                                          /* PRQA S 3218 */ /* MD_Dcm_CodingRule_3218 */
{
  Dcm_Svc19UtiDemGetNumFltrdDtc /* let this API to be called also in linear-buffer case in order to check for the last time if any DEM state error has occured. */
 ,Dcm_Svc19UtiWwhObdDemGetNxtFltrdSeverity
};
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CONST_UNSPECIFIED
/*lint -save -esym(961, 19.1)*/
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore*/
/* ----------------------------------------------
 ~&&&   Inlined function implementations (Top Level)
---------------------------------------------- */
#define DCM_START_SEC_CODE
/*lint -save -esym(961, 19.1)*/
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore*/
#if (DCM_UTI_LOOKUP_RANGE_U16_ENABLED == STD_ON)                                                                                                     /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_UtiLookUpRangeUint16()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(sint16_least, DCM_CODE) Dcm_UtiLookUpRangeUint16(P2CONST(Dcm_UtiU16RangeType, AUTOMATIC, DCM_CONST) lookUpTable
                                                                      ,uint16 value)
{
  sint16_least  lResult;
  uint16_least  loIdx;
  uint16_least  hiIdx;
  uint16_least  lPosition;

  /* #10 Initialize look-up: assume nothing will be found. */
  lResult = -1;
  loIdx= 1;
  hiIdx= lookUpTable[0].LowerLimit;/* Take one of the borders since both have the same value */

  /* #20 If any sub-array exists: */
  while (loIdx <= hiIdx)
  {
    /*  #30 Calculate entry position for comparison. */
    lPosition = (uint16_least)(loIdx + ((hiIdx - loIdx) / 2)); /* avoids overflows on value addition*/

    /* #40 If valid range found:  */
    if( (lookUpTable[lPosition].LowerLimit <= value)
      &&(lookUpTable[lPosition].UpperLimit >= value) )
    {
      /* #50 Return valid entry position (compensate offset). */
      lResult = (sint16_least)(lPosition-1);
      break;
    }
    /* #60 Otherwise - continue searching. */

    /* #70 Determine which sub-array shall be taken as a next.*/
    if (value < lookUpTable[lPosition].LowerLimit)
    {
      /* not needed lPosition zero value check, since loIdx >=1 */
      hiIdx = (uint16_least)(lPosition - 1);
    }
    else
    {
      /* Use upper half of interval... */
      loIdx = (uint16_least)(lPosition + 1);
    }
  }
  /* #80 Otherwise - report nothing found.  */

  return lResult;
}
#endif
/**********************************************************************************************************************
 *  Dcm_PagedBufferInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_PagedBufferInit(void)
{
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
  Dcm_InstanceContext.PagedBuffer.State = DCM_PAGEDBUFFER_STATE_INACTIVE;
#endif
}

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferUpdatePage()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_PagedBufferUpdatePage(void)
{
  Std_ReturnType lStdResult;
  Dcm_CfgNetBufferSizeOptType freeSpace;
  Dcm_CfgNetBufferSizeOptType retFreeSpace;

  Dcm_DebugAssert((Dcm_InstanceContext.PagedBuffer.State != DCM_PAGEDBUFFER_STATE_INACTIVE), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                  /* COV_DCM_RTM_DEV_DEBUG XF */

  /* #10 If page buffer is in under-run: */
  if(Dcm_InstanceContext.PagedBuffer.IsInUnderrun == TRUE)
  {
    /* #20 If de-fragment needed: */
    if(Dcm_InstanceContext.PagedBuffer.ReadIndex != 0)
    {
      /* #30 De-fragment page. */
      Dcm_CfgNetBufferSizeOptType lPageSize = (Dcm_CfgNetBufferSizeOptType)(Dcm_InstanceContext.PagedBuffer.WriteIndex - Dcm_InstanceContext.PagedBuffer.ReadIndex);

      Dcm_UtiMemCopy(&(Dcm_InstanceContext.PagedBuffer.BufferInfoPtr->BufferPtr[Dcm_InstanceContext.PagedBuffer.ReadIndex])
                      ,Dcm_InstanceContext.PagedBuffer.BufferInfoPtr->BufferPtr
                      ,lPageSize);                                                                                                                   /* PRQA S 3109 */ /* MD_MSR_14.3 */
      /* #40 Enter critical section (Reason: Protect against hi-priority task /ISR CopyTxData). */
      Dcm_UtiArEnvEnterCriticalSection();                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
      /* #50 Update Read- and Write-Index. */
      Dcm_InstanceContext.PagedBuffer.ReadIndex  = 0u;
      Dcm_InstanceContext.PagedBuffer.WriteIndex = (Dcm_CfgNetBufferSizeMemType)lPageSize;
      /* #60 Leave critical section. */
      Dcm_UtiArEnvLeaveCriticalSection();                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
    }
  }
  freeSpace = (Dcm_CfgNetBufferSizeOptType)(Dcm_InstanceContext.PagedBuffer.BufferInfoPtr->Size - Dcm_InstanceContext.PagedBuffer.WriteIndex);
  if(freeSpace > Dcm_InstanceContext.PagedBuffer.RemainingLen)
  {
    /* #70 Provide buffer space as much as requested at Dcm_PagedBufferStart call. */
    freeSpace = (Dcm_CfgNetBufferSizeOptType)Dcm_InstanceContext.PagedBuffer.RemainingLen; /*safe cast since it is ensured that the remaining length has lower value than the freeSpace can handle!*/
  }
  retFreeSpace = freeSpace;
  /* #80 Delegate to the page writer. */
  lStdResult = Dcm_InstanceContext.PagedBuffer.UpdateFunc(&(Dcm_InstanceContext.PagedBuffer.BufferInfoPtr->BufferPtr[Dcm_InstanceContext.PagedBuffer.WriteIndex])
                                                        ,&retFreeSpace);
  /* The new value can only be less or equal than the original ! */
  Dcm_DebugAssert((freeSpace >= retFreeSpace), DCM_SID_INTERNAL, DCM_E_PARAM)                                                                        /* COV_DCM_RTM_DEV_DEBUG XF */

  freeSpace -= retFreeSpace; /* calculate written data length */

  /* #90 If the current writer has failed: */
  if(lStdResult == DCM_E_NOT_OK)
  {
    Dcm_SetNegResponse(DCM_E_PANIC_NRC);
    /* #100 Stop processing. */
    lStdResult = DCM_E_OK;
  }
  /* #110 Otherwise update available length: */
  else
  {
    /* #120 Enter critical section (Reason: Protect against hi-priority task /ISR CopyTxData). */
    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /* #130 Update statistic. */
    Dcm_InstanceContext.PagedBuffer.RemainingLen -= freeSpace;
    Dcm_InstanceContext.PagedBuffer.WriteIndex += (Dcm_CfgNetBufferSizeMemType)freeSpace;
    /* #140 Unlock CopyTx Data. */
    Dcm_InstanceContext.PagedBuffer.IsInUnderrun = FALSE;
    /* #150 Leave critical section. */
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }

  /* #160 If the current writer has nothing to do any more - check how to proceed: */
  if(lStdResult == DCM_E_OK)
  {
    Dcm_InstanceContext.PagedBuffer.UpdateFinished = TRUE;

    /* #170 If something went wrong: */
    if(Dcm_InstanceContext.Diag.ErrorRegister != DCM_E_POSITIVERESPONSE)
    {
      /* #180 Cancel writing or send the NRC. */
      if(Dcm_InstanceContext.PagedBuffer.State == DCM_PAGEDBUFFER_STATE_ACTIVATED)
      {
        /* Reset paged buffer usage and delegate to the linear buffer processor. */
        Dcm_PagedBufferInit();
        Dcm_ProcessingDone();
      }/* else - wait for under-run transmission interruption */
      lStdResult = DCM_E_OK;
    }
    /* #190 If all data reported, but still some data to report: */
    else if(Dcm_InstanceContext.PagedBuffer.RemainingLen != 0u)
    {
      /* #200 Delegate to the padding writer. */
      Dcm_InstanceContext.PagedBuffer.UpdateFunc = Dcm_PagedBufferDataPadding;
    }
    else
    {
      /* nothing to do - just MISRA :) */
    }
  }

  /* #210 If transmission not yet started and some data is already available for transmission: */
  if( (Dcm_InstanceContext.PagedBuffer.State == DCM_PAGEDBUFFER_STATE_ACTIVATED)
    &&(lStdResult != DCM_E_PENDING) ) /* If "if" this expression has to be changed, consider changing the line above (hash180) with "lStdResult = DCM_E_OK;"*/
  {
    /* #220 Activate transmission. */
    Dcm_InstanceContext.PagedBuffer.State = DCM_PAGEDBUFFER_STATE_ONTX;
    Dcm_InstanceContext.Diag.State |= DCM_DIAG_STATE_ON_TX; /* update diagnostic state (PROCESS && ON_TX) */
    Dcm_TskSetEvent(DCM_TSK_ID_DIAG_TX, DCM_TSK_EV_DIAG_TX_SEND_PAGED);
  }

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6010, 6030 */ /* MD_MSR_STPTH, MD_MSR_STCYC */
#endif
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)                                                                                                  /* COV_DCM_UNSUPPORTED XF */
# if(DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferCopyData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_PagedBufferCopyData(
                                                                   P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) PduInfo                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,PduLengthType Length)                                                             /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  BufReq_ReturnType              lResult = BUFREQ_OK;
  PduLengthType                  lPageSize;

  Dcm_DebugAssert((Dcm_InstanceContext.PagedBuffer.State != DCM_PAGEDBUFFER_STATE_INACTIVE), DCM_SID_PROVIDETXBUFFER, DCM_E_ILLEGAL_STATE)           /* COV_DCM_RTM_DEV_DEBUG XF */

  /*
   lPageSize |    Length    | PagedBufferState  | lResult |  BufferSize
  -----------+--------------+-------------------+---------+-------------
      0      |     any      | no data available |  BUSY   |  n/a
     != 0    |      0       | data available    |   OK    |  lPageSize
     != 0    | <= lPageSize | data available    |   OK    |  Length
     != 0    | > lPageSize  | too few data      |  BUSY   |  n/a
  */

  lPageSize = (PduLengthType)(Dcm_InstanceContext.PagedBuffer.WriteIndex - Dcm_InstanceContext.PagedBuffer.ReadIndex); /* Calculate and return page size */

  if ((Length <= lPageSize) && (lPageSize != 0))
  {
    /* just update the size and the data pointer */
    PduInfo->SduDataPtr = &(Dcm_InstanceContext.PagedBuffer.BufferInfoPtr->BufferPtr[Dcm_InstanceContext.PagedBuffer.ReadIndex]);

    if (Length == 0)
    {
      /* use available page size */
      PduInfo->SduLength = lPageSize;
    }
    else
    {
      /* use requested data length */
      PduInfo->SduLength = Length;
    }

    Dcm_InstanceContext.PagedBuffer.ReadIndex += (Dcm_CfgNetBufferSizeMemType)(PduInfo->SduLength);
  }
  else
  {
    lResult = BUFREQ_E_BUSY;/* avoid coping data during defragmenting of the paged buffer */

    /* check if paged buffer update is possible */
    if (Dcm_InstanceContext.PagedBuffer.IsInUnderrun == FALSE)
    {
      Dcm_InstanceContext.PagedBuffer.IsInUnderrun = TRUE;
      Dcm_TskSetEvent(DCM_TSK_ID_PGDBUF, DCM_TSK_EV_PGDBUF_UPDATE_PAGE);/* re-activate page updater */
    } /* else - still waiting for the data */
  }

  return lResult;
}
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)                                                                                                  /* COV_DCM_SUPPORT_PARTIALLY TX tx xf */
# if(DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferCopyData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_PagedBufferCopyData(
                                                       P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info                                             /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                      ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) availableDataPtr)                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  BufReq_ReturnType  lResult = BUFREQ_OK;

  Dcm_DebugAssert((Dcm_InstanceContext.PagedBuffer.State != DCM_PAGEDBUFFER_STATE_INACTIVE), DCM_SID_COPYTXDATA, DCM_E_ILLEGAL_STATE)                /* COV_DCM_RTM_DEV_DEBUG XF */

  *availableDataPtr = (PduLengthType)(Dcm_InstanceContext.PagedBuffer.WriteIndex - Dcm_InstanceContext.PagedBuffer.ReadIndex); /* Calculate and return page size */

  /*
  +------------+------------+-----------+-------------------+-----------+------------------+----------------------+
  |  PageSize  | Comparison | SduLength | PagedBufferState  |  lResult  |  *AvailData      |         Action       |
  +------------+------------+-----------+-------------------+-----------+------------------+----------------------+
  |     0      |     ==     |     0     |  No data requested|    OK     |  PageSize        | UpdatePage + Defrag  |
  +------------+------------+-----------+-------------------+-----------+------------------+----------------------+
  |     0      |     ==     |     0     |  Data requested   |    OK     |  PageSize        | -                    |
  +------------+------------+-----------+-------------------+-----------+------------------+----------------------+
  |     !0     |     >      |     0     |  ANY              |    OK     |  PageSize        | -                    |
  +------------+------------+-----------+-------------------+-----------+------------------+----------------------+
  |     ANY    |     <      |    !0     |  No data requested|    BUSY   |  PageSize        | UpdatePage + Defrag  |
  +------------+------------+-----------+-------------------+-----------+------------------+----------------------+
  |     ANY    |     <      |    !0     |  Data requested   |    BUSY   |  PageSize        | -                    |
  +------------+------------+-----------+-------------------+-----------+------------------+----------------------+
  |     !0     |     >=     |    !0     |  No data requested|    OK     |PageSize-SduLength| CopyData             |
  +------------+------------+-----------+-------------------+-----------+------------------+----------------------+
  |     !0     |     >=     |    !0     |  Data requested   |    BUSY   |  PageSize        | -                    |
  +------------+------------+-----------+-------------------+-----------+------------------+----------------------+
  */
  if( (*availableDataPtr == 0u) /* no data at all */
    ||(*availableDataPtr < info->SduLength) ) /* real under-run */
  {
    if(info->SduLength != 0)
    {
      lResult = BUFREQ_E_BUSY;
    }/* else - just buffer size check */

    if( (Dcm_InstanceContext.PagedBuffer.IsInUnderrun == FALSE)
      &&(Dcm_InstanceContext.PagedBuffer.RemainingLen  != 0) )
    {
      Dcm_InstanceContext.PagedBuffer.IsInUnderrun = TRUE;
      Dcm_TskSetEvent(DCM_TSK_ID_PGDBUF, DCM_TSK_EV_PGDBUF_UPDATE_PAGE);/* re-activate page updater */
    }/* else - still waiting for the data */
  }
  else /* (lPageSize != 0) && (lPageSize >= info->SduLength) => <check buffer availability> */
  {
    if( (Dcm_InstanceContext.PagedBuffer.IsInUnderrun == TRUE) /* still waiting for data OR data is currently being written */
      &&(Dcm_InstanceContext.PagedBuffer.ReadIndex != 0) /* with needed defragmentation */
      &&(info->SduLength != 0) )/* no buffer availability check request */
    {
      lResult = BUFREQ_E_BUSY;/* avoid coping data during defragmentation of the paged buffer (i.e. in case of adaptive CopyTxData call with reducing SduLength each time, or when SduLength == 0, and immediately called again with SduLength != 0 */
    }
    else
    {
      *availableDataPtr -= info->SduLength; /* Update remained data part */
      /* Take the linear case always */
      Dcm_UtiMemCopy(&(Dcm_InstanceContext.PagedBuffer.BufferInfoPtr->BufferPtr[Dcm_InstanceContext.PagedBuffer.ReadIndex]), info->SduDataPtr, info->SduLength); /* PRQA S 3109 */ /* MD_MSR_14.3 */
      Dcm_InstanceContext.PagedBuffer.ReadIndex += (Dcm_CfgNetBufferSizeMemType)(info->SduLength);
    }
  }
  return lResult;
}
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_DidMgrInitMainResources()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DidMgrInitMainResources(void)
{
# if (DCM_DIDMGR_22_ACCESS_LOCK_ENABLED == STD_ON)
  Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadOnce = 0u;
# endif
# if (DCM_DIDMGR_2E_ACCESS_LOCK_ENABLED == STD_ON)
  Dcm_InstanceContext.DidMgr.DidRsrcContext.Write = 0u;
# endif
# if (DCM_DIDMGR_2F_ACCESS_LOCK_ENABLED == STD_ON)
  Dcm_InstanceContext.DidMgr.DidRsrcContext.Io = 0;
# endif
  /* readPeriodic and readDynamic have own cancellation mechanisms */
}

/**********************************************************************************************************************
 *  Dcm_DidMgrInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DidMgrInit(void)
{
# if (DCM_DIDMGR_2A_ACCESS_LOCK_ENABLED == STD_ON)
  Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadPeriodic = 0u;
# endif
# if (DCM_DIDMGR_2C_ACCESS_LOCK_ENABLED == STD_ON)
  Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadDynamic  = 0u;
# endif
  Dcm_DidMgrInitMainResources();

# if (DCM_DIDMGR_IODID_NBYTE_EXT_CEMR_ENABLED == STD_ON)
  /* Set default ReturnControlToEcu values to 0xFF...FF */
  Dcm_UtiMemSetUintX(Dcm_InstanceContext.DidMgr.IoControlCemrSessionMask, Dcm_MsgItemType, 0xFFu, DCM_DIDMGR_IODID_MAX_EXT_CEMR_SIZE_CONST);         /* PRQA S 3109 */ /* MD_MSR_14.3 */
# endif
}

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON) && \
     (DCM_DIDMGR_MSIG_OPTYPE_READ_GAP_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrGetGapRemainingLen()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgNetBufferSizeOptType, DCM_CODE) Dcm_DidMgrGetGapRemainingLen(
                                                                      Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                     ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext)                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_CfgNetBufferSizeOptType lGapLength;

  /* #10 If the gap is a the end of the DID: */
  if(pDidOpTypeContext->Base.NumSignals == 0u)
  {
    /* #20 Calculate the gap length by using the DID length information. */
    lGapLength = pDidInfoContext->DidLength
               - pDidOpTypeContext->OpType.Read.Progress;
  }
  else
  {
    /* #30 Otherwise calculate the gap length by using the signal offset. */
    lGapLength = pDidOpTypeContext->OpType.Read.Offset
               - pDidOpTypeContext->OpType.Read.Progress;
  }

  return lGapLength;
}
# endif

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrGetSignalLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_CfgNetBufferSizeOptType, DCM_CODE) Dcm_DidMgrGetSignalLength(
                                                                Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                                    /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                               ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext)                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_CfgNetBufferSizeOptType lSignalLength;

#  if (DCM_DIDMGR_MULTISIGNAL_ENABLED == STD_ON)
  /* #20 If the signal has a variable length: */
  if(pDidOpTypeContext->Base.SignalInfoList->Length == 0)
  {
    /* #30 Calculate the length of the signal. A signal with variable length is always the last signal of the DID. */
    lSignalLength = pDidInfoContext->DidLength - pDidOpTypeContext->OpType.Read.Offset;
  }
  else
  {
    /* #40 Otherwise return the signal length. */
    lSignalLength = pDidOpTypeContext->Base.SignalInfoList->Length;
  }
#  else
  DCM_IGNORE_UNREF_PARAM(pDidOpTypeContext);                                                                                                         /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Check for non-paged caller. If paged -> return length 1 (minimum length) */
  Dcm_DebugAssert((pDidInfoContext->Descriptor.DidSignalOpClassInfoPtr->FuncClass != DCM_DIDMGR_OPCLS_READ_PAGE), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE) /* COV_DCM_RTM_DEV_DEBUG XF */

  /* #50 Otherwise return the DID length. */
  /*
   * In multi signal case this code is not used.
   * In single signal -> linear DID will always fit Dcm_CfgNetBufferSizeOptType, paged DIDs MUST not use this function
   * at all.
   */
  lSignalLength = (Dcm_CfgNetBufferSizeOptType)pDidInfoContext->DidLength;
#  endif
  return lSignalLength;
}
# endif

# if (DCM_DIDMGR_OPTYPE_RANGE_ISAVAIL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrFilterDidRangeGap()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrFilterDidRangeGap(Dcm_OpStatusType            opStatus
                                                                      ,Dcm_DidMgrDidInfoContextPtrType pDidInfoContext)
{
  Std_ReturnType lStdResult = DCM_E_OK;

  /* #10 If the DID range supports gaps: */
  if(Dcm_DidMgrIsOpTypeSupported(pDidInfoContext->Descriptor.DidOpInfoPtr, DCM_DIDMGR_OPTYPE_RANGEISDIDAVAILABLE)) /* check for gaps */
  {
    Dcm_DidSupportedType isAvailable = DCM_DID_NOT_SUPPORTED;

    /* #20 Execute operation for evaluation gap match. */
    Dcm_DidMgrGetOpClassInfo(pDidInfoContext, DCM_DIDMGR_OPTYPE_RANGEISDIDAVAILABLE);
    Dcm_DebugAssert((pDidInfoContext->Descriptor.DidSignalOpClassInfoPtr->FuncClass == DCM_DIDMGR_OPCLS_ISDIDAVAILABLE), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)

    lStdResult = ((Dcm_DidMgrOpFuncRangeIsAvailDidType)pDidInfoContext->Descriptor.DidSignalOpClassInfoPtr->OpFunc)(pDidInfoContext->Did             /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                                                   ,opStatus
                                                                                                                   ,&isAvailable);
    /* #30 If operation needs more time (DCM_E_PENDING) or acknowledges that the DID is still valid: */
    if( ( (lStdResult == DCM_E_OK) && (isAvailable == DCM_DID_SUPPORTED) )
      ||(lStdResult == DCM_E_PENDING) )
    {
      /* #40 Return the current/final result: DCM_E_PENDING, DCM_E_OK */
    }
    else
    {
      /* #50 Otherwise: notify caller for range DID match but still DID invalid since in a gap. */
      lStdResult = DCM_E_LOOKUP_MATCH_FOUND;
    }
  }
  /* #60 Otherwise: all DIDs within that range are valid: return DCM_E_OK */
  return lStdResult;
}
# endif

# if (DCM_DIDMGR_RANGE_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrDidRangeLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrDidRangeLookUp(Dcm_OpStatusType            opStatus
                                                                    ,Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                                    ,Dcm_DidMgrOpOptType             didOp)
{
  Std_ReturnType lStdReturn;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_DIDMGR_OPTYPE_RANGE_ISAVAIL_ENABLED == STD_ON)
  lStdReturn = DCM_E_OK;

  /* #10 On the very first call: */
  if(opStatus == DCM_INITIAL)
#  endif
  {
    sint16_least lResult;

    lStdReturn = DCM_E_NOT_OK;

    /* #20 Try finding a range that encloses this DID. */
    lResult = Dcm_UtiLookUpRangeUint16(Dcm_CfgDidMgrDidRanges, pDidInfoContext->Did);
    /* #30 If a match found:  */
    if(lResult >= 0)
    {
      Dcm_DidMgrDidInfoPtrType lDidInfoPtr = &(Dcm_CfgDidMgrDidInfo[Dcm_CfgDidMgrRangeDidInfoRefs[lResult]]);

      /* #40 If the matched range supports the requested DID operation: */
      if(Dcm_DidMgrIsOpSupported(lDidInfoPtr, didOp))
      {
        /* #50 Prepare for positive final result; initialize DID context. */
        pDidInfoContext->Descriptor.DidInfoPtr = lDidInfoPtr;
        /* Set DID length. Later the concrete length will be stored here. Take the maximum length! */
        pDidInfoContext->DidLength = pDidInfoContext->Descriptor.DidInfoPtr->Length;
        /* Store DID operation information. */
        Dcm_DidMgrGetDidOpInfo(pDidInfoContext, didOp);

        lStdReturn = DCM_E_OK;
      }
      /* #60 Otherwise: Operation not supported -> DID not supported in context of the requested operation. */
    }
  }
  /* #65 Otherwise: keep current result: DCM_E_OK */

#  if (DCM_DIDMGR_OPTYPE_RANGE_ISAVAIL_ENABLED == STD_ON)
  /* #70 If DID match found: */
  if(lStdReturn == DCM_E_OK)
  {
    /* #80 Process potentially available DID range gaps, resp. re-call any pending operation. */
    lStdReturn = Dcm_DidMgrFilterDidRangeGap(opStatus, pDidInfoContext);
  }
  /* #90 Otherwise: return final result: DCM_E_NOT_OK, DCM_E_PENDING */
#  endif

  return lStdReturn;
}
# endif

# if (DCM_DIDMGR_OPTYPE_GETSCALINGINFO_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrGetScalingInfoSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrGetScalingInfoSignal(Dcm_OpStatusType             opStatus
                                                                        ,Dcm_MsgContextPtrType              pMsgContext                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                        ,Dcm_DidMgrSignalOpClassInfoPtrType opFuncInfo
                                                                        ,Dcm_NegativeResponseCodePtrType    errorCode)
{
  Std_ReturnType lStdResult;

  switch(opFuncInfo->FuncClass)
  {
#  if (DCM_DIDMGR_OPCLS_GETSCALINGINFO_SYNC_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_GETSCALING_SYNC:
    DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */
    lStdResult = ((Dcm_DidMgrOpFuncGetScalingInfoSyncType)opFuncInfo->OpFunc)(pMsgContext->resData                                                   /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                             ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_GETSCALINGINFO_ASYNC_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_GETSCALING_ASYNC:
    lStdResult = ((Dcm_DidMgrOpFuncGetScalingInfoAsyncType)opFuncInfo->OpFunc)(opStatus                                                              /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                              ,pMsgContext->resData
                                                                              ,errorCode);
    break;
#  endif
  default:
    DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */
    DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                             /* PRQA S 3112 */ /* MD_Dcm_3112 */
    DCM_IGNORE_UNREF_PARAM(opFuncInfo);                                                                                                              /* PRQA S 3112 */ /* MD_Dcm_3112 */

    *errorCode = DCM_E_PANIC_NRC;
    lStdResult = DCM_E_NOT_OK;
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG)                                                                                    /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

#  if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
  if(opStatus == DCM_CANCEL)
  {
    *errorCode = DCM_E_CONDITIONSNOTCORRECT;
    lStdResult = DCM_E_NOT_OK;
  }
#  endif

  /* Catch any RTE or unexpected specific errors */
  if( (lStdResult != DCM_E_OK)
#  if (DCM_DIDMGR_ASYNC_SCALINGDID_SUPPORT_ENABLED == STD_ON)
    &&(lStdResult != DCM_E_PENDING)
#  endif
    &&(lStdResult != DCM_E_NOT_OK)
    )
  {
    Dcm_DebugApiCheckRteAlways(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)
    *errorCode = DCM_E_PANIC_NRC;
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}
# endif

# if (DCM_DIDMGR_OPTYPE_GETSCALINGINFO_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrGetScalingInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrGetScalingInfo(Dcm_OpStatusType            opStatus
                                                                  ,Dcm_MsgContextPtrType             pMsgContext
                                                                  ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,Dcm_NegativeResponseCodePtrType   errorCode)
{
#  if (DCM_DIDMGR_MSIG_OPTYPE_GETSCALINGINFO_ENABLED == STD_ON)
  Std_ReturnType lStdResult;

  if(opStatus == DCM_INITIAL)
  {
    /* Initialize DID handler */
    Dcm_DidMgrOpTypeHandlerInit(pDidInfoContext, pDidOpTypeContext);
    pDidOpTypeContext->OpType.ReadScaling.LayoutList = &Dcm_DidMgrGetSignalScalingSize(pDidInfoContext->Descriptor.DidInfoPtr);
  }

  DCM_UTI_LOOP_FOR_EVER
  {
    lStdResult = Dcm_DidMgrGetScalingInfoSignal(opStatus
                                               ,pMsgContext
                                               ,pDidOpTypeContext->Base.SignalOpList
                                               ,errorCode);
    if(lStdResult != DCM_E_OK)
    {
      /* on pending or not OK -> just leave */
      break;/* try later */
    }

    /* move on to the next scaling signal and commit current response length. Use "LengthAll" to catch any buffer overflows in processing done */
    Dcm_DiagMoveOnResWithLengthAll(pMsgContext, *(pDidOpTypeContext->OpType.ReadScaling.LayoutList));                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */

    pDidOpTypeContext->Base.NumSignals--;
    if(pDidOpTypeContext->Base.NumSignals == 0u)
    {
      break;                                                                                                                                         /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
    }

    /* next signal */
    Dcm_UtiNextItemByPtr(pDidOpTypeContext->OpType.ReadScaling.LayoutList, 1u);
    Dcm_UtiNextItemByPtr(pDidOpTypeContext->Base.SignalOpList, 1u);

    opStatus = DCM_INITIAL;/* reset op status */
  }

  return lStdResult;
#  else
  DCM_IGNORE_UNREF_PARAM(pDidOpTypeContext);                                                                                                         /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if(opStatus == DCM_INITIAL)
  {
    /* register response length */
    Dcm_DiagUpdateResLength(pMsgContext, Dcm_DidMgrGetSignalScalingSize(pDidInfoContext->Descriptor.DidInfoPtr));                                    /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }

  return Dcm_DidMgrGetScalingInfoSignal(opStatus
                                       ,pMsgContext
                                       ,pDidInfoContext->Descriptor.DidSignalOpClassInfoPtr
                                       ,errorCode);

#  endif
}
# endif

# if (DCM_DIDMGR_OPTYPE_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrWriteSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrWriteSignal(Dcm_OpStatusType opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,Dcm_NegativeResponseCodePtrType errorCode)
{
  Dcm_DidMgrSignalOpClassInfoPtrType   opFuncInfo;
  Std_ReturnType lStdResult;

#  if (DCM_DIDMGR_MSIG_OPTYPE_WRITE_ENABLED == STD_ON)
  opFuncInfo = pDidOpTypeContext->Base.SignalOpList;
#  else
  opFuncInfo = pDidInfoContext->Descriptor.DidSignalOpClassInfoPtr;
#  endif

  switch(opFuncInfo->FuncClass)
  {
#  if (DCM_DIDMGR_OPCLS_WRITE_RANGE_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_WRITE_RANGE:
    lStdResult = ((Dcm_DidMgrOpFuncWriteDidRangeType)opFuncInfo->OpFunc)(pDidInfoContext->Did                                                        /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                        ,pMsgContext->reqData
                                                                        ,opStatus
                                                                        ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                        ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_WRITE_LEN_SYNC_NRES_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_WRITE_LEN_SYNC_NRES_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncWriteLenSyncNResErrorType)opFuncInfo->OpFunc)(pMsgContext->reqData                                                /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                                ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_WRITE_LEN_ASYNC_NRES_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_WRITE_LEN_ASYNC_NRES_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncWriteLenAsyncNResErrorType)opFuncInfo->OpFunc)(pMsgContext->reqData                                               /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                 ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                                 ,opStatus
                                                                                 ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_WRITE_NLEN_SYNC_NRES_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_WRITE_NLEN_SYNC_NRES_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncWriteNLenSyncNResErrorType)opFuncInfo->OpFunc)(pMsgContext->reqData                                               /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                 ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_WRITE_NLEN_ASYNC_NRES_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_WRITE_NLEN_ASYNC_NRES_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncWriteNLenAsyncNResErrorType)opFuncInfo->OpFunc)(pMsgContext->reqData                                              /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                  ,opStatus
                                                                                  ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_WRITE_LEN_SYNC_RES_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_WRITE_LEN_SYNC_RES_ERROR:
    {
      Dcm_DidMgrDidLengthType lDataLength = (Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen;
      lStdResult = ((Dcm_DidMgrOpFuncWriteLenSyncResErrorType)opFuncInfo->OpFunc)(pMsgContext->reqData                                               /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                 ,&lDataLength
                                                                                 ,pMsgContext->resData
                                                                                 ,errorCode);
      if(lStdResult == DCM_E_OK)
      {
        Dcm_DiagUpdateResLength(pMsgContext, lDataLength);
      }
    }
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_WRITE_NLEN_SYNC_NRES_NERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_WRITE_NLEN_SYNC_NRES_NERROR:
    lStdResult = ((Dcm_DidMgrOpFuncWriteNLenSyncNResNErrorType)opFuncInfo->OpFunc)(pMsgContext->reqData);                                            /* PRQA S 0313 */ /* MD_Dcm_0313 */

    if(lStdResult != DCM_E_OK)
    {
      *errorCode = DCM_E_GENERALPROGRAMMINGFAILURE; /* set write operation failed */
      lStdResult = DCM_E_NOT_OK;
    }
    break;
#  endif
  default:
    DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */
    DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                             /* PRQA S 3112 */ /* MD_Dcm_3112 */
    DCM_IGNORE_UNREF_PARAM(pDidInfoContext);                                                                                                         /* PRQA S 3112 */ /* MD_Dcm_3112 */
    DCM_IGNORE_UNREF_PARAM(pDidOpTypeContext);                                                                                                       /* PRQA S 3112 */ /* MD_Dcm_3112 */

    *errorCode = DCM_E_PANIC_NRC;
    lStdResult = DCM_E_NOT_OK;
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG)                                                                                    /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

#  if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
  if(opStatus == DCM_CANCEL)
  {
    *errorCode = DCM_E_CONDITIONSNOTCORRECT;
    lStdResult = DCM_E_NOT_OK;
  }
#  endif

  /* Catch any RTE or unexpected specific errors */
  if( (lStdResult != DCM_E_OK)
#  if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
    &&(lStdResult != DCM_E_PENDING)
#  endif
    &&(lStdResult != DCM_E_NOT_OK)
    )
  {
    Dcm_DebugApiCheckRteAlways(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)
    *errorCode = DCM_E_PANIC_NRC;
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}
# endif

# if (DCM_DIDMGR_OPTYPE_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrWrite()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrWrite(Dcm_OpStatusType opStatus
                                                               ,Dcm_MsgContextPtrType pMsgContext
                                                               ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                               ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                               ,Dcm_NegativeResponseCodePtrType errorCode)                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
#  if (DCM_DIDMGR_MSIG_OPTYPE_WRITE_ENABLED == STD_ON)
  Std_ReturnType lStdResult;

  if(opStatus == DCM_INITIAL)
  {
    /* Initialize DID handler */
    Dcm_DidMgrOpTypeHandlerInit(pDidInfoContext, pDidOpTypeContext);

    Dcm_DiagMoveOnReqWithLength(pMsgContext, pDidOpTypeContext->Base.SignalInfoList->Offset);                                                        /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }

  DCM_UTI_LOOP_FOR_EVER
  {
    lStdResult = Dcm_DidMgrWriteSignal(opStatus
                                     ,pMsgContext
                                     ,pDidInfoContext
                                     ,pDidOpTypeContext
                                     ,errorCode);
    if(lStdResult != DCM_E_OK)
    {
      /* on pending or not OK -> just leave */
      break;/* try later */
    }

    pDidOpTypeContext->Base.NumSignals--;
    if(pDidOpTypeContext->Base.NumSignals == 0u)
    {
      break;                                                                                                                                         /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
    }
    /* next signal */
    Dcm_UtiNextItemByPtr(pDidOpTypeContext->Base.SignalOpList, 1u);
    Dcm_UtiNextItemByPtr(pDidOpTypeContext->Base.SignalInfoList,1u);
    Dcm_DiagMoveOnReqWithLength(pMsgContext, pDidOpTypeContext->Base.SignalInfoList->Offset);                                                        /* PRQA S 3109 */ /* MD_MSR_14.3 */
    opStatus = DCM_INITIAL;/* reset op status */
  }

  return lStdResult;
#  else
  return Dcm_DidMgrWriteSignal(opStatus
                              ,pMsgContext
                              ,pDidInfoContext
                              ,pDidOpTypeContext
                              ,errorCode);
#  endif
}
# endif

# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControlRtrnCtrl2Ecu()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DidMgrIoControlRtrnCtrl2EcuSignal(
                                                                        Dcm_CfgDidMgrSignalOpClassRefOptType opInfoRef)
{
  Std_ReturnType                     lStdResult;
  Dcm_NegativeResponseCodeType       lNrc;
  Dcm_DidMgrSignalOpClassInfoPtrType opFuncInfo;

  Dcm_DebugAssert((Dcm_UtiGetNumElementsOfTable(Dcm_CfgDidMgrSignalOpClassInfo, Dcm_CfgDidMgrSignalOpClassInfoType) > opInfoRef), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE) /* COV_DCM_RTM_DEV_DEBUG XF */

  opFuncInfo = &Dcm_CfgDidMgrSignalOpClassInfo[opInfoRef];

  switch(opFuncInfo->FuncClass)
  {
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_NCEMR_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_NCEMR_ERROR  :
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncNCemrErrorType)opFuncInfo->OpFunc)(                                                                 /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                    &lNrc);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR8_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR8_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncCemr8ErrorType)opFuncInfo->OpFunc)(0xFFu                                                            /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                   ,&lNrc);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR16_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR16_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncCemr16ErrorType)opFuncInfo->OpFunc)(0xFFFFu                                                         /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                    ,&lNrc);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR32_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR32_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncCemr32ErrorType)opFuncInfo->OpFunc)(0xFFFFFFFFUL                                                    /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                    ,&lNrc);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMRN_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMRN_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncCemrNErrorType)opFuncInfo->OpFunc)(Dcm_InstanceContext.DidMgr.IoControlCemrSessionMask              /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                   ,&lNrc);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_NCEMR_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_NCEMR_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncNCemrErrorType)opFuncInfo->OpFunc)(DCM_INITIAL                                                     /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                    ,&lNrc);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR8_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR8_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncCemr8ErrorType)opFuncInfo->OpFunc)(DCM_INITIAL                                                     /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                    ,0xFFu
                                                                                    ,&lNrc);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR16_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR16_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncCemr16ErrorType)opFuncInfo->OpFunc)(DCM_INITIAL                                                    /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                     ,0xFFFFu
                                                                                     ,&lNrc);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR32_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR32_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncCemr32ErrorType)opFuncInfo->OpFunc)(DCM_INITIAL                                                    /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                     ,0xFFFFFFFFUL
                                                                                     ,&lNrc);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMRN_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMRN_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncCemrNErrorType)opFuncInfo->OpFunc)(DCM_INITIAL                                                     /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                    ,Dcm_InstanceContext.DidMgr.IoControlCemrSessionMask
                                                                                    ,&lNrc);
    break;
#  endif
  default:
    DCM_IGNORE_UNREF_PARAM(opInfoRef);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

    lStdResult = DCM_E_NOT_OK;
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG)                                                                                    /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }
  DCM_IGNORE_UNREF_PARAM(lStdResult);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */
  Dcm_DebugApiCheckRte(lStdResult != DCM_E_PENDING, DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)

  /*
  No need to handle application NRC since not used!
  Dcm_DiagHandleApplNrc(lStdResult, &lNrc, DCM_E_CONDITIONSNOTCORRECT);
  */
}                                                                                                                                                    /* PRQA S 6030 */ /* MD_MSR_STCYC */
# endif

# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControlRtrnCtrl2Ecu()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DidMgrIoControlRtrnCtrl2Ecu(Dcm_CfgDidMgrDidOpClassHandleOptType opInfoRef)
{
#  if (DCM_DIDMGR_MSIG_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
  Dcm_DebugAssert((Dcm_UtiGetNumElementsOfTable(Dcm_CfgDidMgrDidOpClassInfo, Dcm_CfgDidMgrDidOpClassInfoType) > (opInfoRef + 1)), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE) /* COV_DCM_RTM_DEV_DEBUG XF */
  {
    Dcm_CfgDidMgrSignalOpClassRefOptType lSignalIter;

    for(lSignalIter = Dcm_CfgDidMgrDidOpClassInfo[opInfoRef+ 0].OpClassRef; lSignalIter < Dcm_CfgDidMgrDidOpClassInfo[opInfoRef+ 1].OpClassRef; ++lSignalIter)
    {
      Dcm_DidMgrIoControlRtrnCtrl2EcuSignal(lSignalIter);
    }
  }
#  else
  Dcm_DidMgrIoControlRtrnCtrl2EcuSignal(Dcm_DidMgrGetOpClassRef(opInfoRef));
#  endif
}
# endif

# if (DCM_DIDMGR_OPTYPE_IO_ANY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControlSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrIoControlSignal(Dcm_OpStatusType           opStatus
                                                                  ,Dcm_MsgContextPtrType             pMsgContext                                     /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,Dcm_NegativeResponseCodePtrType   errorCode)
{
  Std_ReturnType lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType  opFuncInfo;

#  if (DCM_DIDMGR_MSIG_OPTYPE_IO_ANY_ENABLED == STD_ON)
  opFuncInfo = pDidOpTypeContext->Base.SignalOpList;
#  else
  opFuncInfo = pDidInfoContext->Descriptor.DidSignalOpClassInfoPtr;
#  endif

  switch(opFuncInfo->FuncClass)
  {
/* No CEMR */
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_NCEMR_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_NCEMR_ERROR  :

    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncNCemrErrorType)opFuncInfo->OpFunc)(                                                                 /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                    errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_NCEMR_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_NCEMR_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncNCemrErrorType)opFuncInfo->OpFunc)(opStatus                                                        /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                    ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_NCEMR_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_NCEMR_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenSyncNCemrErrorType)opFuncInfo->OpFunc)(pMsgContext->reqData                                              /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                  ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_NCEMR_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_NCEMR_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqLenSyncNCemrErrorType)opFuncInfo->OpFunc)(pMsgContext->reqData                                               /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                 ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                                 ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_NCEMR_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_NCEMR_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenASyncNCemrErrorType)opFuncInfo->OpFunc)(pMsgContext->reqData                                             /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                   ,opStatus
                                                                                   ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_NCEMR_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_NCEMR_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqLenASyncNCemrErrorType)opFuncInfo->OpFunc)(pMsgContext->reqData                                              /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                  ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                                  ,opStatus
                                                                                  ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_RES_NCEMR_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_RES_NCEMR_ERROR:
    {
      Dcm_DidMgrDidLengthType lDataLength = (Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen;
      lStdResult = ((Dcm_DidMgrOpFuncIoReqLenSyncResNCemrErrorType)opFuncInfo->OpFunc)(pMsgContext->reqData                                          /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                      ,&lDataLength
                                                                                      ,pMsgContext->resData
                                                                                      ,errorCode);
      if (lStdResult == DCM_E_OK)
      {
        Dcm_DiagUpdateResLength(pMsgContext, lDataLength);
      }
    }
    break;
#  endif
/* CEMR 8Bit */
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR8_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR8_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncCemr8ErrorType)opFuncInfo->OpFunc)((uint8)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord      /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                   ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR8_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR8_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncCemr8ErrorType)opFuncInfo->OpFunc)(opStatus                                                        /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                    ,(uint8)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                                    ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR8_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR8_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenSyncCemr8ErrorType)opFuncInfo->OpFunc)(pMsgContext->reqData                                              /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                  ,(uint8)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                                  ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR8_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR8_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqLenSyncCemr8ErrorType)opFuncInfo->OpFunc)(pMsgContext->reqData                                               /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                 ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                                 ,(uint8)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                                 ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR8_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR8_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenASyncCemr8ErrorType)opFuncInfo->OpFunc)(pMsgContext->reqData                                             /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                   ,opStatus
                                                                                   ,(uint8)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                                   ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR8_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR8_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqLenASyncCemr8ErrorType)opFuncInfo->OpFunc)(pMsgContext->reqData                                              /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                  ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                                  ,opStatus
                                                                                  ,(uint8)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                                  ,errorCode);
    break;
#  endif

/* CEMR 16Bit */
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR16_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR16_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncCemr16ErrorType)opFuncInfo->OpFunc)((uint16)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord    /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                    ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR16_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR16_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncCemr16ErrorType)opFuncInfo->OpFunc)(opStatus                                                       /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                     ,(uint16)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                                     ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR16_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR16_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenSyncCemr16ErrorType)opFuncInfo->OpFunc)(pMsgContext->reqData                                             /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                   ,(uint16)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                                   ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR16_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR16_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqLenSyncCemr16ErrorType)opFuncInfo->OpFunc)(pMsgContext->reqData                                              /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                  ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                                  ,(uint16)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                                  ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR16_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR16_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenASyncCemr16ErrorType)opFuncInfo->OpFunc)(pMsgContext->reqData                                            /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                    ,opStatus
                                                                                    ,(uint16)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                                    ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR16_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR16_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqLenASyncCemr16ErrorType)opFuncInfo->OpFunc)(pMsgContext->reqData                                             /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                   ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                                   ,opStatus
                                                                                   ,(uint16)pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                                   ,errorCode);
    break;
#  endif

/* CEMR 32Bit */
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR32_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMR32_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncCemr32ErrorType)opFuncInfo->OpFunc)(pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord            /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                    ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR32_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMR32_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncCemr32ErrorType)opFuncInfo->OpFunc)(opStatus                                                       /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                     ,pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                                     ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR32_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMR32_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenSyncCemr32ErrorType)opFuncInfo->OpFunc)(pMsgContext->reqData                                             /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                   ,pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                                   ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR32_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMR32_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqLenSyncCemr32ErrorType)opFuncInfo->OpFunc)(pMsgContext->reqData                                              /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                  ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                                  ,pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                                  ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR32_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMR32_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenASyncCemr32ErrorType)opFuncInfo->OpFunc)(pMsgContext->reqData                                            /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                    ,opStatus
                                                                                    ,pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                                    ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR32_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMR32_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqLenASyncCemr32ErrorType)opFuncInfo->OpFunc)(pMsgContext->reqData                                             /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                   ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                                   ,opStatus
                                                                                   ,pDidOpTypeContext->OpType.Io.ControlEnableMaskRecord
                                                                                   ,errorCode);
    break;
#  endif
/* CEMR NBit */
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMRN_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_SYNC_NRES_CEMRN_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenSyncCemrNErrorType)opFuncInfo->OpFunc)(pDidOpTypeContext->OpType.Io.EnableMaskPtr                       /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                   ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMRN_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_NREQ_NLEN_ASYNC_NRES_CEMRN_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoNReqNLenASyncCemrNErrorType)opFuncInfo->OpFunc)(opStatus                                                        /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                    ,pDidOpTypeContext->OpType.Io.EnableMaskPtr
                                                                                    ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMRN_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_SYNC_NRES_CEMRN_ERROR:
    DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */

    lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenSyncCemrNErrorType)opFuncInfo->OpFunc)(pMsgContext->reqData                                              /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                  ,pDidOpTypeContext->OpType.Io.EnableMaskPtr
                                                                                  ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMRN_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_NRES_CEMRN_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqLenSyncCemrNErrorType)opFuncInfo->OpFunc)(pMsgContext->reqData                                               /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                 ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                                 ,pDidOpTypeContext->OpType.Io.EnableMaskPtr
                                                                                 ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMRN_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_NLEN_ASYNC_NRES_CEMRN_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqNLenASyncCemrNErrorType)opFuncInfo->OpFunc)(pMsgContext->reqData                                             /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                   ,opStatus
                                                                                   ,pDidOpTypeContext->OpType.Io.EnableMaskPtr
                                                                                   ,errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMRN_ERROR_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_IO_REQ_LEN_ASYNC_NRES_CEMRN_ERROR:
    lStdResult = ((Dcm_DidMgrOpFuncIoReqLenASyncCemrNErrorType)opFuncInfo->OpFunc)(pMsgContext->reqData                                              /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                  ,(Dcm_DidMgrDidLengthType)pMsgContext->reqDataLen
                                                                                  ,opStatus
                                                                                  ,pDidOpTypeContext->OpType.Io.EnableMaskPtr
                                                                                  ,errorCode);
    break;
#  endif

  default:
    DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */
    DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                             /* PRQA S 3112 */ /* MD_Dcm_3112 */
    DCM_IGNORE_UNREF_PARAM(pDidInfoContext);                                                                                                         /* PRQA S 3112 */ /* MD_Dcm_3112 */
    DCM_IGNORE_UNREF_PARAM(pDidOpTypeContext);                                                                                                       /* PRQA S 3112 */ /* MD_Dcm_3112 */

    *errorCode = DCM_E_PANIC_NRC;
    lStdResult = DCM_E_NOT_OK;
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG)                                                                                    /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

#  if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
  if(opStatus == DCM_CANCEL)
  {
    *errorCode = DCM_E_CONDITIONSNOTCORRECT;
    lStdResult = DCM_E_NOT_OK;
  }
#  endif

  /* Catch any RTE or unexpected specific errors */
  if( (lStdResult != DCM_E_OK)
#  if (DCM_DIDMGR_ASYNC_IODID_SUPPORT_ENABLED == STD_ON)
    &&(lStdResult != DCM_E_PENDING)
#  endif
    &&(lStdResult != DCM_E_NOT_OK)
    )
  {
    Dcm_DebugApiCheckRteAlways(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)
    *errorCode = DCM_E_PANIC_NRC;
    lStdResult = DCM_E_NOT_OK;
  }

  Dcm_DiagHandleApplNrc(lStdResult, errorCode, DCM_E_CONDITIONSNOTCORRECT);                                                                          /* PRQA S 3109 */ /* MD_MSR_14.3 */

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6010, 6030 */ /* MD_MSR_STPTH, MD_MSR_STCYC */
# endif

# if (DCM_DIDMGR_OPTYPE_IO_ANY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControl()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrIoControl(Dcm_OpStatusType opStatus
                                                                   ,Dcm_MsgContextPtrType pMsgContext
                                                                   ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                                /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                   ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                   ,Dcm_NegativeResponseCodePtrType errorCode)
{
#  if (DCM_DIDMGR_MSIG_OPTYPE_IO_ANY_ENABLED == STD_ON)
  Std_ReturnType lStdResult;

  if(opStatus == DCM_INITIAL)
  {
    /* Initialize DID handler */
    Dcm_DidMgrOpTypeHandlerInit(pDidInfoContext, pDidOpTypeContext);

    Dcm_DiagMoveOnReqWithLength(pMsgContext, pDidOpTypeContext->Base.SignalInfoList->Offset);                                                        /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }

  DCM_UTI_LOOP_FOR_EVER
  {
    lStdResult = Dcm_DidMgrIoControlSignal(opStatus
                                         ,pMsgContext
                                         ,pDidInfoContext
                                         ,pDidOpTypeContext
                                         ,errorCode);
    if(lStdResult != DCM_E_OK)
    {
      /* on pending or not OK -> just leave */
      break;
    }

    pDidOpTypeContext->Base.NumSignals--;
    if(pDidOpTypeContext->Base.NumSignals == 0u)
    {
      break;                                                                                                                                         /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
    }
    /* next signal */
    Dcm_UtiNextItemByPtr(pDidOpTypeContext->Base.SignalOpList, 1u);
    Dcm_UtiNextItemByPtr(pDidOpTypeContext->Base.SignalInfoList,1u);
    Dcm_DiagMoveOnReqWithLength(pMsgContext, pDidOpTypeContext->Base.SignalInfoList->Offset);                                                        /* PRQA S 3109 */ /* MD_MSR_14.3 */

    opStatus = DCM_INITIAL;/* reset op status */
  }

  return lStdResult;
#  else
  DCM_IGNORE_UNREF_PARAM(pDidOpTypeContext);                                                                                                         /* PRQA S 3112 */ /* MD_Dcm_3112 */
  return Dcm_DidMgrIoControlSignal(opStatus
                                  ,pMsgContext
                                  ,pDidInfoContext
                                  ,pDidOpTypeContext
                                  ,errorCode);
#  endif
}
# endif

# if (DCM_DIDMGR_OPCLS_IO_ANY_WITH_INT_CEMR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrIoControlWithMask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrIoControlWithMask(Dcm_OpStatusType         opStatus
                                                                  ,Dcm_MsgContextPtrType             pMsgContext
                                                                  ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                  ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                  ,Dcm_NegativeResponseCodePtrType   errorCode)

{
  Std_ReturnType lStdResult;

  if(opStatus == DCM_INITIAL)
  {
    /* Initialize DID handler */
    Dcm_DidMgrOpTypeHandlerInit(pDidInfoContext, pDidOpTypeContext);

    pDidOpTypeContext->OpType.Io.OperExecuted= FALSE;
    pDidOpTypeContext->OpType.Io.SignalIter  = 0u;
    pDidOpTypeContext->OpType.Io.BitScanner  = 0x80u;

    Dcm_DiagMoveOnReqWithLength(pMsgContext, pDidOpTypeContext->Base.SignalInfoList->Offset);                                                        /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }

  DCM_UTI_LOOP_FOR_EVER
  {
    if((pDidOpTypeContext->OpType.Io.EnableMaskPtr[0] & pDidOpTypeContext->OpType.Io.BitScanner) != 0)
    {
      pDidOpTypeContext->OpType.Io.OperExecuted = TRUE;

      lStdResult = Dcm_DidMgrIoControlSignal(opStatus
                                            ,pMsgContext
                                            ,pDidInfoContext
                                            ,pDidOpTypeContext
                                            ,errorCode);
    }
    else
    {
      /* else - signal not allowed -> skip with ok */
      lStdResult = DCM_E_OK;
    }

    if(lStdResult != DCM_E_OK)
    {
      break;
    }

    pDidOpTypeContext->OpType.Io.SignalIter++;
    if(pDidOpTypeContext->OpType.Io.SignalIter >= pDidOpTypeContext->Base.NumSignals)
    {
      break;                                                                                                                                         /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
    }

    /* next signal */
    pDidOpTypeContext->OpType.Io.BitScanner >>= 1;
    if(pDidOpTypeContext->OpType.Io.BitScanner == 0)
    {
      pDidOpTypeContext->OpType.Io.BitScanner = 0x80u;
      Dcm_UtiNextItemByPtr(pDidOpTypeContext->OpType.Io.EnableMaskPtr,1);
    }
    Dcm_UtiNextItemByPtr(pDidOpTypeContext->Base.SignalOpList, 1u);
    Dcm_UtiNextItemByPtr(pDidOpTypeContext->Base.SignalInfoList,1u);
    Dcm_DiagMoveOnReqWithLength(pMsgContext, pDidOpTypeContext->Base.SignalInfoList->Offset);                                                        /* PRQA S 3109 */ /* MD_MSR_14.3 */
    opStatus = DCM_INITIAL;/* reset op status */
  }

  if(pDidOpTypeContext->OpType.Io.OperExecuted == FALSE)
  {
    /* the enable mask record did not enable any signal */
    *errorCode = DCM_E_REQUESTOUTOFRANGE;
    lStdResult = DCM_E_NOT_OK;
  }
  return lStdResult;
}
# endif

# if (DCM_DIDMGR_OPTYPE_READ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadSignal(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgType pData                                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_CfgNetBufferSizePtrType pAvailLen                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext                             /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,Dcm_NegativeResponseCodePtrType errorCode)
{
  Std_ReturnType lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType opFuncInfo;

#  if (DCM_DIDMGR_MSIG_OPTYPE_READ_ENABLED == STD_ON)
  opFuncInfo = pDidOpTypeContext->Base.SignalOpList;
#  else
  opFuncInfo = pDidInfoContext->Descriptor.DidSignalOpClassInfoPtr;
#  endif

  switch(opFuncInfo->FuncClass)
  {
#  if (DCM_DIDMGR_OPCLS_READ_RANGE_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_READ_RANGE:
    {
      Dcm_DidMgrDidLengthType lResLength = 0u;/* set just in case not set by application */
      /* #20 Call the appropriate application callback for that DID range signal. */
      lStdResult = ((Dcm_DidMgrOpFuncReadDidRangeType)opFuncInfo->OpFunc)(pDidInfoContext->Did                                                       /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                        ,pData
                                                                        ,opStatus
                                                                        ,&lResLength
                                                                        ,errorCode);
      if(lStdResult == DCM_E_OK)
      {
        /* Update final response length only in positive/final case */
#   if(DCM_DEV_ERROR_DETECT == STD_ON)
        if(lResLength > pDidInfoContext->DidLength)
        {
          lStdResult = DCM_E_NOT_OK;
          *errorCode = DCM_E_PANIC_NRC;
          Dcm_DebugReportError(DCM_SID_SVCPORT_DATASVCS_OP_READDIDRANGE, DCM_E_INTERFACE_BUFFER_OVERFLOW);
        }
        else
#   endif
        {
          pDidInfoContext->DidLength = lResLength;/* update current DID length */
        }
      }
      /*
       * Currently excluded from PAGED DID feature:
       * "*pAvailLen = Dcm_DidMgrGetSignalLength(pDidInfoContext, pDidOpTypeContext);"
       */
      break;
    }
#  endif
#  if (DCM_DIDMGR_OPCLS_READ_ASYNC_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_READ_ASYNC:
    /* #40 Call the appropriate application callback for that asynchronous signal. */
    lStdResult = ((Dcm_DidMgrOpFuncReadAsyncType)opFuncInfo->OpFunc)(opStatus                                                                        /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                    ,pData);
#   if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
    /* #50 Update the remaining available length. */
    *pAvailLen = Dcm_DidMgrGetSignalLength(pDidInfoContext, pDidOpTypeContext);
#   endif
    /* #55 Handle NRC here since no NRC can be passed by the application on this interface. */
    if(lStdResult == DCM_E_NOT_OK)
    {
      *errorCode = DCM_E_CONDITIONSNOTCORRECT;
    }
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_READ_SYNC_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_READ_SYNC:
    /* #70 Call the appropriate application callback for that synchronous signal. */
    lStdResult = ((Dcm_DidMgrOpFuncReadSyncType)opFuncInfo->OpFunc)(pData);                                                                          /* PRQA S 0313 */ /* MD_Dcm_0313 */
#   if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
    /* #80 Update the remaining available length. */
    *pAvailLen = Dcm_DidMgrGetSignalLength(pDidInfoContext, pDidOpTypeContext);
#   endif
    /* #85 Handle NRC here since no NRC can be passed by the application on this interface. */
    if(lStdResult == DCM_E_NOT_OK)
    {
      *errorCode = DCM_E_CONDITIONSNOTCORRECT;
    }
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_READ_PAGE:
    {
      Dcm_DidMgrDidLengthType lTmpAvailLen  = (Dcm_DidMgrDidLengthType)*pAvailLen; /* Needed in case pAvailLen is not derived from U16 type. */

      /* #100 Call the appropriate application callback for that paged signal. */
      lStdResult = ((Dcm_DidMgrOpFuncReadPagedDidType)opFuncInfo->OpFunc)(opStatus                                                                   /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                        ,pData
                                                                        ,&lTmpAvailLen);
      *pAvailLen = (Dcm_CfgNetBufferSizeOptType)lTmpAvailLen; /* Store again the returned value. */
      /* Handle NRC here since no NRC can be passed by the application on this interface */
      if(lStdResult == DCM_E_NOT_OK)
      {
        *errorCode = DCM_E_CONDITIONSNOTCORRECT;
      }
      break;
    }
#  endif
#  if (DCM_DIDMGR_OPCLS_READ_VID_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_READ_VID:
    {
      /* #120 Call the appropriate application callback for that VID signal. */
#   if (DCM_DCM_AR_VERSION < DCM_DCM_AR_VERSION_422)
      lStdResult = ((Dcm_DidMgrOpFuncReadVidType)opFuncInfo->OpFunc)(opStatus                                                                        /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                    ,pData);
#   else
      uint8 lResLength = (uint8)pDidInfoContext->DidLength;
#    if (DCM_DIDMGR_REPORT_NODIBYTE_ENABLED == STD_OFF)
      /* Did length does not contain NODI byte; application will provide NODI byte always so length must be incremented */
      lResLength++;
#    endif
      lStdResult = ((Dcm_DidMgrOpFuncReadVidType)opFuncInfo->OpFunc)(opStatus                                                                        /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                    ,pData
                                                                    ,&lResLength);
#   endif
      /* #125 Handle NRC here since no NRC can be passed by the application on this interface. */
      if (lStdResult == DCM_E_NOT_OK)
      {
        *errorCode = DCM_E_CONDITIONSNOTCORRECT;
      }
      else if(lStdResult == DCM_E_OK)
      {
        /* #130 If VID signal with dynmaic length supported (Autosar Version >= 4.2.2) */
#   if (DCM_DCM_AR_VERSION >= DCM_DCM_AR_VERSION_422)
        /* Update final response length only in positive/final case */
#    if(DCM_DEV_ERROR_DETECT == STD_ON)
        if(lResLength > pDidInfoContext->DidLength)
        {
          lStdResult = DCM_E_NOT_OK;
          *errorCode = DCM_E_PANIC_NRC;
          Dcm_DebugReportError(DCM_SID_SVCPORT_DATASVCS_OP_READVID, DCM_E_INTERFACE_BUFFER_OVERFLOW);
        }
        else
#    endif
        {
          /* Decrement length of signal if NODI byte reporting disabled */
#    if (DCM_DIDMGR_REPORT_NODIBYTE_ENABLED == STD_OFF)
          lResLength--;
#    endif
          pDidInfoContext->DidLength = lResLength;/* update current DID length */
        }
#   endif

        /* #140 Remove NODI byte from VID signal if NODI byte reporting disabled */
#   if (DCM_DIDMGR_REPORT_NODIBYTE_ENABLED == STD_OFF)
        {
          /* remove NODI byte */
          uint16_least lIter;
          DCM_UTI_LOOP_FOR_UP(lIter, 0, pDidInfoContext->DidLength)
          {
            pData[lIter] = pData[lIter+1];
          }
        }
#   endif
      }
      else
      {
        /* delegate */
      }

      break;
    }
#  endif
  default:
    DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */
    DCM_IGNORE_UNREF_PARAM(pData);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */
    DCM_IGNORE_UNREF_PARAM(pAvailLen);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
    DCM_IGNORE_UNREF_PARAM(pDidOpTypeContext);                                                                                                       /* PRQA S 3112 */ /* MD_Dcm_3112 */
    DCM_IGNORE_UNREF_PARAM(pDidInfoContext);                                                                                                         /* PRQA S 3112 */ /* MD_Dcm_3112 */

    *errorCode = DCM_E_PANIC_NRC;
    lStdResult = DCM_E_NOT_OK;
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG)                                                                                    /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

#  if (DCM_DIDMGR_CANCEL_OP_READ_ENABLED == STD_ON)
  if(opStatus == DCM_CANCEL)
  {
    *errorCode = DCM_E_CONDITIONSNOTCORRECT;
    lStdResult = DCM_E_NOT_OK;
  }
#  endif

  /* Catch any RTE or unexpected specific errors */
  if( (lStdResult != DCM_E_OK)
    &&(lStdResult != DCM_E_NOT_OK)
#  if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
    &&(lStdResult != DCM_E_PENDING)
#  endif
#  if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
    &&(lStdResult != DCM_E_BUFFERTOOLOW)
#  endif
#  if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
    &&(lStdResult != DCM_E_FORCE_RCRRP)
#  endif
    )
  {
    Dcm_DebugApiCheckRteAlways(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)
    *errorCode = DCM_E_PANIC_NRC;
    lStdResult = DCM_E_NOT_OK;
  }

  Dcm_DiagHandleApplNrc(lStdResult, errorCode, DCM_E_CONDITIONSNOTCORRECT);                                                                          /* PRQA S 3109 */ /* MD_MSR_14.3 */

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6010, 6030, 6060 */ /* MD_MSR_STPTH,  MD_MSR_STCYC,  MD_Dcm_Design_6060 */
# endif

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON) && \
     (DCM_DIDMGR_MSIG_OPTYPE_READ_GAP_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadGap()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadGap(Dcm_CfgNetBufferSizePtrType       pAvailLen
                                                                 ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                                  /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                 ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext)
{
  Std_ReturnType lStdResult;
  Dcm_CfgNetBufferSizeOptType lGapLength;

  lGapLength = Dcm_DidMgrGetGapRemainingLen(pDidInfoContext, pDidOpTypeContext);

  /* #10 If the gap doesn't fit into the available buffer space: */
  if(*pAvailLen < lGapLength)
  {
    /* #20 Use the full available length for writing the gap. */
    lStdResult = DCM_E_BUFFERTOOLOW;
  }
  else
  {
    /* #30 Otherwise commit the whole gap. */
    *pAvailLen = lGapLength;
    lStdResult = DCM_E_OK;
  }

  return lStdResult;
}
# endif

# if (DCM_DIDMGR_OPTYPE_READ_LENGTH_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadLengthSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadLengthSignal(Dcm_OpStatusType                opStatus
                                                                       ,Dcm_DidMgrDidInfoContextPtrType    pDidInfoContext                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                       ,Dcm_DidMgrDidLengthPtrType         pResLength
                                                                       ,Dcm_NegativeResponseCodePtrType    errorCode)
{
  Std_ReturnType lStdResult;
  Dcm_DidMgrSignalOpClassInfoPtrType opFuncInfo;

  /* Only one signal may have dynamic length - the last DID signal. */
  opFuncInfo = pDidInfoContext->Descriptor.DidSignalOpClassInfoPtr;

  switch(opFuncInfo->FuncClass)
  {
#  if (DCM_DIDMGR_OPCLS_READ_LENGTH_SYNC_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_READLENGTH_SYNC:
    DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */

    lStdResult = ((Dcm_DidMgrOpFuncReadLengthSyncType)opFuncInfo->OpFunc)(pResLength);                                                               /* PRQA S 0313 */ /* MD_Dcm_0313 */
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_READ_LENGTH_ASYNC_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_READLENGTH_ASYNC:
    lStdResult = ((Dcm_DidMgrOpFuncReadLengthAsyncType)opFuncInfo->OpFunc)(opStatus                                                                  /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                         ,pResLength);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_READ_LENGTH_RANGE_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_READLENGTH_RANGE:
    lStdResult = ((Dcm_DidMgrOpFuncReadDidRangeLengthType)opFuncInfo->OpFunc)(pDidInfoContext->Did                                                   /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                             ,opStatus
                                                                             ,pResLength);
    break;
#  endif
  default:
    DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */
    DCM_IGNORE_UNREF_PARAM(pResLength);                                                                                                              /* PRQA S 3112 */ /* MD_Dcm_3112 */
    DCM_IGNORE_UNREF_PARAM(opFuncInfo);                                                                                                              /* PRQA S 3112 */ /* MD_Dcm_3112 */

    *errorCode = DCM_E_PANIC_NRC;
    lStdResult = DCM_E_NOT_OK;
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG)                                                                                    /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

#  if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
  if(opStatus == DCM_CANCEL)
  {
    *errorCode = DCM_E_CONDITIONSNOTCORRECT;
    lStdResult = DCM_E_NOT_OK;
  }
#  endif

  if(lStdResult == DCM_E_NOT_OK)
  {
    *errorCode = DCM_E_CONDITIONSNOTCORRECT; /* return NRC CNC since no error code supported by the application API */
  }

  /* Catch any RTE or unexpected specific errors */
  if( (lStdResult != DCM_E_OK)
#  if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
    &&(lStdResult != DCM_E_PENDING)
#  endif
    &&(lStdResult != DCM_E_NOT_OK)
    )
  {
    Dcm_DebugApiCheckRteAlways(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)
    *errorCode = DCM_E_PANIC_NRC;
    lStdResult = DCM_E_NOT_OK;
  }

  /* No need of handling E_NOT_OK since the only setter is the DCM itself (no appl NRC).
  Dcm_DiagHandleApplNrc(lStdResult, errorCode, DCM_E_CONDITIONSNOTCORRECT);
  */
  return lStdResult;
}
# endif

# if (DCM_DIDMGR_OPTYPE_READ_CHECKCOND_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadCheckCondSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadCheckCondSignal(Dcm_OpStatusType              opStatus
                                                                        ,Dcm_DidMgrSignalOpClassInfoPtrType opFuncInfo                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                        ,Dcm_NegativeResponseCodePtrType    errorCode)
{
  Std_ReturnType lStdResult;

  switch(opFuncInfo->FuncClass)
  {
#  if (DCM_DIDMGR_OPCLS_READ_CHECKCOND_SYNC_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_READCHK_COND_SYNC:
    DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */

    lStdResult = ((Dcm_DidMgrOpFuncReadCheckCondSyncType)opFuncInfo->OpFunc)(                                                                        /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                             errorCode);
    break;
#  endif
#  if (DCM_DIDMGR_OPCLS_READ_CHECKCOND_ASYNC_ENABLED == STD_ON)
  case DCM_DIDMGR_OPCLS_READCHK_COND_ASYNC:
    lStdResult = ((Dcm_DidMgrOpFuncReadCheckCondAsyncType)opFuncInfo->OpFunc)(opStatus                                                               /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                             ,errorCode);
    break;
#  endif
  default:
    DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */
    DCM_IGNORE_UNREF_PARAM(opFuncInfo);                                                                                                              /* PRQA S 3112 */ /* MD_Dcm_3112 */

    *errorCode = DCM_E_PANIC_NRC;
    lStdResult = DCM_E_NOT_OK;
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG)                                                                                    /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

#  if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
  if(opStatus == DCM_CANCEL)
  {
    *errorCode = DCM_E_CONDITIONSNOTCORRECT;
    lStdResult = DCM_E_NOT_OK;
  }
#  endif

  /* Catch any RTE or unexpected specific errors */
  if( (lStdResult != DCM_E_OK)
#  if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
    &&(lStdResult != DCM_E_PENDING)
#  endif
    &&(lStdResult != DCM_E_NOT_OK)
    )
  {
    Dcm_DebugApiCheckRteAlways(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)
    *errorCode = DCM_E_PANIC_NRC;
    lStdResult = DCM_E_NOT_OK;
  }

  Dcm_DiagHandleApplNrc(lStdResult, errorCode, DCM_E_CONDITIONSNOTCORRECT);                                                                          /* PRQA S 3109 */ /* MD_MSR_14.3 */

  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_DidMgrFilterDidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrFilterDidLookUp(
                                                                       Dcm_DidMgrDidInfoContextPtrType pDidInfoContext                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                      ,Dcm_DidMgrOpOptType             didOp)
{
  Std_ReturnType lStdReturn = DCM_E_OK;

  DCM_IGNORE_UNREF_PARAM(pDidInfoContext);                                                                                                           /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(didOp);                                                                                                                     /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if(DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)
  if(Dcm_VarMgrIsEnabledInActiveVariants(pDidInfoContext->Descriptor.DidOpInfoPtr->ExecCondRef) == FALSE)
  {
    /* Not supported in current variant */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
# endif
  /* check session state */
  if(!Dcm_StateIsSupportedInSession(Dcm_StateGetPreconditionStates(pDidInfoContext->Descriptor.DidOpInfoPtr->ExecCondRef)))
  {
    /* Not supported in current session. */
    lStdReturn = DCM_E_NOT_OK;
  }
  else
  {
# if (DCM_SVC_22_OBD_CALIBRATION_ENABLED == STD_ON) && (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)
    /* perform this check only on supported DIDs ! */
    if( (pDidInfoContext->Did >= (uint16)0xF400u)
      &&(pDidInfoContext->Did <= (uint16)0xF8FFu)
#  if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
      /* Already filtered in the IsDidAvailable operation of the 0xF6xx DID range.
       * Note: Dcm_CfgSvc22SupportedIdMask does not contain any information for this DID range -> exclude from indexing.
       */
      && ((pDidInfoContext->Did & 0xF600u) != 0xF600u)
#  endif
      )
    {
      if(!Dcm_ObdIdMgrIsIdEnabled(Dcm_UtiGetLoByte(pDidInfoContext->Did), &Dcm_CfgSvc22SupportedIdMask[Dcm_CfgSvc22SupportedIdMaskOffset[Dcm_UtiGetHiByte(pDidInfoContext->Did)-(uint8)0xF4u]]))
      {
        /* OBD DID not enabled */
        lStdReturn = DCM_E_NOT_OK;
      }/* else - still enabled */
    }
    else/* not an (WWH-)OBD DID */
# endif
    {
# if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)
      if(didOp != DCM_DIDMGR_OP_DEFINE) /* isolate SID 0x2C - Define or Clear on not defined DDDID is always allowed! */
      {
        if(!Dcm_Svc2CIsDidDefined(pDidInfoContext->Descriptor.DidInfoPtr))
        {
          /* not yet defined for other operations than DEFINE */
          lStdReturn = DCM_E_NOT_OK;
        }/* else - defined for other operations */
      }
# endif
    }
  }

  return lStdReturn;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_DidMgrConcreteDidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrConcreteDidLookUp(
                                                                        Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                                       ,Dcm_DidMgrOpOptType didOp)
{
  Std_ReturnType lStdReturn = DCM_E_NOT_OK;
  /* Search for the DID in the database. */
  sint16_least  lResult = Dcm_UtiLookUpUint16(Dcm_CfgDidMgrDidLookUpTable, pDidInfoContext->Did);

  /* Check DID lookup result: */
  if(lResult >= 0)
  {
    /* If found, check if the DID supports the required operation: */
    if(Dcm_DidMgrIsOpSupported(&Dcm_CfgDidMgrDidInfo[lResult], didOp))
    {
      /* If operation supported, initialize DID information (set DID as supported). */
      pDidInfoContext->Descriptor.DidInfoPtr = &Dcm_CfgDidMgrDidInfo[lResult];
      /* Set DID length. Later the concrete length will be stored here. Take the maximum/concrete length! */
      pDidInfoContext->DidLength = pDidInfoContext->Descriptor.DidInfoPtr->Length;
      /* Initialize DID operation information.  */
      Dcm_DidMgrGetDidOpInfo(pDidInfoContext, didOp);
      lStdReturn = DCM_E_OK;
    }/* else - not a supported DID in the operation context! */
  }/* else - not a supported DID at all! */

  return lStdReturn;
}

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON) && \
     (DCM_DIDMGR_MSIG_OPTYPE_READ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadPagedMultiSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadPagedMultiSignal(Dcm_MsgType pData
                                                                  ,Dcm_CfgNetBufferSizePtrType pAvailLen
                                                                  ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                                  ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                                  ,Dcm_NegativeResponseCodePtrType errorCode)
{
  Std_ReturnType               lResult;
  Dcm_CfgNetBufferSizeOptType  lAvailLen;
  Dcm_CfgNetBufferSizeOptType  lSignalLen;
  boolean                      lHasNext;
#  if (DCM_DIDMGR_MSIG_OPTYPE_READ_GAP_ENABLED == STD_ON)
  boolean                      lIsGap;
#  endif

  lHasNext = TRUE;

  /* #10 For each signal of the DID: */
  do
  {
    /* #20 Calculate the remaining available length. */
    lAvailLen = (Dcm_CfgNetBufferSizeOptType)(*pAvailLen - pDidOpTypeContext->OpType.Read.PageProgress);

#  if (DCM_DIDMGR_MSIG_OPTYPE_READ_GAP_ENABLED == STD_ON)
    lIsGap = (boolean)
              ( (pDidOpTypeContext->OpType.Read.Progress < pDidOpTypeContext->OpType.Read.Offset)
              ||(pDidOpTypeContext->Base.NumSignals == 0u) );

    /* #30 Calculate the length of the signal. */
    if(lIsGap == TRUE)
    {
      lSignalLen = 1u; /* A gap signal is treated as a paged signal -> minimum one byte is required */
    }
    else
#  endif
    {
      lSignalLen = Dcm_DidMgrGetSignalLength(pDidInfoContext, pDidOpTypeContext);
    }

    /* #40 If there is not enough buffer space available for the signal: */
    if(lAvailLen < lSignalLen)
    {
      /* #50 Try it the next task cycle. */
      *pAvailLen = (Dcm_CfgNetBufferSizeMemType)pDidOpTypeContext->OpType.Read.PageProgress;

      pDidOpTypeContext->OpType.Read.PageProgress = 0u;
      lResult = DCM_E_BUFFERTOOLOW;
      lHasNext = FALSE;
    }
    else
    {
      /* #60 Read the signal data considering gaps. */
#  if (DCM_DIDMGR_MSIG_OPTYPE_READ_GAP_ENABLED == STD_ON)
      if(lIsGap == TRUE)
      {
        lResult = Dcm_DidMgrReadGap(&lAvailLen, pDidInfoContext, pDidOpTypeContext);
      }
      else
#  endif
      {
        lResult = Dcm_DidMgrReadSignal(pDidOpTypeContext->OpType.Read.OpStatus
                                      ,&(pData[pDidOpTypeContext->OpType.Read.PageProgress])
                                      ,&lAvailLen
                                      ,pDidInfoContext
                                      ,pDidOpTypeContext
                                      ,errorCode);
      }

#  if(DCM_DEV_ERROR_DETECT == STD_ON)
      if(((Dcm_CfgNetBufferSizeOptType)(pDidOpTypeContext->OpType.Read.PageProgress + lAvailLen)) > *pAvailLen)
      {
        lResult = DCM_E_NOT_OK;
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_BUFFER_OVERFLOW);
      }
#  endif
      switch(lResult)
      {
      case DCM_E_OK:
        pDidOpTypeContext->OpType.Read.OpStatus = DCM_INITIAL;
        pDidOpTypeContext->OpType.Read.Progress += (Dcm_CfgDidMgrOptimizedDidLengthType)lAvailLen;
        pDidOpTypeContext->OpType.Read.PageProgress += (Dcm_CfgNetBufferSizeMemType)lAvailLen;

        /* #80 If this was the last signal: */
        if(pDidOpTypeContext->OpType.Read.Progress == pDidInfoContext->DidLength)
        {
          /* Commit data */
          *pAvailLen = pDidOpTypeContext->OpType.Read.PageProgress;

          /* #90 All signals read without any errors. Finalize reading. */
          lHasNext = FALSE;
        }
        else
        {
#  if (DCM_DIDMGR_MSIG_OPTYPE_READ_GAP_ENABLED == STD_ON)
          /* #100 Otherwise, if there is no gap till next signal: */
          if(lIsGap == FALSE)
#  endif
          {
            --pDidOpTypeContext->Base.NumSignals;

#  if (DCM_DIDMGR_MSIG_OPTYPE_READ_GAP_ENABLED == STD_OFF)
            /*
             * Each signal handler shall always return the correct number of bytes, configured/registered by ReadDataLength.
             * This includes also the paged signals that shall always return DCM_E_OK only once all signal data is copied.
             * If the DET check below detects an error, it could only be caused by any paged signal handler called
             * for this DID.
             */
            Dcm_DebugAssert((pDidOpTypeContext->Base.NumSignals > 0), DCM_SID_INTERNAL, DCM_E_PARAM)                                                 /* COV_DCM_RTM_DEV_DEBUG XF */
#  endif

            /* #110 Go on with next signal. */
            Dcm_UtiNextItemByPtr(pDidOpTypeContext->Base.SignalOpList,  1u);
            Dcm_UtiNextItemByPtr(pDidOpTypeContext->Base.SignalInfoList, 1u);
            pDidOpTypeContext->OpType.Read.Offset += (Dcm_CfgDidMgrOptimizedDidLengthType)(pDidOpTypeContext->Base.SignalInfoList->Offset);
          }/* else - transmit gap */
        }
        break;
      case DCM_E_BUFFERTOOLOW:
        /* #120 If there is not enough buffer space available: */
        pDidOpTypeContext->OpType.Read.OpStatus = DCM_PENDING;
        /* Commit data */
        *pAvailLen = (Dcm_CfgNetBufferSizeOptType)(pDidOpTypeContext->OpType.Read.PageProgress + lAvailLen);
        pDidOpTypeContext->OpType.Read.Progress += (Dcm_CfgDidMgrOptimizedDidLengthType)lAvailLen;
        pDidOpTypeContext->OpType.Read.PageProgress = 0u;
        lHasNext = FALSE;
        break;
      default: /* DCM_E_PENDING, DCM_E_NOT_OK */
        /* In case DCM_E_NOT_OK -> No further call shall be made. */
        pDidOpTypeContext->OpType.Read.OpStatus = DCM_PENDING;
        lHasNext = FALSE;
        break;
      }
    }
  }
  while(lHasNext == TRUE);

  return lResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
/*lint -save -esym(961, 19.1)*/
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore*/
/* ----------------------------------------------
 ~&&&   Inlined function implementations (Level1)
---------------------------------------------- */
#define DCM_START_SEC_CODE
/*lint -save -esym(961, 19.1)*/
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore*/
/**********************************************************************************************************************
 *  Dcm_DiagAcceptNewRequest()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_DiagAcceptNewRequest(Dcm_NetTransportObjectPtrType pTranspObj)                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  boolean lResult = TRUE;
#if(DCM_DIAG_IGNORE_RESPONSE_SID_ENABLED == STD_ON)
  /* Ignore any on SID in range: [0x40, 0x7F]U[0xC0, 0xFF] will not be responded at all */
  if((pTranspObj->RxData[0] & 0x40u) != 0)
  {
    lResult = FALSE;
  }
  else
#endif
  /* Check for valid functional "0x3E 0x80" */
  if(pTranspObj->RxData[0] == 0x3Eu)
  {
    if( (pTranspObj->RxData[1] == 0x80u)
      &&(pTranspObj->RxLength == 2u) )
    {
      if(Dcm_PbCfgNetRxPduInfo[pTranspObj->RxPduId].IsFuncReq == TRUE)
      {
        /* do nothing - just restart S3 timer */
        lResult = FALSE;
      }
    }
  }
  else
  {
    /* nothing to do */
  }
  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_DiagOnTxFinished()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagOnTxFinished(Dcm_NetTransportObjectPtrType pTranspObj                                                  /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                          ,Dcm_NetTransmissionResultType txStatus)
{
  switch(pTranspObj->ResType)
  {
  case DCM_NET_TOBJ_RESTYPE_LINEAR:
  case DCM_NET_TOBJ_RESTYPE_PAGED:
    /* Do finalize main response */
    Dcm_DiagTxFinalization(pTranspObj, txStatus);                                                                                                    /* SBSW_DCM_INT_API_PARAM_PTR_PASSED_THROUGH */
    break;
  case DCM_NET_TOBJ_RESTYPE_RCRRP:
    Dcm_DiagRcrRpTxFinished(pTranspObj, txStatus);                                                                                                   /* SBSW_DCM_INT_API_PARAM_PTR_PASSED_THROUGH */
    break;
#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
  case DCM_NET_TOBJ_RESTYPE_UNSOLICITED:
    Dcm_DiagOnFblResTxFinished(pTranspObj, txStatus);                                                                                                /* SBSW_DCM_INT_API_PARAM_PTR_PASSED_THROUGH */
    break;
#endif
  default:                                                                                                                                           /* COV_DCM_RTM_UNREACHABLE XX */
    /* Unknown response type */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }
}
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc2AOnStateChanged()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2AOnStateChanged(void)
{
# if (DCM_DIDMGR_PERIODICDID_CLR_ON_STATE_CHG_ENABLED == STD_ON)
  if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries != 0u)
  {
    Dcm_NegativeResponseCodeType   lNrc;
    Dcm_Svc2ASchdItemHandleOptType schdIter;

    for(schdIter = 0; schdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++schdIter)
    {
      if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdIter].Rate < DCM_SVC2A_RATE_TYPE_STOPPED)/* is still an active entry? */
      {
        lNrc = Dcm_DidMgrDynDidStateCheck(&(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdIter].DidContext));
        if(lNrc != DCM_E_POSITIVERESPONSE)
        {
          Dcm_Svc2ASchdStopItemByHandle(schdIter);
        }
      }
    }
  }
# endif
}
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_DIDMGR_DYNDID_SRCITEM_CHECK_STATE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CStateCheckSrcItems()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_Svc2CStateCheckSrcItems(
                                                                         Dcm_CfgDidMgrDynDidHandleOptType dynDidHandle)
{
  Dcm_NegativeResponseCodeType     lNrc;
  Dcm_CfgDidMgrDynDidSrcItemIdxOptType currItem;
  Dcm_CfgDidMgrDynDidSrcItemIdxOptType endItem;

  currItem = Dcm_DidMgrGetDynDidSrcItemStartRef(dynDidHandle);
  endItem = (Dcm_CfgDidMgrDynDidHandleOptType)(currItem + Dcm_InstanceContext.Diag.Services.Svc2C.Items[dynDidHandle].Count);

  Dcm_DebugAssert((currItem < endItem), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                       /* COV_DCM_RTM_DEV_DEBUG XF */

  do
  {
#  if (DCM_SVC_2C_HYBRID_MODE_ENABLED == STD_ON)
    if(Dcm_Svc2CIsDidSrcItem(currItem))
#  endif
    {
#  if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
      lNrc = Dcm_StateCheck(Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[currItem].DidDescriptor.DidContext.Descriptor.DidOpInfoPtr->ExecCondRef, DCM_DIAG_CHK_LVL_PARAMETER);
#  endif
    }
#  if (DCM_SVC_2C_HYBRID_MODE_ENABLED == STD_ON)
    else
#  endif
    {
#  if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
      lNrc = Dcm_MemMgrCheckMemBlock(&(Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[currItem].MemDescriptor.MemBlock), DCM_MEMMGR_OP_READ);
#  endif
    }
    ++currItem;
  }
  while((lNrc == DCM_E_POSITIVERESPONSE)&&(currItem < endItem));

  return lNrc;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2COnStateChanged()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2COnStateChanged(void)
{
# if (DCM_DIDMGR_DYNDID_CLR_ON_STATE_CHG_ENABLED == STD_ON)
  /* clear all DynDID definitions not supported any more */
  Dcm_NegativeResponseCodeType lNrc;
  Dcm_CfgDidMgrDynDidHandleOptType dynDidIter;

  for(dynDidIter = 0; dynDidIter < DCM_NUM_DYNDIDS; ++dynDidIter)
  {
    if(Dcm_Svc2CIsDynDidDefined(dynDidIter))
    {
      lNrc = Dcm_StateCheck(Dcm_DidMgrGetDynDidReadExecPrecond(dynDidIter), DCM_DIAG_CHK_LVL_PARAMETER);
#  if (DCM_DIDMGR_DYNDID_SRCITEM_CHECK_STATE_ENABLED == STD_ON)
      if(lNrc == DCM_E_POSITIVERESPONSE)/* all DDDID conditions OK - check inside */
      {
        lNrc = Dcm_Svc2CStateCheckSrcItems(dynDidIter);
      }
#  endif
      if(lNrc != DCM_E_POSITIVERESPONSE)/* any condition not fulfilled? */
      {
        Dcm_Svc2CDefMgrClear((Dcm_CfgDidMgrDynDidHandleMemType)dynDidIter);
      }
    }/*else - DDDID not defined yet */
  }
# endif
}
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc2FOnStateChanged()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FOnStateChanged(void)
{
# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON) && \
     (DCM_DIDMGR_IODID_EXEC_PRECOND_LIMIT_ENABLED == STD_ON)
  if(Dcm_InstanceContext.Diag.Services.Svc2F.HasAnyActiveIoDid == TRUE)
  {
    P2VAR(Dcm_UtiBitSetBaseType, AUTOMATIC, DCM_VAR_NOINIT) pActiveIoDids = Dcm_InstanceContext.Diag.Services.Svc2F.ActiveIoDids;
    Dcm_CfgDidMgrDidOpClassHandleOptType opInfoRefPage = 0;
    Dcm_CfgDidMgrIoDidHandleOptType ioDidIter = Dcm_UtiGenericBitSetCalcSize(DCM_NUM_IODIDS_CONST);

    Dcm_InstanceContext.Diag.Services.Svc2F.HasAnyActiveIoDid = FALSE; /* Assume all IODIDs will be deactivated */

    for(; (ioDidIter != 0u); --ioDidIter)
    {
      Dcm_UtiBitSetBaseType lActiveIoDids = *pActiveIoDids;
      Dcm_UtiBitSetBaseType lActiveIoDidScanner = 0x01u;
      Dcm_CfgDidMgrDidOpClassHandleOptType opInfoRef = opInfoRefPage;

      DCM_UTI_BIT_SCAN_LOOP(lActiveIoDids)
      {
        if((*pActiveIoDids & lActiveIoDidScanner) != 0)
        {
          Dcm_NegativeResponseCodeType lNrc;

          lNrc = Dcm_DidMgrStaticDidStateCheck(Dcm_DidMgrGetCtrlOpExecCondRef(opInfoRef));
          if(lNrc != DCM_E_POSITIVERESPONSE)
          {
            Dcm_UtiBitOpClr(Dcm_UtiBitSetBaseType, *pActiveIoDids, lActiveIoDidScanner);                                                             /* PRQA S 0290 */ /* MD_Dcm_BitNegation_0290 */
            Dcm_DidMgrIoControlRtrnCtrl2Ecu(Dcm_DidMgrGetCtrlOpInfoRef(opInfoRef));
          }
        }

        lActiveIoDidScanner<<=1;
        ++opInfoRef;
      }

      /* If still any IODID active in this row: */
      if(*pActiveIoDids != 0)
      {
        /* Update IODID activity statistics. */
        Dcm_InstanceContext.Diag.Services.Svc2F.HasAnyActiveIoDid = TRUE;
      }

      Dcm_UtiNextItemByPtr(pActiveIoDids, 1u);
      opInfoRefPage += (Dcm_CfgDidMgrDidOpClassHandleOptType)Dcm_UtiGetNumBitsOfXintType(Dcm_UtiBitSetBaseType);/* next bunch of IoDids */
    }
  }
# endif
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
/*lint -save -esym(961, 19.1)*/
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore*/
/* ----------------------------------------------
 ~&&&   Inlined function implementations
---------------------------------------------- */
#define DCM_START_SEC_CODE
/*lint -save -esym(961, 19.1)*/
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore*/
#if (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_MemMgrInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_MemMgrInit(void)
{
# if (DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
  Dcm_InstanceContext.MemMgr.LockedByClient = DCM_MEMMGR_ACCESS_NONE;
# endif
}
#endif /* (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
# if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgr_F6XX_ReadDidData_SupportedId()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgr_F6XX_ReadDidData_SupportedId(uint8 ObdMID
                                                                                         ,Dcm_MsgType Data
                                                                                         ,Dcm_DidMgrDidLengthPtrType DataLength
                                                                                         ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;
  uint32 lObdMidAvailMask;

  /* #10 If request of MID value from Dem is successful */
  if (Dem_DcmGetAvailableOBDMIDs(ObdMID, &lObdMidAvailMask) == E_OK)
  {
    *DataLength = 4u;

    /* #80 Copy MID and MID value to data buffer */
    lStdResult = Dcm_ObdIdMgrReadSupportedId(lObdMidAvailMask, Data);
  }
  else
  {
    /* #30 Otherwise return negative response */
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}
# endif

# if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgr_F6XX_ReadDidData_DataId()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgr_F6XX_ReadDidData_DataId(uint8 ObdMID
                                                                                    ,Dcm_MsgType Data
                                                                                    ,Dcm_DidMgrDidLengthPtrType DataLength
                                                                                    ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult = DCM_E_OK;
  uint8 lNumOfTIDs;

  /* #10 Request number of TIDs for DID from Dem */
  if (Dem_DcmGetNumTIDsOfOBDMID(ObdMID, &lNumOfTIDs) == E_OK)
  {
    /* #20 Request is successful */
    uint8 lTidIter;
    uint16 lTestValue;
    uint16 lTestValuMin;
    uint16 lTestValueMax;

    *DataLength = lNumOfTIDs * 8;

    /* #30 Request Test Result of each TID from Dem */
    for (lTidIter = 0; lTidIter < lNumOfTIDs; lTidIter++)
    {
      if (Dem_DcmGetDTRData(ObdMID, lTidIter, &Data[0], &Data[1], &lTestValue, &lTestValuMin, &lTestValueMax) == E_OK)
      {
        /* #40 If request is successful for a TID */
        /* #50 Copy response data to data buffer */

        Data[2] = Dcm_UtiGetHiByte(lTestValue);
        Data[3] = Dcm_UtiGetLoByte(lTestValue);

        Data[4] = Dcm_UtiGetHiByte(lTestValuMin);
        Data[5] = Dcm_UtiGetLoByte(lTestValuMin);

        Data[6] = Dcm_UtiGetHiByte(lTestValueMax);
        Data[7] = Dcm_UtiGetLoByte(lTestValueMax);

        /* next block */
        Data = &Data[8];
      }
      else
      {
        /* #60 Otherwise return negative response */
        *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
        lStdResult = DCM_E_NOT_OK;
        break;
      }
    }
  }
  else
  {
    /* #70 Otherwise return negative response */
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
    lStdResult = DCM_E_NOT_OK;
  }

  return lStdResult;
}
# endif
#endif /* (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)                                                                                                  /* COV_DCM_UNSUPPORTED XF */
# if (DCM_UTI_NVM_READ_ENABLED  == STD_ON) || \
     (DCM_UTI_NVM_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_UtiNvMGetErrorStatus()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_UtiArEnvNvMGetErrorStatus(uint16 blockId
                                                         ,P2VAR(NvM_RequestResultType, AUTOMATIC, AUTOMATIC) nvmStatus)
{
  NvM_GetErrorStatus(blockId, nvmStatus);
  return E_OK;
}
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_NetCommon()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetCommon(void)
{
#if(DCM_NET_MULTI_TRANSP_OBJ_ENABLED == STD_ON)
  Dcm_SingletonContext.Network.NumActiveConnections = 0u;
#endif
#if(DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)                                                                                                        /* COV_DCM_UNSUPPORTED XF */
  Dcm_SingletonContext.Network.ActiveProtocol = DCM_NET_INVALID_PROTID;
#endif
  Dcm_SingletonContext.Network.ActiveDiagnostic = DCM_NET_COMM_ACTIVE;
#if (DCM_NET_RX_BLOCKING_ENABLED == STD_ON)
  Dcm_SingletonContext.Network.RxAllowed = TRUE;
#endif
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
  Dcm_SingletonContext.Network.KeepAlive = FALSE;
#endif
}

/**********************************************************************************************************************
 *  Dcm_NetComMInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetComMInit(void)
{
  DCM_NETCHNL_COMM_ITER_DEF
  DCM_NETCHNL_COMM_LOOP_FOR_UP
  {
    Dcm_PbRamNetComMContext[DCM_NETCHNL_COMM_ITER_VALUE].ComState = DCM_NET_COMM_STATE_RX_DIS_TX_DIS;
    Dcm_PbRamNetComMContext[DCM_NETCHNL_COMM_ITER_VALUE].RegisteredNetworks = 0u;
  }
}

/**********************************************************************************************************************
 *  Dcm_NetBufferInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetBufferInit(void)
{
  DCM_NETBUF_ITER_DEF
  DCM_NETBUF_LOOP_FOR_UP
  {
    Dcm_PbRamNetBufferContext[DCM_NETBUF_ITER_VALUE].IsInUseCnt = 0u;
  }
}

/**********************************************************************************************************************
 *  Dcm_NetConnectionInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetConnectionInit(void)
{
#if (DCM_NET_TRANSP_OBJ_DYN_ALLOC_ENABLED == STD_ON)
  DCM_NETCONNID_ITER_DEF
  DCM_NETCONNID_LOOP_FOR_UP
  {
    Dcm_PbRamNetConnId2TObjMap[DCM_NETCONNID_ITER_VALUE] = DCM_NET_INVALID_TOBJID;
  }
#endif
}

/**********************************************************************************************************************
 *  Dcm_NetTranspObjInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTranspObjInit(void)
{
  DCM_NETTOBJ_ITER_DEF
  DCM_NETTOBJ_LOOP_FOR_UP
  {
    Dcm_PbRamNetTransportObject[DCM_NETTOBJ_ITER_VALUE].ResType = DCM_NET_TOBJ_RESTYPE_NONE;
    Dcm_PbRamNetTransportObject[DCM_NETTOBJ_ITER_VALUE].State = DCM_NET_TOBJ_STATE_FREE;
    Dcm_PbRamNetTransportObject[DCM_NETTOBJ_ITER_VALUE].Flags = DCM_NET_TOBJ_FLAG_NONE;
    Dcm_PbRamNetTransportObject[DCM_NETTOBJ_ITER_VALUE].AddBuffer[0] = 0x7Fu;/* always used for negative responses */
    Dcm_PbRamNetTransportObject[DCM_NETTOBJ_ITER_VALUE].Handle = (Dcm_CfgNetTObjHandleMemType)DCM_NETTOBJ_ITER_VALUE;
  }
}

/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgInit(void)
{
#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
  /* Initialize periodic transmission manager state machine */
  Dcm_NetPeriodicMsgResetConnection();
  /* Dcm_NetPeriodicMsgResetMsgCounter(); will be reset at scheduler activation */
  Dcm_NetPeriodicMsgResetMsgHdl();
  {
    DCM_NET_PTXOBJ_ITER_DEF

    DCM_NET_PTXOBJ_LOOP_FOR_UP_GEN
    {
      /* Initialize the transport object */
# if(DCM_NET_PTXOBJ_SOFT_TIMER_ENABLED == STD_ON)
      Dcm_PbRamNetPeriodicTxObject[DCM_NET_PTXOBJ_ITER_VALUE].Timer = 0u;
# endif
    Dcm_PbRamNetPeriodicTxObject[DCM_NET_PTXOBJ_ITER_VALUE].IsReserved = FALSE;
    Dcm_PbRamNetPeriodicTxObject[DCM_NET_PTXOBJ_ITER_VALUE].TxPduInfo.SduDataPtr = Dcm_PbRamNetPeriodicTxObject[DCM_NET_PTXOBJ_ITER_VALUE].TxBuffer;
    }
  }
#endif
}

/**********************************************************************************************************************
 *  Dcm_NetInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetInit(void)
{
  /* #10 First initialize common variables. */
  Dcm_NetCommon();
  /* #20 Now initialize all remaining network related sub-elements. The order of execution shall not be relevant. */
  Dcm_NetComMInit();
  Dcm_NetBufferInit();
  Dcm_NetConnectionInit();
  Dcm_NetTranspObjInit();
  Dcm_NetPeriodicMsgInit();
}

/**********************************************************************************************************************
 *  Dcm_NetComposeAddNegResponse()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetComposeAddNegResponse(Dcm_NetTransportObjectPtrType pTranspObj                                          /* COV_DCM_RTM_NO_RCR_RP_TX */
                                                                  ,Dcm_NetResponseType resType
                                                                  ,Dcm_NegativeResponseCodeType nrc)
{
  pTranspObj->State = DCM_NET_TOBJ_STATE_PREPTX;
  pTranspObj->AddBuffer[2] = nrc; /* NRC = nrc, 0x7F and SID are already copied! */
  pTranspObj->BuffInfo.SduDataPtr = pTranspObj->AddBuffer; /* use the temp buffer to free the main buffer now */
  pTranspObj->BuffInfo.SduLength  = 3u;
  pTranspObj->ResType = resType;
}

#if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)                                                                                                 /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetOnRequestDetection()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetOnRequestDetection(DCM_NETCONNID_PARAMDEF_ONLY)
{
  Dcm_CfgNetTObjHandleMemType tObjHdl;

  /* #10 Retrieve the transport object handle from the given connection. */
  tObjHdl = Dcm_NetGetTranspObjIdForConnection(DCM_NETCONNID_PARAM_VALUE);

# if(DCM_NET_MULTI_CONNECT_ENABLED == STD_ON)
  /* #20 Check whether a transport object is mapped by the handle. */
  if(tObjHdl < DCM_NET_INVALID_TOBJID)
# endif
  {
    /* #30 Retrieve the transport object from the handle. */
    Dcm_NetTransportObjectPtrType pTranspObj = Dcm_NetGetTranspObjByHandle(tObjHdl);

    /* #40 Enter critical section (Reason: the transport object may not be modified from outside). */
    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
    BEGIN CRITICAL SECTION
    *=================================*/

    /* #50 Check whether the connection is free. */
    if(pTranspObj->State != DCM_NET_TOBJ_STATE_FREE)
    {
# if (DCM_NET_SUPPRESS_ON_FUNC_REQ_ENABLED == STD_ON)
      /* #60 Check if suppression of responses on functional addressed requests is enabled. */
      if( (Dcm_NetIsPropertieSet(pTranspObj, DCM_NET_CONN_PROP_TX_ON_FUNC_RX))
        &&(Dcm_PbCfgNetRxPduInfo[pTranspObj->RxPduId].IsFuncReq == TRUE) )
      {
        /*
         * #70 Interruption of functional addressed request is not necessary because response will already be
         * suppressed.
         */
      }
      /* #80 Otherwise, interrupt ongoing service processing. */
      else
# endif
      {
        /* #90 If a new request is being received: */
        if(pTranspObj->State == DCM_NET_TOBJ_STATE_ONRX)
        {
          /* #100 Isolate this connection. */
          pTranspObj->Flags |= DCM_NET_TOBJ_FLAG_CANCELED;

          /* #110 Terminate the ongoing reception immediately. */
          (void)Dcm_NetArEnvPduRCancelReceive(pTranspObj->RxPduId);
        }
        /* #120 Otherwise, let the task cancel any pending jobs. */
        else
        {
          Dcm_TskSetEvent(DCM_TSK_ID_NET_TA_MONITOR, Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, pTranspObj->Handle));
        }
      }
    }/* else - nothing to interrupt */

    /*=================================*
    END CRITICAL SECTION
    *=================================*/
    /* #130 Leave critical section. */
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }/* else - no request in progress or different tester -> ignore */
}
#endif

#if(DCM_NET_PROTOCOL_SWITCH_NOTIFICATION_ENABLED == STD_ON)                                                                                          /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetExecStartProtocolOp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_NetExecStartProtocolOp(Dcm_ProtocolType newProtocol)
{
  boolean lResult = TRUE;
  P2CONST(Dcm_CfgNetProtocolNotificationInfoType, AUTOMATIC, DCM_CONST) notifList = Dcm_CfgNetProtocolNotificationInfo;
  while(notifList->StartFunc != NULL_PTR)
  {
    if(notifList->StartFunc(newProtocol) != DCM_E_OK)
    {
      lResult = FALSE;
      break;
    }
    Dcm_UtiNextItemByPtr(notifList,1u);/* take next function */
  }
  return lResult;
}
#endif

#if (DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)                                                                                                       /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetProcessStartProtocol()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetProcessStartProtocol(Dcm_NetTransportObjectPtrType pTranspObj )
{
# if(DCM_NET_PROTOCOL_SWITCH_NOTIFICATION_ENABLED == STD_ON)
  boolean startProtocolAllowed;

  startProtocolAllowed = Dcm_NetExecStartProtocolOp(Dcm_PbCfgNetProtocolInfo[Dcm_NetGetProtIdOfTranspObj(pTranspObj)].Id);
  if(startProtocolAllowed == FALSE)
  {
    /* Neg response 0x22 */
    Dcm_NetComposeAddNegResponse(pTranspObj
                                ,DCM_NET_TOBJ_RESTYPE_SIMPLE
                                ,DCM_E_CONDITIONSNOTCORRECT);
    Dcm_NetBufferRelease(Dcm_NetTranspObjGetBufferHandleValue(pTranspObj));   /* the buffer is free now */
    Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND);
  }
  else
# endif
  {
    if(Dcm_NetGetProtIdOfActiveProtocol() < DCM_NET_INVALID_PROTID)
    {
# if (DCM_NET_PROTOCOL_PRIORITISATION_ENABLED == STD_ON)
      Dcm_DiagCancelProcessing();
# endif
      /* According to AR DCM SWS the session switch is executed at start protocol, not at stop! */
      Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_INT_SET2DEF);
    }/* else - no protocol enabled -> no need to reset anything */

    Dcm_SingletonContext.Network.ActiveProtocol = Dcm_NetGetProtIdOfTranspObj(pTranspObj);/* set new active protocol */

    /* Update P2 timings at once. */
    Dcm_DiagSetP2Timings(0, Dcm_SingletonContext.Network.ActiveProtocol);

    Dcm_DiagRxIndication(pTranspObj);
  }
}
#endif

#if (DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)                                                                                                       /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetRxPrioritisation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetRxPrioritisation(Dcm_TskTaskEvOptType ev
                                                             ,Dcm_TskTaskEvPtrType pPostEv)                                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
# if (DCM_NET_PROTOCOL_PRIORITISATION_ENABLED == STD_ON)
  uint16 lMaxPrio = 0x100u;/* lower than the lowest configurable priority (256 > 255) */
# endif
  Dcm_TskTaskEvOptType lBusyEvents = 0u;
  DCM_NETTOBJ_CNTR_DEF
  DCM_NETTOBJ_CNTR_TYPE lTranspObjWinnerId = DCM_NET_INVALID_TOBJID;

  DCM_IGNORE_UNREF_PARAM(pPostEv);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* one pass scanner and marker */
  DCM_NETTOBJ_CNTR_INIT

  DCM_TSK_EVENT_SCAN_LOOP(ev)
  {
    /* scan all arrived transport objects */
    if(Dcm_TskIsLocalEventSet(ev, 0x01u)) /* start scan from the LSB since TObjects are allocated by reversed iteration and thus -> first allocated (last checked here) will be the winner */
    {
# if (DCM_NET_PROTOCOL_PRIORITISATION_ENABLED == STD_ON)
      uint8 tmpProtPrio = Dcm_NetGetProtObjOfTranspObj(Dcm_NetGetTranspObjByHandle(DCM_NETTOBJ_CNTR_VALUE))->Priority;

      /* Higher priority */
      if(lMaxPrio <= tmpProtPrio)
      {
        /* Lower priority than current request/pending response */
        lBusyEvents |= Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvOptType, DCM_NETTOBJ_CNTR_VALUE);
      }
      else
# endif
      {
        if(lTranspObjWinnerId < DCM_NET_INVALID_TOBJID)
        {
          /* Mark busy for the last winner */
          lBusyEvents |= Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvOptType, lTranspObjWinnerId);
        }
# if (DCM_NET_PROTOCOL_PRIORITISATION_ENABLED == STD_ON)
        /* Update maximum priority */
        lMaxPrio = tmpProtPrio;
# endif
        /* potential winner found */
        lTranspObjWinnerId = DCM_NETTOBJ_CNTR_VALUE;
      }
    }
    DCM_NETTOBJ_CNTR_NEXT
  }

  /* There shall be always a winner! */
  if(lTranspObjWinnerId < DCM_NET_INVALID_TOBJID)
  {
    Dcm_NetTransportObjectPtrType pTranspObj = Dcm_NetGetTranspObjByHandle(lTranspObjWinnerId);
    if(Dcm_NetGetProtIdOfActiveProtocol() != Dcm_NetGetProtIdOfTranspObj(pTranspObj))   /*lint !e661 There is always a winner (lTranspObjWinnerId valid value) since this task gets active only on a request! */ /* the winner is a different protocol as the old one -> interrupt the old protocol */
    {
      if( (Dcm_NetGetProtIdOfActiveProtocol() >= DCM_NET_INVALID_PROTID) /* very first protocol activation - start the protocol/send busy responses */
# if (DCM_NET_PROTOCOL_PRIORITISATION_ENABLED == STD_ON)
        ||(Dcm_PbCfgNetProtocolInfo[Dcm_NetGetProtIdOfTranspObj(pTranspObj)].Priority < Dcm_PbCfgNetProtocolInfo[Dcm_NetGetProtIdOfActiveProtocol()].Priority) /* new one is higher priority */
# endif
        ||( (((DCM_DIAG_QUEUE_FLAG_IS_ACTIVE | DCM_DIAG_QUEUE_FLAG_IS_WAITING) & Dcm_InstanceContext.Diag.QueuedSet.Flags) == 0 )  /* if idle or post-processing (considered for back-to-back requests) ... */
          &&((DCM_STATE_VALUE_SESSION_INIT & Dcm_StateGetPendingSession()) != 0) )/* ... still default session - continue with new request */
        )  /*lint !e661 There is always a winner (lTranspObjWinnerId valid value) since this task gets active only on a request! */
      {
        Dcm_NetProcessStartProtocol(pTranspObj);
      }
      else
      {
        /* Mark busy for the winner */
        lBusyEvents |= Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvOptType, lTranspObjWinnerId);
      }
    }
    else/* same protocol - proceed with the new request/busy responses */
    {
      Dcm_DiagRxIndication(pTranspObj);
    }
  }/* else - no winner - proceed with the busy responses */

  DCM_NETTOBJ_CNTR_INIT
  DCM_TSK_EVENT_SCAN_LOOP(lBusyEvents)
  {
    /* Check who did just loose */
    if(Dcm_TskIsLocalEventSet(lBusyEvents, 0x01u))
    {
      Dcm_NetTransportObjectPtrType pTranspObj = Dcm_NetGetTranspObjByHandle(DCM_NETTOBJ_CNTR_VALUE);

      Dcm_NetBufferRelease(Dcm_NetTranspObjGetBufferHandleValue(pTranspObj));   /* the buffer is free now */
# if(DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
      pTranspObj->Flags |= DCM_NET_TOBJ_FLAG_BUSY;
      Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND);
# else
      Dcm_NetUnRegisterComMActivity(Dcm_NetTranspObjGetConnIdOnly(pTranspObj));
      Dcm_NetUnRegisterActiveConnection(pTranspObj);/* no further processing needed */
# endif
    }
    DCM_NETTOBJ_CNTR_NEXT
  }
}                                                                                                                                                    /* PRQA S 6030 */ /* MD_MSR_STCYC */
#endif

/**********************************************************************************************************************
 *  Dcm_NetRegisterActiveConnection()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetRegisterActiveConnection(Dcm_NetTransportObjectPtrType pTranspObj)                                      /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  DCM_IGNORE_UNREF_PARAM(pTranspObj);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */
#if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
  if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_INTERNAL) == 0)/* internal requests do not manage the S3 timer */
#endif
  {
#if(DCM_NET_MULTI_TRANSP_OBJ_ENABLED == STD_ON)
    /*=================================*
     END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */

    if(Dcm_SingletonContext.Network.NumActiveConnections == 0u)
#endif
    {
      Dcm_TmrStopTimer(DCM_TMR_ID_S3);
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
      Dcm_TmrStopTimer(DCM_TMR_ID_KEEP_ALIVE);
#endif
    }

#if(DCM_NET_MULTI_TRANSP_OBJ_ENABLED == STD_ON)
    if(Dcm_SingletonContext.Network.NumActiveConnections < Dcm_UtiMaxValueOfUintType(uint8))                                                         /* COV_DCM_RTM_UNREACHABLE TX */
    {
      ++Dcm_SingletonContext.Network.NumActiveConnections;
    }
    else
    {
      /* Too many activations! */
      Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                   /* COV_DCM_RTM_DEV_DEBUG XF */
    }
    /*=================================*
     END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
#endif
  }
}

/**********************************************************************************************************************
 *  Dcm_NetTransmitUsdtResponse()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTransmitUsdtResponse(Dcm_NetTransportObjectPtrType pTranspObj)
{
  Std_ReturnType lStdResult = DCM_E_NOT_OK;
  boolean doCallTxConfirmation = TRUE;

  /* The TX path must be still "ready" here. if not, check the caller - it shall take care about this state! */
  Dcm_DebugAssert((pTranspObj->State == DCM_NET_TOBJ_STATE_PREPTX), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                           /* COV_DCM_RTM_DEV_DEBUG XF */

  /* Update TX context */
  pTranspObj->BuffPos = 0u;
  pTranspObj->State = DCM_NET_TOBJ_STATE_ONTX;

#if (DCM_NET_SUPPRESS_ON_FUNC_REQ_ENABLED == STD_ON)                                                                                                 /* COV_DCM_UNSUPPORTED XF */
  if( (Dcm_NetIsPropertieSet(pTranspObj, DCM_NET_CONN_PROP_TX_ON_FUNC_RX))
    &&(Dcm_PbCfgNetRxPduInfo[pTranspObj->RxPduId].IsFuncReq == TRUE) )
  {
    lStdResult = DCM_E_OK;
  }
  else
#endif
#if (DCM_NET_CONNECTION_WITHOUT_TX_ENABLED == STD_ON)
  if (Dcm_NetIsPropertieSet(pTranspObj, DCM_NET_CONN_PROP_NO_MAIN_TX))
  {
    lStdResult = DCM_E_OK;
  }
  else
#endif
  {
    if((DCM_NET_COMM_STATE_FLAG_TX_EN & Dcm_NetGetComStateByTranspObject(pTranspObj)) != 0)
    {
      lStdResult = PduR_DcmTransmit(Dcm_PbCfgNetConnectionInfo[Dcm_NetTranspObjGetConnIdValue(pTranspObj)].TxPduIdMain
                                  ,&pTranspObj->BuffInfo);
      if(lStdResult == E_OK)
      {
        doCallTxConfirmation = FALSE;/* wait for CopyTxData/TxConfirmation */
      }
    }/* else - finish with TX failed! */
  }

  /* Do not retry transmission -> make a loop-back and finalize transmission */
  if(doCallTxConfirmation == TRUE)
  {
    Dcm_NetUsdtTxConfirmation(pTranspObj, lStdResult);
  }
}

#if (DCM_NET_CONN_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetLockConnection()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NetTransportObjectPtrType, DCM_CODE) Dcm_NetLockConnection(DCM_NETCONNID_PARAMDEF_ONLY)
{
  Dcm_NetTransportObjectPtrType pTranspObj;
  Dcm_CfgNetTObjHandleMemType   tObjHdl;

# if(DCM_NET_MULTI_CONNECT_ENABLED == STD_ON)
  DCM_IGNORE_UNREF_PARAM(DCM_NETCONNID_PARAM_NAME);                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  /*=================================*
   BEGIN CRITICAL SECTION
   *=================================*/
  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  tObjHdl = Dcm_NetAllocateOrGetTranspObject(DCM_NETCONNID_PARAM_ONLY);
# if(DCM_NET_TRANSP_OBJ_DYN_ALLOC_ENABLED == STD_ON)
  if(tObjHdl >= DCM_NET_INVALID_TOBJID)
  {
    pTranspObj = NULL_PTR;
  }
  else
# endif
  {
    pTranspObj = Dcm_NetGetTranspObjByHandle(tObjHdl);

    if(pTranspObj->State == DCM_NET_TOBJ_STATE_FREE)
    {
      Dcm_NetTranspObjSetBufferHandle(pTranspObj, Dcm_NetGetProtObjOfConnection(DCM_NETCONNID_PARAM_VALUE)->RxTxBufferRef);
      /* Is the buffer in use? */
      if(Dcm_NetBufferIsFree(Dcm_NetTranspObjGetBufferHandleValue(pTranspObj)))
      {
        Dcm_NetBufferLock(Dcm_NetTranspObjGetBufferHandleValue(pTranspObj));   /* the buffer is in use now */
        Dcm_NetTranspObjSetConnId(pTranspObj, (Dcm_NetConnRefMemType)DCM_NETCONNID_PARAM_VALUE);
        pTranspObj->State = DCM_NET_TOBJ_STATE_RESERVED;
      }
      else
      {
        Dcm_NetTranspObjRelease(pTranspObj);
        pTranspObj = NULL_PTR;
      }
    }
    else
    {
      pTranspObj = NULL_PTR;
    }
  }/*else - nothing found to be free */
  /*=================================*
   END CRITICAL SECTION
   *=================================*/
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  return pTranspObj;
}
#endif

/**********************************************************************************************************************
 *  Dcm_NetTpRxIndicationNotOk()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpRxIndicationNotOk(Dcm_NetTransportObjectPtrType pTranspObj)
{
#if(DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
  if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_BUSY) == 0) /* consider only real buffer usage */
#endif
  {
    Dcm_NetBufferRelease(Dcm_NetTranspObjGetBufferHandleValue(pTranspObj));   /* the buffer is free now */
  }
  Dcm_NetUnRegisterActiveConnection(pTranspObj);/* no further processing needed */
}

/**********************************************************************************************************************
 *  Dcm_NetTpRxIndication()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpRxIndicationOk(Dcm_NetTransportObjectPtrType pTranspObj)
{
#if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)                                                                                                 /* COV_DCM_UNSUPPORTED XF */
  if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_CANCELED) != 0) /* CancelReceive was called before -> ignore request although reception couldn't be canceled */
  {
    Dcm_NetBufferRelease(Dcm_NetTranspObjGetBufferHandleValue(pTranspObj));   /* the buffer is free now */
    Dcm_NetUnRegisterActiveConnection(pTranspObj);/* no further processing needed */
  }
  else
#endif
  {
    boolean keepTranspObj;

    keepTranspObj = Dcm_DiagAcceptNewRequest(pTranspObj);
    pTranspObj->State = DCM_NET_TOBJ_STATE_RX_END;

    if(keepTranspObj == TRUE)
    {
      Dcm_NetRegisterComMActivity(pTranspObj);
#if(DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
      if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_BUSY) != 0)
      {
        Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND);
      }
      else
#endif
      {
        /* Store SID for RCR-RP responses */
        pTranspObj->AddBuffer[1] = pTranspObj->RxData[0];
        /* signal processing start */
#if (DCM_NET_TASK_RX_ENABLED == STD_ON)                                                                                                              /* COV_DCM_UNSUPPORTED XF */
        Dcm_TskSetEvent(DCM_TSK_ID_NET_RX, Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, pTranspObj->Handle));
#else
        Dcm_DiagRxIndication(pTranspObj);
#endif
      }
    }
    else
    {
      Dcm_NetTpRxIndicationNotOk(pTranspObj);
    }
  }
}
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)                                                                                                  /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetTpTxConfirmation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpTxConfirmation(PduIdType txPduId
                                                             ,Dcm_NetArEnvNotifResultType result)
{
  uint8 lErrorId = DCM_E_NO_ERROR;
  Dcm_CfgNetTObjHandleMemType tObjHdl = Dcm_NetGetTranspObjIdOfTxPduId(txPduId);

  DCM_IGNORE_UNREF_PARAM(txPduId);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_DEV_ERROR_DETECT == STD_ON)
#  if(DCM_NET_TRANSP_OBJ_DYN_ALLOC_ENABLED == STD_ON)
  if(tObjHdl >= DCM_NET_INVALID_TOBJID)
  {
    lErrorId = DCM_E_ILLEGAL_STATE;
  }
  else
#  endif
# endif
  {
    Dcm_NetTransportObjectPtrType pTranspObj = Dcm_NetGetTranspObjByHandle(tObjHdl);
# if (DCM_DEV_ERROR_DETECT == STD_ON)
    if((DCM_NET_TOBJ_STATE_ONTX & pTranspObj->State) == 0)
    {
      lErrorId = DCM_E_ILLEGAL_STATE;
    }
    else
# endif
    {
      Dcm_NetUsdtTxConfirmation(pTranspObj, Dcm_NetArEnvGetTransmResult(result));
    }
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_TXCONFIRMATION, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)                                                                                                  /* COV_DCM_SUPPORT_PARTIALLY TX tx xf */
/**********************************************************************************************************************
 *  Dcm_NetCopyRxData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetCopyRxData(Dcm_NetTransportObjectPtrType pTranspObj
                                                         ,P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info                                          /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                         ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) bufferSizePtr)
{
  BufReq_ReturnType lResult;
  uint8             lErrorId = DCM_E_NO_ERROR;

  if(info->SduLength != 0u) /* any payload now? */
  {
# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
    lResult = BUFREQ_E_NOT_OK;
    if (pTranspObj->BuffPos >= pTranspObj->RxLength)
    {
      lErrorId = DCM_E_PARAM;
    }
    else if((PduLengthType)(pTranspObj->RxLength - pTranspObj->BuffPos) < info->SduLength)
    {
      lErrorId = DCM_E_PARAM;
    }
    else
# endif
    {
# if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)                                                                                                /* COV_DCM_UNSUPPORTED XF */
      if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_CANCELED) != 0)
      {
        lResult = BUFREQ_E_NOT_OK;
      }
      else
# endif
      {
        /* Copy current data portion */
# if(DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
        /* Check for simulated mode */
        if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_BUSY) != 0)
        {
          if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_COPYHEAD) != 0)
          {
            Dcm_UtiBitOpClr(Dcm_NetTransportObjectFlagType, pTranspObj->Flags, DCM_NET_TOBJ_FLAG_COPYHEAD);                                          /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
            /* Assumed that no TP will write bytewise but at least 2 bytes are inside the SduDataPtr */
            pTranspObj->RxData[0] = info->SduDataPtr[0];/* copy the SID */
            pTranspObj->RxData[1] = info->SduDataPtr[1];/* copy the SUBSID */
          }
        }
        else
# endif
        {
          Dcm_UtiMemCopy(info->SduDataPtr, &(pTranspObj->RxData[pTranspObj->BuffPos]), info->SduLength);                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
        }
        pTranspObj->BuffPos += (Dcm_CfgNetBufferSizeMemType)(info->SduLength); /* update next position */

        *bufferSizePtr = (PduLengthType)(pTranspObj->RxLength - pTranspObj->BuffPos); /* Notify lower layer about available buffer space */
        lResult = BUFREQ_OK;
      }
    }
  }
  else
  {
    *bufferSizePtr = (PduLengthType)(pTranspObj->RxLength - pTranspObj->BuffPos); /* Notify lower layer about available buffer space */
    lResult = BUFREQ_OK;
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_COPYRXDATA, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
  return lResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_NetTpRxIndication()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_NetTpRxIndication(PduIdType rxPduId
                                                           ,Dcm_NetArEnvNotifResultType result)
{
  Dcm_CfgNetTObjHandleMemType tObjHdl = Dcm_NetGetTranspObjIdOfRxPduId(rxPduId);

# if(DCM_NET_TRANSP_OBJ_DYN_ALLOC_ENABLED == STD_ON)
  if(tObjHdl >= DCM_NET_INVALID_TOBJID)
  {
    /* just ignore in case the DCM_E_NOT_OK from the StartOfReception has lead to the RxIndication (AR does not specify what will happen after this)*/
  }
  else
# endif
  {
    Dcm_NetTransportObjectPtrType pTranspObj = Dcm_NetGetTranspObjByHandle(tObjHdl);
    if( (pTranspObj->State == DCM_NET_TOBJ_STATE_ONRX) /* expected state for RX indication? Note: if parallel request from the same tester is sent (i.e. functional 0x3E 0x80) -> the transport object state will be ON_RX!  */
      &&(rxPduId == pTranspObj->RxPduId) ) /* Consider also any nested request on different TP connection but from the same tester! */
    {
      if(result != DCM_NET_ARENV_NTFRSLT_OK)
      {
        Dcm_NetTpRxIndicationNotOk(pTranspObj);
      }
      else
      {
        Dcm_NetTpRxIndicationOk(pTranspObj);
      }
    }/* else- (could be an unexpected API call but most probably it is due to a concurrent request (StartOfReception returns DCM_E_NOT_OK) from the same tester) OR (indication of unexpected connection) */
  }
}

/**********************************************************************************************************************
 *  Dcm_NetCopyTxData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetCopyTxData(Dcm_NetTransportObjectPtrType pTranspObj
                                                      ,P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info                                             /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                      ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) availableDataPtr)
{
  BufReq_ReturnType lResult;
  uint8             lErrorId = DCM_E_NO_ERROR;

# if (DCM_NET_PROCESSING_CANCELLATION_ENABLED == STD_ON)                                                                                             /* COV_DCM_UNSUPPORTED XF */
  if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_CANCELED) != 0)
  {
    lResult = BUFREQ_E_NOT_OK;
  }
  else
# endif
  {
# if(DCM_PAGED_BUFFER_ENABLED == STD_ON)
    if(pTranspObj->ResType == DCM_NET_TOBJ_RESTYPE_PAGED)
    {
      lResult = Dcm_PagedBufferCopyData(info, availableDataPtr);
    }
    else
# endif
    {
      /* Linear case */
# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
      lResult = BUFREQ_E_NOT_OK;

      if( (info->SduLength != 0u)
        &&(pTranspObj->BuffPos >= pTranspObj->BuffInfo.SduLength) )
      {
        lErrorId = DCM_E_PARAM;
      }
      else if((PduLengthType)(pTranspObj->BuffInfo.SduLength - pTranspObj->BuffPos) < info->SduLength)
      {
        lErrorId = DCM_E_PARAM;
      }
      else
# endif
      {
        /* Copy current data portion */
        Dcm_UtiMemCopy(&(pTranspObj->BuffInfo.SduDataPtr[pTranspObj->BuffPos]), info->SduDataPtr, info->SduLength);                                  /* PRQA S 3109 */ /* MD_MSR_14.3 */
        pTranspObj->BuffPos += (Dcm_CfgNetBufferSizeMemType)(info->SduLength); /* update next position */

        *availableDataPtr = (PduLengthType)(pTranspObj->BuffInfo.SduLength - pTranspObj->BuffPos); /* Notify lower layer about available buffer space */
        lResult = BUFREQ_OK;
      }
    }
  }
# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_COPYTXDATA, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
#if (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON)                                                                                                          /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_ModeInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_ModeInit(void)
{
  /* Initialize ControlDTCsetting internal mode. */
  Dcm_ModeSetControlDtcSettingGroup(DEM_DTC_GROUP_ALL_DTCS);
  Dcm_ModeSetControlDtcSettingMode(RTE_MODE_DcmControlDtcSetting_ENABLEDTCSETTING);

# if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
  /* Initialize CommunicationControl internal mode. */
  {
    uint8_least channelIter;
    for(channelIter = 0; channelIter < Dcm_PbCfgNetNumAllComMChannels; ++channelIter)
    {
      Dcm_ModeSetCommControlState(channelIter, DCM_ENABLE_RX_TX_NORM_NM);
    }
  }
# endif
}

# if (DCM_MODEMGR_CHECK_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeCheck()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_ModeCheck(Dcm_CfgModeMgrRuleRefOptType modeRuleRef)
{
  uint8 lNrc = DCM_E_CONDITIONSNOTCORRECT;/* default NRC in case no rule specifies any NRC */

  return (Dcm_NegativeResponseCodeType)((Dcm_CfgModeMgrRules[modeRuleRef](&lNrc) == TRUE) ? DCM_E_POSITIVERESPONSE /* no error */
                                                                                          : lNrc ); /* condition failed - consider the returned NRC */
}
# endif
#endif /* (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)                                                                                                  /* COV_DCM_UNSUPPORTED XF */
# if (DCM_MODE_ECU_RESET_ENABLED == STD_ON) || \
     (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchAckEcuReset()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchAckEcuReset(void)
{
  return DCM_E_OK;/* always succeeds */
}
# endif

# if (DCM_MODE_ECU_RESET_ENABLED == STD_ON) || \
     (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchEcuReset()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchEcuReset(Dcm_ResetModeType mode)
{
  BswM_Dcm_RequestResetMode(mode);
  return DCM_E_OK;
}
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)                                                                                                  /* COV_DCM_SUPPORT_PARTIALLY TX tx xf */
# if (DCM_MODE_ECU_RESET_ENABLED == STD_ON)   || \
     (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)                                                                                                         /* COV_DCM_UNSUPPORTED TF tf xf */
/**********************************************************************************************************************
 *  Dcm_ModeSwitchAckResultInterpreter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchAckResultInterpreter(Std_ReturnType modeSwitchAckResult)
{
  Std_ReturnType lStdResult;

  switch(modeSwitchAckResult)
  {
  case RTE_E_TRANSMIT_ACK:
    /* switch accomplished */
    lStdResult = DCM_E_OK;
    break;
  case RTE_E_NO_DATA:
    lStdResult = DCM_E_PENDING;
    break;
  default: /* any error situation */
    lStdResult = DCM_E_NOT_OK;
    break;
  }
  return lStdResult;
}
# endif

# if (DCM_MODE_ECU_RESET_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchAckEcuReset()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchAckEcuReset(void)
{
  Std_ReturnType lStdResult;

  lStdResult = Rte_SwitchAck_DcmEcuReset_DcmEcuReset();

  return Dcm_ModeSwitchAckResultInterpreter(lStdResult);
}
# endif

# if (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)                                                                                                         /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_ModeSwitchAckRapidShutDown()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchAckRapidShutDown(void)
{
  Std_ReturnType lStdResult;

  lStdResult = Rte_SwitchAck_DcmModeRapidPowerShutDown_DcmModeRapidPowerShutDown();

  return Dcm_ModeSwitchAckResultInterpreter(lStdResult);
}
# endif

# if (DCM_MODE_ECU_RESET_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchEcuReset()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchEcuReset(Rte_ModeType_DcmEcuReset mode)
{
  Std_ReturnType lStdResult;

  lStdResult = Rte_Switch_DcmEcuReset_DcmEcuReset(mode);

  Dcm_DebugApiCheckRte((lStdResult == RTE_E_OK), DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)
  return lStdResult;
}
# endif

# if (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)                                                                                                         /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_ModeSwitchRapidShutDown()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_ModeSwitchRapidShutDown(Rte_ModeType_DcmModeRapidPowerShutDown mode)
{
  Std_ReturnType lStdResult;

  lStdResult = Rte_Switch_DcmModeRapidPowerShutDown_DcmModeRapidPowerShutDown(mode);

  Dcm_DebugApiCheckRte((lStdResult == RTE_E_OK), DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)
  return lStdResult;
}
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_StateInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_StateInit(void)
{
  Dcm_SingletonContext.StateMgr.Preconditions.Session  = DCM_STATE_VALUE_SESSION_INIT;
#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
  Dcm_SingletonContext.StateMgr.Preconditions.Security = DCM_STATE_VALUE_SECURITY_INIT;
#endif
  Dcm_StateSetPendingSession(DCM_STATE_VALUE_SESSION_INIT);
}

#if (DCM_STATE_ANY_NOTIFICATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateExecOnStateChangeFunc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_StateExecOnStateChangeFunc(Dcm_CfgStateNotificationInfoPtrType notifList                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                    ,uint8 formerStateId
                                                                    ,uint8 newStateId)
{
  while(notifList->OnChgFunc != NULL_PTR)
  {
    notifList->OnChgFunc(formerStateId, newStateId);
    Dcm_UtiNextItemByPtr(notifList,1u);/* take next function */
  }
}
#endif

#if (DCM_STATE_SECURITY_LOOKUP_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateFindStateIndexFromSecLevel()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(sint8_least, DCM_CODE) Dcm_StateFindStateIndexFromSecLevel(Dcm_SecLevelType secLevel)
{
  sint8_least lResult;

  /* #10 If "locked" level: */
  if(secLevel == DCM_SEC_LEV_LOCKED)
  {
    /* #20 Return the only possible index - 0 */
    lResult = 0;
  }
  else
  {
    /* #30 Otherwise locate the index of the security level value in the security info table */
    DCM_STATE_SEC_LEVEL_ITER_DEF

    lResult = -1;
    DCM_STATE_SEC_LEVEL_LOOP_FOR_UP
    {
      if (Dcm_CfgStateSecurityInfo[DCM_STATE_SEC_LEVEL_ITER_VALUE].Value == secLevel)
      {
        /* #40 Found the correct index into the table - compensate zero offset for locked level */
        lResult = (sint8_least)(DCM_STATE_SEC_LEVEL_ITER_VALUE + 1);
        DCM_STATE_SEC_LEVEL_LOOP_BREAK
      }
    }
    /* #50 If the security level is not found, return -1 */
  }
  /* #60 Return final result */
  return lResult;
}
#endif

#if (DCM_STATE_SECURITY_FIXED_BYTES_ENABLED == STD_ON)                                                                                               /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_StateGetSecurityLevelFixedBytes()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_StateGetSecurityLevelFixedBytes(Dcm_SecLevelType secLevel
                                                                    ,P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) fixedBytes
                                                                    ,P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) bufferSize)
{
  Std_ReturnType  lResult;
  sint8_least     lStateIdx;

  lStateIdx = Dcm_StateFindStateIndexFromSecLevel(secLevel);
  if (lStateIdx <= 0)
  {
    /* Locked, or unsupported security level */
    lResult = DCM_E_NOT_OK;
  }
  else
  {
    uint8 lFixedByteSize;
    --lStateIdx; /* norm to zero index (excluded locked state offset) */
    lFixedByteSize = (uint8)(Dcm_CfgStateSecurityFixedByteInfo[lStateIdx + 1]
                            - Dcm_CfgStateSecurityFixedByteInfo[lStateIdx + 0]);
    if (lFixedByteSize > *bufferSize)
    {
      lResult = DCM_E_BUFFERTOOLOW;
    }
    else
    {
      Dcm_UtiConstByteMemCopy(&Dcm_CfgStateSecurityFixedBytes[Dcm_CfgStateSecurityFixedByteInfo[lStateIdx]]
                              ,fixedBytes
                              ,lFixedByteSize);
      lResult = E_OK;
    }
    *bufferSize = lFixedByteSize;
  }
  return lResult;
}
#endif

/**********************************************************************************************************************
 *  Dcm_StateNotifyServiceProcessors()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_StateNotifyServiceProcessors(void)
{
  /* now process session/security state updates:
    - on any session transition: security is always changed
    - on security state transition: security is always changed
  */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc2COnStateChanged();
#endif
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc2AOnStateChanged();
#endif
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc2FOnStateChanged();
#endif
}
/**********************************************************************************************************************
 *  Dcm_TskInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskInit(void)
{
  /* #10 Initialize task activity tracer. */
  Dcm_TskTraceInit();

  /* #20 Initialize priority related states. */
  {
    Dcm_TskTaskPrioOptType tskPrioIter;

    for(tskPrioIter = 0; tskPrioIter < DCM_TSK_NUM_PRIOS; ++tskPrioIter)
    {
      Dcm_SingletonContext.TaskMgr.TaskScheduler[tskPrioIter].SchdIsActive = FALSE;
    }
  }

  /* #30 Initialize task related events. */
  {
    Dcm_TskTaskIdOptType tskIter;

    for(tskIter = 0; tskIter < DCM_TSK_NUM_TASKS; ++tskIter)
    {
      Dcm_SingletonContext.TaskMgr.TaskContext[tskIter].TaskEvents = 0u;
    }
  }
}

#if (DCM_TSK_TASK_KILL_ENABLED == STD_ON)                                                                                                            /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_TskKillAllTasks()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TskKillAllTasks(void)
{
  Dcm_TskTaskIdOptType tskIter;

  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
   BEGIN CRITICAL SECTION
   *=================================*/

   for(tskIter = 0; tskIter < DCM_TSK_NUM_TASKS; ++tskIter)
   {
     if((Dcm_TskTaskInfo[tskIter].TskAtr & DCM_TSK_ATR_KILL_ALWAYS) != 0)
     {
       Dcm_SingletonContext.TaskMgr.TaskContext[tskIter].TaskEvents &= Dcm_TskTaskInfo[tskIter].NonKillEvents;      /* clear only killable events */
# if (DCM_TSK_TASK_COMPLEX_KILL_ENABLED == STD_ON)
       Dcm_TskSetFlag(tskIter, DCM_TSK_TASK_FLAG_KILLED);
# endif
     }
   }

   /*=================================*
   END CRITICAL SECTION
   *=================================*/
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
}
#endif
/**********************************************************************************************************************
 *  Dcm_TmrInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_TmrInit(void)
{
  Dcm_TmrTimerIdOptType iter;

  for(iter = 0; iter < DCM_TMR_NUM_TIMERS_CASTED; ++iter)
  {
    Dcm_SingletonContext.TimerMgr.Timer[iter] = 0u;
  }
}
#if (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_RidMgrExecuteRoutine()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_RidMgrExecuteRoutine(Dcm_OpStatusType opStatus
                                                                        ,Dcm_MsgContextPtrType pMsgContext                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                        ,Dcm_NegativeResponseCodePtrType errorCode)
{
  Std_ReturnType          lStdResult;

# if (DCM_RIDMGR_DYN_LEN_ENABLED == STD_ON)
  Dcm_RidMgrRidLengthType reqResLen = (Dcm_RidMgrRidLengthType)(pMsgContext->reqDataLen);/* on dynamic length -> already subtracted to the last signal length */
# endif

  /* Prepare response buffer for routine info byte (if enabled) */
# if (DCM_RIDMGR_SUPPORT_ROUTINEINFOBYTE_ENABLED == STD_ON)

  /* Read routine info byte of RID from configuration; RIDs that do not support routine info byte have a invalid value */
  Dcm_CfgRidMgrRoutineInfoByteMemType lRoutineInfoByte = Dcm_InstanceContext.Repeater.Contexts.Context.Svc31.RidInfoPtr->RoutineInfoByte;

  /* If initial call of function and routine info byte of Rid is valid, reserve 1 byte in response buffer by moving response buffer pointer */
  if ((opStatus == DCM_INITIAL)
    && (lRoutineInfoByte != DCM_CFGRIDMGR_INVALID_ROUTINEINFOBYTE))
  {
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc31.RIBResPtr = pMsgContext->resData;
    Dcm_DiagMoveOnResWithLength(pMsgContext, 1u);                                                                                                    /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }
# endif

  /* call appropriate function prototype */
  switch(Dcm_InstanceContext.Repeater.Contexts.Context.Svc31.RidOpInfoPtr->OpType)
  {
# if (DCM_RIDMGR_OPTYPE_NONE_ENABLED == STD_ON)
  case DCM_RIDMGR_OPTYPE_NONE:
    lStdResult = ((Dcm_RidMgrOpFuncNoParamsType)Dcm_InstanceContext.Repeater.Contexts.Context.Svc31.RidOpInfoPtr->OpFunc)(opStatus                   /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                                                        ,errorCode);
    break;
# endif
# if (DCM_RIDMGR_OPTYPE_REQ_ENABLED == STD_ON)
  case DCM_RIDMGR_OPTYPE_REQ:
    lStdResult = ((Dcm_RidMgrOpFuncReqType)Dcm_InstanceContext.Repeater.Contexts.Context.Svc31.RidOpInfoPtr->OpFunc)(pMsgContext->reqData            /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                                                   ,opStatus
                                                                                                                   ,errorCode);
    break;
# endif
# if (DCM_RIDMGR_OPTYPE_REQ_RES_ENABLED == STD_ON)
  case DCM_RIDMGR_OPTYPE_REQ_RES:
    lStdResult = ((Dcm_RidMgrOpFuncReqResType)Dcm_InstanceContext.Repeater.Contexts.Context.Svc31.RidOpInfoPtr->OpFunc)(pMsgContext->reqData         /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                                                      ,opStatus
                                                                                                                      ,pMsgContext->resData
                                                                                                                      ,errorCode);
    break;
# endif
# if (DCM_RIDMGR_OPTYPE_RES_ENABLED == STD_ON)
  case DCM_RIDMGR_OPTYPE_RES:
    lStdResult = ((Dcm_RidMgrOpFuncResType)Dcm_InstanceContext.Repeater.Contexts.Context.Svc31.RidOpInfoPtr->OpFunc)(opStatus                        /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                                                   ,pMsgContext->resData
                                                                                                                   ,errorCode);
    break;
# endif
# if (DCM_RIDMGR_OPTYPE_REQ_DYNLEN_ENABLED == STD_ON)
  case DCM_RIDMGR_OPTYPE_REQ_DYNLEN:
    lStdResult = ((Dcm_RidMgrOpFuncReqDynLenType)Dcm_InstanceContext.Repeater.Contexts.Context.Svc31.RidOpInfoPtr->OpFunc)(pMsgContext->reqData      /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                                                         ,opStatus
                                                                                                                         ,reqResLen
                                                                                                                         ,errorCode);
    break;
# endif
# if (DCM_RIDMGR_OPTYPE_REQ_DYNLEN_RES_ENABLED == STD_ON)
  case DCM_RIDMGR_OPTYPE_REQ_DYNLEN_RES:
    lStdResult = ((Dcm_RidMgrOpFuncReqDynLenResType)Dcm_InstanceContext.Repeater.Contexts.Context.Svc31.RidOpInfoPtr->OpFunc)(pMsgContext->reqData   /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                                                            ,opStatus
                                                                                                                            ,pMsgContext->resData
                                                                                                                            ,reqResLen
                                                                                                                            ,errorCode);
    break;
# endif
# if (DCM_RIDMGR_OPTYPE_RES_DYNLEN_ENABLED == STD_ON)
  case DCM_RIDMGR_OPTYPE_RES_DYNLEN:
    lStdResult = ((Dcm_RidMgrOpFuncResDynLenType)Dcm_InstanceContext.Repeater.Contexts.Context.Svc31.RidOpInfoPtr->OpFunc)(opStatus                  /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                                                         ,pMsgContext->resData
                                                                                                                         ,&reqResLen
                                                                                                                         ,errorCode);
    break;
# endif
# if (DCM_RIDMGR_OPTYPE_REQ_DYNLEN_RES_DYNLEN_ENABLED == STD_ON) || \
     (DCM_RIDMGR_OPTYPE_REQ_RES_DYNLEN_ENABLED == STD_ON)
#  if (DCM_RIDMGR_OPTYPE_REQ_DYNLEN_RES_DYNLEN_ENABLED == STD_ON)
  case DCM_RIDMGR_OPTYPE_REQ_DYNLEN_RES_DYNLEN:
#  endif
#  if (DCM_RIDMGR_OPTYPE_REQ_RES_DYNLEN_ENABLED == STD_ON)
  case DCM_RIDMGR_OPTYPE_REQ_RES_DYNLEN:
#  endif
    lStdResult = ((Dcm_RidMgrOpFuncReqAnyLenResDynLenType)Dcm_InstanceContext.Repeater.Contexts.Context.Svc31.RidOpInfoPtr->OpFunc)(pMsgContext->reqData /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                                                                  ,opStatus
                                                                                                                                  ,pMsgContext->resData
                                                                                                                                  ,&reqResLen
                                                                                                                                  ,errorCode);
    break;
# endif

  default:
    *errorCode = DCM_E_PANIC_NRC;
    lStdResult = DCM_E_NOT_OK;
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG)                                                                                    /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }

  /* Catch any RTE or unexpected specific errors */
  if( (lStdResult != DCM_E_OK)
    &&(lStdResult != DCM_E_PENDING)
    &&(lStdResult != DCM_E_NOT_OK)
    &&(lStdResult != DCM_E_FORCE_RCRRP) )
  {
    Dcm_DebugApiCheckRteAlways(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)
    *errorCode = DCM_E_PANIC_NRC;
    lStdResult = DCM_E_NOT_OK;
  }

  /* Provide routine Info byte (if enabled) */
# if (DCM_RIDMGR_SUPPORT_ROUTINEINFOBYTE_ENABLED == STD_ON)

  /* If final result is ok and routine info byte value is valid, copy routine info byte to reserved place in response buffer */
  if ((lStdResult == DCM_E_OK)
    && (lRoutineInfoByte != DCM_CFGRIDMGR_INVALID_ROUTINEINFOBYTE))
  {
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc31.RIBResPtr[0] = (uint8)lRoutineInfoByte;
  }
# endif

# if (DCM_RIDMGR_DYN_RES_LEN_ENABLED == STD_ON)
  if( (lStdResult == DCM_E_OK) /* consider only final results */
    &&((Dcm_InstanceContext.Repeater.Contexts.Context.Svc31.RidOpInfoPtr->DynLenMask & DCM_RIDMGR_DYNLEN_MASK_RES) != 0) )
  {
    Dcm_DiagUpdateResLength(pMsgContext, reqResLen); /* register response length of the last signal  */
  }
# endif

  Dcm_DiagHandleApplNrc(lStdResult, errorCode, DCM_E_CONDITIONSNOTCORRECT);                                                                          /* PRQA S 3109 */ /* MD_MSR_14.3 */

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6010, 6030 */ /* MD_MSR_STPTH,  MD_MSR_STCYC */
/**********************************************************************************************************************
 *  Dcm_RidMgrGetOpInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_RidMgrOpInfoPtrType, DCM_CODE) Dcm_RidMgrGetOpInfo(Dcm_RidMgrRidInfoPtrType pRidInfo
                                                                            ,Dcm_RidMgrOpType ridOp)
{
  Dcm_RidMgrOpInfoPtrType lpRidOpInfo = NULL_PTR;

  if((pRidInfo->Operations & ridOp) != 0)
  {
    Dcm_CfgRidMgrOpHandleOptType opHandle = pRidInfo->OpBaseIdx;
    do
    {
      ridOp>>= 1;/* pre-decrement! */
      if((pRidInfo->Operations & ridOp) != 0)
      {
        ++opHandle;
      }
    }
    while(ridOp != 0);
    lpRidOpInfo = &(Dcm_CfgRidMgrOpInfo[opHandle]);
  }
  return lpRidOpInfo;
}

/**********************************************************************************************************************
 *  Dcm_RidMgrRidLookUpFilter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_RidMgrRidLookUpFilter(uint16 rid
                                                                         ,Dcm_RidMgrRidInfoPtrType pRidInfo)
{
  Std_ReturnType lStdReturn = DCM_E_OK;

  DCM_IGNORE_UNREF_PARAM(rid);                                                                                                                       /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pRidInfo);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# if(DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)
  if(Dcm_VarMgrIsEnabledInActiveVariants(pRidInfo->ExecCondRef) == FALSE)
  {
    lStdReturn = DCM_E_NOT_OK;
  }
  else
# endif
  /* check session state */
  if(!Dcm_StateIsSupportedInSession(Dcm_StateGetPreconditionStates(pRidInfo->ExecCondRef)))
  {
    lStdReturn = DCM_E_NOT_OK;
  }
  else
  {
# if (DCM_SVC_31_OBD_CALIBRATION_ENABLED == STD_ON) && (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)
    if( (rid >= (uint16)0xE000u)
      &&(rid <= (uint16)0xE1FFu) )
    {
      if(Dcm_ObdIdMgrIsIdEnabled(Dcm_UtiGetLoByte(rid), &Dcm_CfgSvc31SupportedIdMask[Dcm_CfgSvc31SupportedIdMaskOffset[Dcm_UtiGetHiByte(rid)-(uint8)0xE0u]]) == FALSE)
      {
        lStdReturn = DCM_E_NOT_OK;
      }/* else - an enabled (WWH-)OBD RID */
    }/* else - a non (WWH-)OBD RID */
# endif
  }
  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_RidMgrRidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_RidMgrRidLookUp(Dcm_OpStatusType opStatus
                                                                   ,uint16 rid
                                                                   ,P2VAR(Dcm_RidMgrRidInfoPtrType, AUTOMATIC, DCM_VAR_NOINIT) pRidInfo)
{
  Std_ReturnType lStdReturn;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdReturn = DCM_E_OK;

# if (DCM_RIDMGR_EXTENDED_LOOKUP_ENABLED == STD_ON)
  if(opStatus == DCM_INITIAL)
# endif
  {
    sint16_least  lResult;

    lResult = Dcm_UtiLookUpUint16(Dcm_CfgRidMgrRidLookUpTable, rid);
    if (lResult >= 0)
    {
      *pRidInfo   = &Dcm_CfgRidMgrRidInfo[lResult];
    }
    else
    {
      lStdReturn = DCM_E_NOT_OK;
    }
  }

# if (DCM_RIDMGR_EXTENDED_LOOKUP_ENABLED == STD_ON)
  if(lStdReturn == DCM_E_OK)
  {
    /* Process DID enabled filter. */
    lStdReturn = Dcm_FilterRidLookUpResult(opStatus, rid);

#  if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
    if(opStatus == DCM_CANCEL)
    {
      /* Terminate immediately any further processing */
      lStdReturn = DCM_E_NOT_OK;
    }
#  endif

#  if (DCM_DEV_ERROR_DETECT == STD_ON)
    if( (lStdReturn != DCM_E_OK)
      &&(lStdReturn != DCM_E_PENDING)
      &&(lStdReturn != DCM_E_NOT_OK) )
    {
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
      lStdReturn = DCM_E_NOT_OK;
    }
#  endif
  }/*else - DCM_E_NOT_OK */
# endif

  if(lStdReturn == DCM_E_OK)
  {
    lStdReturn = Dcm_RidMgrRidLookUpFilter(rid, *pRidInfo);
  }/*else - DCM_E_NOT_OK, DCM_E_PENDING */
  return lStdReturn;
}
#endif /* (DCM_RIDMGR_SUPPORT_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_DiagInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagInit(void)
{
  Dcm_InstanceContext.Diag.State           = DCM_DIAG_STATE_IDLE;
#if (DCM_DIAG_PROCESSOR_FLAGS_ENABLED == STD_ON)                                                                                                     /* COV_DCM_UNSUPPORTED XF */
  Dcm_InstanceContext.Diag.QueuedSet.Flags = DCM_DIAG_QUEUE_FLAG_NONE;
#endif
#if (DCM_DIAG_GARB_COL_ENABLED == STD_ON)
  Dcm_InstanceContext.Diag.QueuedSet.QueuedTObjects = 0;
#endif

#if (DCM_DIAG_SVC_INITIALIZERS_ENABLED == STD_ON)                                                                                                    /* COV_DCM_UNSUPPORTED XF */
  /* Initialize all processors */
  {
    P2CONST(Dcm_DiagSvcInitFuncType, AUTOMATIC, DCM_CONST) initFuncPtr = &(Dcm_CfgDiagSvcInitializers[0]);
    do/* use do-while as optimal loop since link-time not supported */
    {
      (*initFuncPtr)();
      Dcm_UtiNextItemByPtr(initFuncPtr,1u);
    }
    while(*initFuncPtr != NULL_PTR);
  }
#endif

  Dcm_DiagSetP2Timings(0, 0);

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
  Dcm_SingletonContext.Network.RxAllowed = FALSE;
  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_RECOVERY, DCM_TSK_EV_DIAG_RECOVERY_GETSTATE);
#endif

#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
  /* Delegate to the first task activation. */
  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_FBLRES, DCM_TSK_EV_DIAG_FBLRES_SEND);
#endif
}

#if (DCM_DIAG_ANY_NOTIFICATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagExecConfirmationFunc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagExecConfirmationFunc(Dcm_CfgDiagNotificationInfoPtrType notifList                                      /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                  ,Dcm_ConfirmationStatusType confStatus)
{
  /* This API shall not be called if the list is empty (i.e. contains only list termination NULL_PTR) */
  Dcm_DebugAssert((notifList->IndFunc != NULL_PTR), DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG)                                                          /* COV_DCM_RTM_DEV_DEBUG XF */

  do
  {
    (void)notifList->ConfFunc(Dcm_InstanceContext.Diag.PostProcessorContext.Sid
                             ,Dcm_InstanceContext.Diag.PostProcessorContext.ReqType
                             ,Dcm_InstanceContext.Diag.PostProcessorContext.SrcAddr
                             ,confStatus);
    Dcm_UtiNextItemByPtr(notifList,1u);/* take next function */
  }
  while(notifList->ConfFunc != NULL_PTR);
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagGetPostProcessResult()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_ConfirmationStatusType, DCM_CODE) Dcm_DiagGetPostProcessResult(void)
{
  Dcm_ConfirmationStatusType confStatus  = DCM_DIAG_RES_ANY_OK;

  if(Dcm_InstanceContext.Diag.TxStatus != DCM_E_OK)
  {
    /* Set TX error flag */
    confStatus |= DCM_DIAG_RES_ANY_NOT_OK;
  }

  if(Dcm_InstanceContext.Diag.ErrorRegister != DCM_E_POSITIVERESPONSE)
  {
    /* Set neg response flag */
    confStatus |= DCM_DIAG_RES_NEG_ANY;
  }
  return confStatus;
}

/**********************************************************************************************************************
 *  Dcm_DiagStartServiceExecution()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagStartServiceExecution(Dcm_MsgContextPtrType pMsgContext)
{
  /* #10 Check if the new service supports sub-function parameter. */
  if((Dcm_CfgDiagServiceInfo[Dcm_InstanceContext.Diag.SidIndex].Props & DCM_DIAG_SVC_CFG_PROP_HAS_SUBFUNC)  != 0)
  {
    /* #20 If so, deal with the SPRMIB: extract and store. */
    if((pMsgContext->reqData[0] & 0x80u) != 0)
    {
      pMsgContext->reqData[0] &= 0x7Fu;/* mask out the SPRMIB */
      pMsgContext->msgAddInfo.suppressPosResponse = 1;
    }
    /* copy the sub-function byte once split RX/TX buffers are supported.
    pMsgContext->resData[0] = pMsgContext->reqData[0];
    */
  }

  /* #30 From now on, mark application calls for post-processing later. */
  Dcm_InstanceContext.Diag.ApplNotification |= DCM_DIAG_APPL_NOTIFICATION_SVC_HDLR; /* mark application notification at last here */

  /* #40 Set repeater per default to be no specific service. */
  Dcm_RepeaterSetUser(DCM_REPEATER_USER_NONE);
  /* #50 Execute Main-Handler (register it and it will be called immediately). */
  Dcm_RepeaterSetCallee(Dcm_CfgDiagServiceInfo[Dcm_InstanceContext.Diag.SidIndex].ProcFunc);
  /* #60 Let the service processor take over immediately. */
  return DCM_E_LOOP;
}

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_DiagProvideRecoveryStates()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagProvideRecoveryStates(
                                                    P2VAR(Dcm_RecoveryInfoType, AUTOMATIC, DCM_APPL_DATA) RecoveryInfo)
{
  /* Retrieve ComM channel states. */
  DCM_NETCHNL_COMM_ITER_DEF
  DCM_NETCHNL_COMM_LOOP_FOR_UP
  {
    RecoveryInfo->ComMChannelState[DCM_NETCHNL_COMM_ITER_VALUE] =
                                   (boolean)(Dcm_PbRamNetComMContext[DCM_NETCHNL_COMM_ITER_VALUE].RegisteredNetworks != 0u);
  }

  /* Retrieve session state. */
  RecoveryInfo->SessionLevel = Dcm_UtiGetBitPosition(Dcm_StateGetSession());

  /* Retrieve session connection. */
# if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
  RecoveryInfo->SessionConnection = Dcm_NetGetSessionConnection();
# endif

  /* Retrieve security state. */
# if (DCM_STATE_SECURITY_ENABLED == STD_ON)
  RecoveryInfo->SecurityLevel = Dcm_UtiGetBitPosition(Dcm_StateGetSecurity());
# endif

  /* Retrieve DTC settings state. */
# if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
#  if (DCM_SVC_85_DTC_GRP_ENABLED == STD_ON)
  RecoveryInfo->ControlDTCSettingDTCGroup = Dcm_ModeGetControlDtcSettingGroup();
#  endif
  RecoveryInfo->ControlDTCSettingDisabled = (boolean)(Dcm_ModeGetControlDtcSettingMode() == RTE_MODE_DcmControlDtcSetting_DISABLEDTCSETTING);
# endif

  /* Retrieve communication control state. */
# if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
  {
    uint8_least channelIter;
    for(channelIter = 0; channelIter < Dcm_PbCfgNetNumAllComMChannels; ++channelIter)
    {
      RecoveryInfo->CommControlState[channelIter] = Dcm_ModeGetCommControlState(channelIter);
    }
  }
# endif

  RecoveryInfo->Signature = DCM_DIAG_RECOVERY_SIGNATURE;
}
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_DiagProcessRecoveryInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagProcessRecoveryInfo(
                                                 P2CONST(Dcm_RecoveryInfoType, AUTOMATIC, DCM_VAR_NOINIT) RecoveryInfo)
{
  /* If a non-default session was active: */
  if(RecoveryInfo->SessionLevel != 0)
  {
    /* Activate ComM channels. */
    DCM_NETCHNL_COMM_ITER_DEF
    DCM_NETCHNL_COMM_LOOP_FOR_UP
    {
      if(RecoveryInfo->ComMChannelState[DCM_NETCHNL_COMM_ITER_VALUE] == TRUE)
      {
        Dcm_NetArEnvComMActiveDiag(Dcm_PbCfgNetAllComMChannelMap[Dcm_PbCfgNetConnComMChannelMap[DCM_NETCHNL_COMM_ITER_VALUE]]);
      }
    }

    /* Recover session state. */
    Dcm_StateSetSession(RecoveryInfo->SessionLevel);

# if(DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
    /* Works only for single protocol. See ESCAN00087310 for more details. */
    Dcm_SingletonContext.Network.ActiveProtocol = 0;
# endif

    /* Update P2 timings at once. */
    Dcm_DiagSetP2Timings(RecoveryInfo->SessionLevel, Dcm_NetGetProtIdOfActiveProtocol());

    /* Recover session connection. */
# if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
    Dcm_NetSetSessionConnection(RecoveryInfo->SessionConnection);
# endif

    Dcm_TmrStartTimer(DCM_TMR_ID_S3, DCM_DIAG_TIME_S3);
  }

# if (DCM_STATE_SECURITY_ENABLED == STD_ON)
  /* If any security level was unlocked: */
  if(RecoveryInfo->SecurityLevel != 0)
  {
    /* Recover security state. */
    Dcm_StateSetSecurity(RecoveryInfo->SecurityLevel);
  }
# endif

# if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
  /* If DTC settings were disabled: */
  if(RecoveryInfo->ControlDTCSettingDisabled == TRUE)
  {
    /* Recover DTC updating state. */
#  if (DCM_SVC_85_DTC_GRP_ENABLED == STD_ON)
    Dcm_Svc85DisableDtcSetting(RecoveryInfo->ControlDTCSettingDTCGroup);
#  else
    Dcm_Svc85DisableDtcSetting(DEM_DTC_GROUP_ALL_DTCS);
#  endif
  }
# endif

  /* Recover communication control states. */
# if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
  {
    uint8_least channelIter;
    for(channelIter = 0; channelIter < Dcm_PbCfgNetNumAllComMChannels; ++channelIter)
    {
      if(RecoveryInfo->CommControlState[channelIter] != DCM_ENABLE_RX_TX_NORM_NM)
      {
        Dcm_ModeSwitchCommControl(channelIter, RecoveryInfo->CommControlState[channelIter]);
      }
    }
  }
# endif
}
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_DiagSafeProcessRecoveryInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagSafeProcessRecoveryInfo(
                                                 P2CONST(Dcm_RecoveryInfoType, AUTOMATIC, DCM_VAR_NOINIT) RecoveryInfo)
{
  uint8  lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)
  if(RecoveryInfo->Signature != DCM_DIAG_RECOVERY_SIGNATURE)
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(RecoveryInfo->SessionLevel >= DCM_STATE_NUM_SESSION)
  {
    lErrorId = DCM_E_PARAM;
  }
  else
#  if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
  if( (RecoveryInfo->SessionLevel != 0u) /* non-default session */
    &&(RecoveryInfo->SessionConnection >= DCM_NET_INVALID_CONNID) )
  {
    lErrorId = DCM_E_PARAM;
  }
  else
#  endif
#  if (DCM_STATE_SECURITY_ENABLED == STD_ON)
  if(RecoveryInfo->SecurityLevel >= DCM_STATE_NUM_SECURITY)
  {
    lErrorId = DCM_E_PARAM;
  }
  else
#  endif
#  if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON)
  if(Dcm_PbCfgNetNumComMChannels > DCM_NET_MAX_NUM_COMM_CHANNELS)
  {
    lErrorId = DCM_E_PARAM;
  }
  else
#   if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
  if(Dcm_PbCfgNetNumAllComMChannels > DCM_NET_MAX_NUM_ALL_COMM_CHANNELS)
  {
    lErrorId = DCM_E_PARAM;
  }
  else
#   endif
#  endif
# endif
  {
    Dcm_DiagProcessRecoveryInfo(RecoveryInfo);
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_GETRECOVERYSTATES, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

#if (DCM_NET_PROCESSING_CANCELLATION_ENABLED == STD_ON)                                                                                              /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoCancelProcessing()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagWorkerDoCancelProcessing(Dcm_TskTaskEvOptType ev
                                                                                      ,Dcm_TskTaskEvPtrType pPostEv)                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_TskTaskEvOptType lResultEv = ev;

  DCM_IGNORE_UNREF_PARAM(pPostEv);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if(Dcm_InstanceContext.Diag.State == DCM_DIAG_STATE_PROCESS) /* still any open jobs (no PB jobs!) -> cancel them */
  {
    Dcm_InstanceContext.Repeater.Contexts.OpStatus = DCM_CANCEL;/* override any other opStatus values up to now */
    (void)Dcm_RepeaterExecute();/* signal cancellation */
  }

  if(((DCM_DIAG_STATE_PROCESS | DCM_DIAG_STATE_ON_TX) & Dcm_InstanceContext.Diag.State) != 0)/* any open diagnostic job ? (optimize interrupt lock times)*/
  {
    /* immediately cancel any ongoing transmission (RCR-RP, final response (RoE or external)) */
    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
      BEGIN CRITICAL SECTION
      *=================================*/
    if(((DCM_DIAG_STATE_PROCESS | DCM_DIAG_STATE_ON_TX) & Dcm_InstanceContext.Diag.State) != 0)/* STILL any open diagnostic job -> diagnostic transport object is still in use -> try cancel it */
    {
# if(DCM_NET_MULTI_TRANSP_OBJ_ENABLED == STD_ON)
      Dcm_DebugAssert((Dcm_DiagGetTranspObj() != NULL_PTR), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)
# endif
      if(Dcm_DiagGetTranspObj()->State == DCM_NET_TOBJ_STATE_ONTX) /* Any transmission active ? Potentially also RCR-RP response can be at sending */
      {
        Dcm_DiagGetTranspObj()->Flags |= DCM_NET_TOBJ_FLAG_CANCELED;/* isolate this connection */
        /* Short cut to speed up the service processing finalization - RCR-RP responses will just end with the cancellation below. */
        Dcm_DiagTxFinalization(Dcm_DiagGetTranspObj(), DCM_E_NOT_OK);

        /* Try cancel any ongoing response. The return value does not matter:
          * OK -> there will be a confirmation for this cancellation
          * N_OK -> request rejected, but there will be a confirmation due to the ongoing transmission */
        (void)Dcm_NetArEnvPduRCancelTransmit(Dcm_PbCfgNetConnectionInfo[Dcm_NetTranspObjGetConnIdValue(Dcm_DiagGetTranspObj())].TxPduIdMain);
        /* Any response (final, RCR-RP, etc) will just end with releasing the connection assigned to the tObject! No confirmation post-processing will be performed! */
      }
      else if (Dcm_DiagGetTranspObj()->State == DCM_NET_TOBJ_STATE_READY)
      {
        /* no transmission yet started -> just loop back the diagnostic confirmation immediately. Note: no other TX-confirmation type is expected here */
        Dcm_DiagTxFinalization(Dcm_DiagGetTranspObj(), DCM_E_NOT_OK);
      }
      else
      {
        /* unexpected state reached for canceling a transport object */
        Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                 /* COV_DCM_RTM_DEV_DEBUG XF */
      }
    }/* else - post processing or idle are to be handled in a normal way */
    /*=================================*
      END CRITICAL SECTION
      *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }
  /* Sync with TxEnd events set above OR TX confirmation. No ISR lock since:
    * - No TX confirmation can occur from now on.
    * - If above TX confirmation executed -> no other changes of the state are possible!
    * - If there was already a TX Confirmation (above code not executed) -> the task will just be re-triggered.
    */
  if((DCM_TSK_EV_DIAG_WORK_TX_END_FINAL & Dcm_TskGetEvent(DCM_TSK_ID_DIAG_WORK)) != 0) /* look ahead for any locally/externally (previous TX confirmation) finalization events */
  {
    Dcm_TskClrEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_TX_END_FINAL);/* clear any potentially globally set TX-end-response (from the above TX cancellation code) */
    Dcm_TskSetLocalEvent(lResultEv, DCM_TSK_EV_DIAG_WORK_TX_END_FINAL);/* set/transfer the TX end event */
  }/* else - either no TX end OR already set in the "ev" OR nothing to do */

  /* Attempt to revive the tasks */
  if((DCM_TSK_EV_DIAG_WORK_KILL_JOBS & Dcm_TskGetEvent(DCM_TSK_ID_DIAG_WORK)) == 0)/* Look ahead: Any nested kill job received? If so, no task revival!*/
  {
# if (DCM_DIAG_GARB_COL_ENABLED == STD_ON)
    Dcm_TskTaskEvOptType queuedTObjBitSet = 0; /* nothing to clean (for now) */
# endif
    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    if((DCM_TSK_EV_DIAG_WORK_KILL_JOBS & Dcm_TskGetEvent(DCM_TSK_ID_DIAG_WORK)) == 0)/* STILL no nested kill job received? */
    {
      Dcm_TskReviveAllTasks();/* from now on enable tasks for working */
# if (DCM_DIAG_GARB_COL_ENABLED == STD_ON)
      queuedTObjBitSet = Dcm_InstanceContext.Diag.QueuedSet.QueuedTObjects;
      /* Clear all except the last queued one  */
      Dcm_UtiBitOpClr(Dcm_TskTaskEvOptType, queuedTObjBitSet, Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, Dcm_DiagGetQueuedTranspObj()->Handle));   /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
      /* Remove all processed transport objects from the queue (the last queued one will be removed from the queue once transfered to the active tObject or canceled by higher prio request here again) */
      Dcm_UtiBitOpClr(Dcm_TskTaskEvMemType, Dcm_InstanceContext.Diag.QueuedSet.QueuedTObjects, queuedTObjBitSet);                                    /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
# endif
    }
    Dcm_UtiArEnvLeaveCriticalSection();
# if (DCM_DIAG_GARB_COL_ENABLED == STD_ON)
    if(queuedTObjBitSet > 0)
    {
      /* Some connections to clean up (in background)? */
      Dcm_TskSetEvent(DCM_TSK_ID_DIAG_GARB_COL, (Dcm_TskTaskEvMemType)queuedTObjBitSet);
    }
# endif                                                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }

  return lResultEv;
}                                                                                                                                                    /* PRQA S 6010, 6050 */ /* MD_MSR_STPTH, MD_MSR_STCAL */
#endif

/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoPostProcessing()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_DiagWorkerDoPostProcessing(void)
{
  /* do post processing */
  Dcm_ConfirmationStatusType confStatus;

  confStatus = Dcm_DiagGetPostProcessResult();

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
  /* reset any pending PB processing */
 (void)Dcm_PagedBufferCancel();
#endif

  /* Execute first the assigned service post-processor */
  if(((DCM_DIAG_APPL_NOTIFICATION_SVC_HDLR | DCM_DIAG_APPL_NOTIFICATION_SID_FOUND) & Dcm_InstanceContext.Diag.ApplNotification) != 0)
  {
    Dcm_CfgDiagSvcPostProcessors[Dcm_CfgDiagServiceInfo[Dcm_InstanceContext.Diag.SidIndex].ConfFuncRef](confStatus);/* execute any internal service processor post-handlers */

    if((DCM_DIAG_APPL_NOTIFICATION_SVC_HDLR & Dcm_InstanceContext.Diag.ApplNotification) != 0)
    {
      Dcm_Confirmation(0, Dcm_InstanceContext.Diag.MsgContext.rxPduId, confStatus);/* notify the application about transmission end (of any service) */
    }
  }

#if(DCM_DIAG_SYS_NOTIFICATION_ENABLED == STD_ON)
  /* Call post-handler only if the application has been notified about this service */
  if((DCM_DIAG_APPL_NOTIFICATION_SYS & Dcm_InstanceContext.Diag.ApplNotification) != 0)
  {
    Dcm_DiagExecConfirmationFunc(Dcm_CfgDiagSysNotificationInfo, confStatus);
  }
#endif
#if(DCM_DIAG_OEM_NOTIFICATION_ENABLED == STD_ON)
  if((DCM_DIAG_APPL_NOTIFICATION_OEM & Dcm_InstanceContext.Diag.ApplNotification) != 0)
  {
    Dcm_DiagExecConfirmationFunc(Dcm_CfgDiagOemNotificationInfo, confStatus);
  }
#endif
#if(DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
  if(Dcm_InstanceContext.Diag.IsInternRequest == TRUE)/* manage ComM states only on processed requests from external clients */
  {
# if (DCM_SVC_86_TX_END_IND_ENABLED == STD_ON)                                                                                                       /* COV_DCM_UNSUPPORTED XF */
    Dcm_ExtSvc86TxEnd(confStatus);
# endif
  }
  else
#endif
  {
    Dcm_NetUnRegisterComMActivity(Dcm_NetConnIdWrpOnly(Dcm_NetGetConnIdOfRxPduId(Dcm_InstanceContext.Diag.MsgContext.rxPduId)));/* process here to take a potentially new session change into account */
  }
  Dcm_InstanceContext.Diag.State = DCM_DIAG_STATE_IDLE;
}

/**********************************************************************************************************************
 *  Dcm_DiagWorkerSetDefSessionExtern()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagWorkerSetDefSessionExtern(Dcm_TskTaskEvOptType ev
                                                                                       ,Dcm_TskTaskEvPtrType pPostEv)
{
  Dcm_TskTaskEvOptType lResultEv = ev;

  /* enforce default session reset, but only if no service is still in processing! */
  if(Dcm_InstanceContext.Diag.State != DCM_DIAG_STATE_IDLE)
  {
    /* If no one has already requested session change -> try later */
    if(!Dcm_TskIsLocalEventSet(lResultEv, DCM_TSK_EV_DIAG_WORK_INT_SET2DEF))                                                                         /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY XX */
    {
      Dcm_TskSetLocalEvent(*pPostEv, DCM_TSK_EV_DIAG_WORK_EXT_SET2DEF); /* retry later again */
    }
  }
  else
  {
    /* Do immediately activate default session. */
    Dcm_TskSetLocalEvent(lResultEv, DCM_TSK_EV_DIAG_WORK_INT_SET2DEF);

    /* If non-default session is active the current protocol id is unequal to DCM_NET_INVALID_PROTID. */
    if(!Dcm_StateIsDefaultSessionActive())
    {
      /* Update P2 timings at once. */
      Dcm_DiagSetP2Timings(0, Dcm_NetGetProtIdOfActiveProtocol());
    }/* else - P2 timings of default session already set. */

#if (DCM_NET_RX_BLOCKING_ENABLED == STD_ON)
    Dcm_SingletonContext.Network.RxAllowed = TRUE;
#endif
  }

  return lResultEv;
}

/**********************************************************************************************************************
 *  Dcm_DiagWorkerProcessNewRequest()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagWorkerProcessNewRequest(Dcm_TskTaskEvOptType ev
                                                                                     ,Dcm_TskTaskEvPtrType pPostEv)                                  /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_TskTaskEvOptType lResultEv = ev;

  DCM_IGNORE_UNREF_PARAM(pPostEv);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

#if (DCM_DIAG_TOBJ_QUEUE_ENABLED == STD_ON) || \
    (DCM_DIAG_GARB_COL_ENABLED == STD_ON) || \
    (DCM_DIAG_SYNCH_FLAGS_ENABLED == STD_ON)                                                                                                         /* COV_DCM_UNSUPPORTED XF xf xf xf */
  Dcm_SplitTaskEnterCS();                                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
# if (DCM_DIAG_GARB_COL_ENABLED ==STD_ON)                                                                                                            /* COV_DCM_UNSUPPORTED XF */
  if((DCM_TSK_EV_DIAG_WORK_KILL_JOBS & Dcm_TskGetEvent(DCM_TSK_ID_DIAG_WORK)) != 0)/* STILL no (nested) kill job received? */
  {
    Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, (Dcm_TskTaskEvMemType)ev);/* repeat all still unprocessed events at once together with the kill-event in order to get these always synchronized */
    lResultEv = 0; /* skip any further processing in this Dcm_DiagTaskWorker() activation (i.e. return immediately) */
  }
  else
# endif
  {
# if (DCM_DIAG_SYNCH_FLAGS_ENABLED == STD_ON)
    Dcm_UtiBitOpClr(Dcm_DiagProcessorFlagType, Dcm_InstanceContext.Diag.QueuedSet.Flags, DCM_DIAG_QUEUE_FLAG_IS_WAITING);                            /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
    Dcm_UtiBitOpSet(Dcm_DiagProcessorFlagType, Dcm_InstanceContext.Diag.QueuedSet.Flags, DCM_DIAG_QUEUE_FLAG_IS_ACTIVE);
# endif

# if (DCM_DIAG_TOBJ_QUEUE_ENABLED == STD_ON)
    Dcm_DiagSetTranspObj(Dcm_DiagGetQueuedTranspObj()); /* switch work contexts! RCR-RP will be sent also from this one (QueuedCtxt) */
# endif
    /* Remove from queue */
# if (DCM_DIAG_GARB_COL_ENABLED ==STD_ON)                                                                                                            /* COV_DCM_UNSUPPORTED XF */
    Dcm_UtiBitOpClr(Dcm_TskTaskEvMemType, Dcm_InstanceContext.Diag.QueuedSet.QueuedTObjects, (Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, Dcm_DiagGetQueuedTranspObj()->Handle)));
# endif
  }
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_SplitTaskLeaveCS();                                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
#endif
#if (DCM_DIAG_GARB_COL_ENABLED ==STD_ON)                                                                                                             /* COV_DCM_UNSUPPORTED XF */
  /* Shall we start dispatching or wait for kill old job ? */
  if((DCM_DIAG_QUEUE_FLAG_IS_ACTIVE & Dcm_InstanceContext.Diag.QueuedSet.Flags) != 0)
#endif
  {
#if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
    /* use new request type */
    Dcm_InstanceContext.Diag.IsInternRequest = (boolean)((Dcm_DiagGetTranspObj()->Flags & DCM_NET_TOBJ_FLAG_INTERNAL) != 0);
#endif
    /* start new request processing */
    Dcm_RepeaterSetCallee(Dcm_DiagDispatcher);
    Dcm_TskSetLocalEvent(lResultEv, DCM_TSK_EV_DIAG_WORK_REPEAT);/* execute immediately */
  }

  return lResultEv;
}

/**********************************************************************************************************************
 *  Dcm_DiagWorkerProcessRcrRpTxEnd()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagWorkerProcessRcrRpTxEnd(Dcm_TskTaskEvOptType ev
                                                                                     ,Dcm_TskTaskEvPtrType pPostEv)                                  /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_TskTaskEvOptType lResultEv = ev;

  DCM_IGNORE_UNREF_PARAM(pPostEv);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if((DCM_NET_TOBJ_FLAG_RCRRP_TYPE_APPL & Dcm_DiagGetTranspObj()->Flags) != 0)/* this is a RCR-RP response - check which kind */
  {
    Dcm_UtiBitOpClr(Dcm_NetTransportObjectFlagType, Dcm_DiagGetTranspObj()->Flags, DCM_NET_TOBJ_FLAG_RCRRP_TYPE_APPL);                               /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
    Dcm_InstanceContext.Repeater.Contexts.OpStatus = (Dcm_OpStatusType)((Dcm_InstanceContext.Diag.TxStatus != DCM_E_OK)
                                                                        ?DCM_FORCE_RCRRP_NOT_OK
                                                                        :DCM_FORCE_RCRRP_OK);
    Dcm_TskSetLocalEvent(lResultEv, DCM_TSK_EV_DIAG_WORK_REPEAT); /* notify immediately */
  }

  return lResultEv;
}

/**********************************************************************************************************************
 *  Dcm_DiagWorkerDoRepeat()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagWorkerDoRepeat(Dcm_TskTaskEvOptType ev
                                                                            ,Dcm_TskTaskEvPtrType pPostEv)
{
  Std_ReturnType lStdResult;
  Dcm_TskTaskEvOptType lResultEv = ev;

#if (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
  if(Dcm_TskIsLocalEventSet(lResultEv, DCM_TSK_EV_DIAG_WORK_CANCEL_OP))
  {
    Dcm_InstanceContext.Repeater.Contexts.OpStatus = DCM_CANCEL;/* override any other opStatus values up to now */
  }
#endif
  lStdResult = Dcm_RepeaterExecute();

  switch(lStdResult)
  {
  case DCM_E_PROCESSINGDONE:
    Dcm_ProcessingDone();
    /* stop polling and wait for confirmation */
    break;
  case DCM_E_PENDING:
    Dcm_InstanceContext.Repeater.Contexts.OpStatus = DCM_PENDING;
#if (DCM_RUNTIME_USAGE_LIMIT_ENABLED == STD_ON)
    /* fall through - keep the last opStatus on "pending" forced by Dcm_RepeaterExecute code */
  case DCM_E_PENDING_LIMITER:                                                                                                                        /* PRQA S 2003 */ /* MD_Dcm_Optimize_2003 */
#endif
    /* Retry next cycle with the same parameter */
    Dcm_TskSetLocalEvent(*pPostEv, DCM_TSK_EV_DIAG_WORK_REPEAT);
    break;
  case DCM_E_FORCE_RCRRP:
    Dcm_UtiArEnvEnterCriticalSection();/* protect against Dcm_TpTxConfirmation or hi-priority Dcm_DiagTaskRx */                                      /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
    BEGIN CRITICAL SECTION
    *=================================*/
    Dcm_DiagGetTranspObj()->Flags |= DCM_NET_TOBJ_FLAG_RCRRP_TYPE_APPL;
    if((Dcm_DiagGetTranspObj()->Flags & (DCM_NET_TOBJ_FLAG_RCRRP_ON_TX | DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ))  == 0)/* no RCR-RP already requested for transmission/ongoing? */
    {
      Dcm_TskSetEvent(DCM_TSK_ID_DIAG_RX, DCM_TSK_EV_DIAG_RX_TMR_P2_TO);/* trigger a RCR-RP event timeout */
    }/*else - just wait for confirmation signal */

    /*=================================*
    END CRITICAL SECTION
    *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /* stop polling and wait for confirmation */
    break;
  default:
    Dcm_RepeaterSetCallee(Dcm_RepeaterDeadEnd); /* any other return value leads to a dead end */
    break;
  }

  return lResultEv;
}

#if (DCM_TSK_NUM_DIAG_FBLRES > 0)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoGetProgCond()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagFblResDoGetProgCond(Dcm_TskTaskEvOptType ev
                                                                                 ,Dcm_TskTaskEvPtrType pPostEv)                                      /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_TskTaskEvOptType lResultEv = ev;

  DCM_IGNORE_UNREF_PARAM(pPostEv);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if(Dcm_GetProgConditions(&Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions) == DCM_WARM_START) /* is a reset after reprogramming ? */
  {
    sint16_least sesSfIter = -1;
# if (DCM_DIAG_NOTIF_BSWM_APPL_UPDATED_ENABLED == STD_ON)
    if(Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.ApplUpdated == TRUE)
    {
      BswM_Dcm_ApplicationUpdated();
    }
# endif

    if(Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.Sid == 0x10u)
    {
      sesSfIter = Dcm_VarMgrLookUpFilter(Dcm_UtiLookUpUint8(Dcm_CfgSvc10SubFuncLookUpTable, Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.SubFuncId)
                                        ,Dcm_CfgSvc10SubFuncExecPrecondTable);
    }/*else - for SID 0x11 or other it is not critical to send any response - it will be up to the application to use the API! */

    if( (Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.ResponseRequired == TRUE) /* a response is to be sent */
      ||(sesSfIter > 0) ) /* OR a non-default session is to be activated (need ComM active)*/
    {
      Dcm_NetConnRefMemType connId;

      connId = Dcm_NetGetConnIdByTesterAddress(Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.TesterSourceAddr);

      if(connId < DCM_NET_INVALID_CONNID)
      {
        Dcm_NetTransportObjectPtrType pTranspObj; /* use a local copy to avoid collision with a RxIndication! */

        pTranspObj = Dcm_NetLockConnection(Dcm_NetConnIdWrpOnly(connId));

        if(pTranspObj != NULL_PTR) /* try to lock the connection to this tester */
        {
# if(DCM_NET_MULTI_CONNECT_ENABLED == STD_ON)
          Dcm_InstanceContext.Diag.StartUpFbl.ConnId = Dcm_NetTranspObjGetConnIdValue(pTranspObj);
# endif
          Dcm_DiagSetTranspObj(pTranspObj);/* store working context */
          Dcm_TmrStartTimer(DCM_TMR_ID_FBLRES, Dcm_InstanceContext.Diag.P2Timings.P2Star); /* wait at most P2 star to finalize the FBL positive response */
          /* Start communication */
          Dcm_NetRegisterActiveConnection(pTranspObj);
          Dcm_NetRegisterComMActivity(pTranspObj);
          Dcm_TskSetLocalEvent(lResultEv, DCM_TSK_EV_DIAG_FBLRES_WAITTXCOMM);/* Try immediately */
        }
        /* else - there is a problem locking the channel (there is already a tester request) */
      }
      else
      {
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_PARAM);
      }
    }
    /* store current analysis results */
    Dcm_InstanceContext.Diag.StartUpFbl.SessStateRef = (sint8)sesSfIter;
    Dcm_InstanceContext.Diag.StartUpFbl.IsResponseRequired = Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.ResponseRequired;
    /* Clear the flags for the next boot mode in background (in parallel) */
    Dcm_TskSetLocalEvent(lResultEv, DCM_TSK_EV_DIAG_FBLRES_RSTFLAGS);/* Try immediately */
  }

  return lResultEv;
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif

#if (DCM_TSK_NUM_DIAG_FBLRES > 0)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoWaitTxComm()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagFblResDoWaitTxComm(Dcm_TskTaskEvOptType ev
                                                                                ,Dcm_TskTaskEvPtrType pPostEv)
{
  Dcm_TskTaskEvOptType lResultEv = ev;

  if((DCM_NET_COMM_STATE_FLAG_TX_EN & Dcm_NetGetComStateByTranspObject(Dcm_DiagGetTranspObj())) != 0)
  {
    Dcm_TmrStopTimer(DCM_TMR_ID_FBLRES);

    if(Dcm_InstanceContext.Diag.StartUpFbl.IsResponseRequired == FALSE) /* is final response required ? */
    {
      Dcm_DiagOnFblResTxFinished(Dcm_DiagGetTranspObj(), DCM_E_OK);/* Loop-back to the confirmation (successful "virtual" transmission) to clean up transportObject and ComM */
    }
    else
    {
      Dcm_DiagGetTranspObj()->State   = DCM_NET_TOBJ_STATE_PREPTX;
      Dcm_DiagGetTranspObj()->ResType = DCM_NET_TOBJ_RESTYPE_UNSOLICITED;
      Dcm_DiagGetTranspObj()->BuffInfo.SduDataPtr = &Dcm_InstanceContext.Diag.StartUpFbl.ResBuffer[0];
      Dcm_DiagGetTranspObj()->BuffInfo.SduLength  = 2u; /* only service and a sub-function to be sent */
      /* Prepare final response to be sent */
      Dcm_InstanceContext.Diag.StartUpFbl.ResBuffer[0] = (uint8)(Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.Sid + 0x40u);
      Dcm_InstanceContext.Diag.StartUpFbl.ResBuffer[1] = Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.SubFuncId;

      if(Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.Sid == 0x10u)
      {
        if(Dcm_InstanceContext.Diag.StartUpFbl.SessStateRef >= 0)
        {
          Dcm_InstanceContext.Diag.StartUpFbl.ResBuffer[2] = Dcm_UtiGetHiByte(Dcm_CfgSvc10SubFuncInfo[Dcm_InstanceContext.Diag.StartUpFbl.SessStateRef].ResponseTime.P2);
          Dcm_InstanceContext.Diag.StartUpFbl.ResBuffer[3] = Dcm_UtiGetLoByte(Dcm_CfgSvc10SubFuncInfo[Dcm_InstanceContext.Diag.StartUpFbl.SessStateRef].ResponseTime.P2);
          Dcm_InstanceContext.Diag.StartUpFbl.ResBuffer[4] = Dcm_UtiGetHiByte(Dcm_CfgSvc10SubFuncInfo[Dcm_InstanceContext.Diag.StartUpFbl.SessStateRef].ResponseTime.P2Star);
          Dcm_InstanceContext.Diag.StartUpFbl.ResBuffer[5] = Dcm_UtiGetLoByte(Dcm_CfgSvc10SubFuncInfo[Dcm_InstanceContext.Diag.StartUpFbl.SessStateRef].ResponseTime.P2Star);
          Dcm_DiagGetTranspObj()->BuffInfo.SduLength = 6u;
        }
        else
        {
          Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_PARAM);
        }
      }/*else - for SID 0x11 or other it is not critical to send any response - it will be up to the application to use the API! */

      Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND);
    }
  }
  else
  {
    if(Dcm_TskIsLocalEventSet(lResultEv, DCM_TSK_EV_DIAG_FBLRES_CANCEL))/* stop polling since time is up */
    {
      Dcm_DiagOnFblResTxFinished(Dcm_DiagGetTranspObj(), DCM_E_NOT_OK);/* Loop-back to the confirmation (failed transmission) to clean up transportObject and ComM */
    }
    else
    {
      Dcm_TskSetLocalEvent(*pPostEv, DCM_TSK_EV_DIAG_FBLRES_WAITTXCOMM);/* Retry next time */
    }
  }

  return lResultEv;
}
#endif

#if (DCM_TSK_NUM_DIAG_FBLRES > 0)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoResetFlags()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagFblResDoResetFlags(Dcm_TskTaskEvOptType ev
                                                                                ,Dcm_TskTaskEvPtrType pPostEv)
{
  Dcm_TskTaskEvOptType lResultEv = ev;
  Std_ReturnType lStdResult;

  /* clear here in order to share flag resetting with the kill job */
  Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.ReprogrammingRequest = FALSE;
  Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.ApplUpdated      = FALSE;
  Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions.ResponseRequired = FALSE;

  lStdResult = Dcm_SetProgConditions(&Dcm_InstanceContext.Diag.StartUpFbl.ProgConditions);
  switch(lStdResult)
  {
  case DCM_E_OK:
    /* flags have been updated */
    break;
  case DCM_E_PENDING:
    Dcm_TskSetLocalEvent(*pPostEv, DCM_TSK_EV_DIAG_FBLRES_RSTFLAGS);/* Retry next time */
    break;
  default:
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
    break;
  }

  return lResultEv;
}
#endif

#if (DCM_TSK_NUM_DIAG_FBLRES > 0)
/**********************************************************************************************************************
 *  Dcm_DiagFblResDoProcessTxConfirmation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_DiagFblResDoProcessTxConfirmation(Dcm_TskTaskEvOptType ev
                                                                                           ,Dcm_TskTaskEvPtrType pPostEv)                            /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_TskTaskEvOptType lResultEv = ev;

  DCM_IGNORE_UNREF_PARAM(pPostEv);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* #10 If the final response was for a non-default session and was successfully sent: */
  if( (Dcm_InstanceContext.Diag.StartUpFbl.TxStatus == DCM_E_OK) /* only if successfully sent response ... */
    &&(Dcm_InstanceContext.Diag.StartUpFbl.SessStateRef > 0) )/* ... of diagnostic session control for a non-default session ... */
  {
    /* #20 Enter critical section (Reason: Protect against Dcm_StartOfReception) */
    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */

    /* #30 Register the diagnostic client for this session. */
    Dcm_NetSetSessionConnection(Dcm_NetConnIdWrpOnly(Dcm_InstanceContext.Diag.StartUpFbl.ConnId));/* set tester for the session */
# if(DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)                                                                                                       /* COV_DCM_UNSUPPORTED XF */
    /* #40 Register new active protocol. */
    Dcm_SingletonContext.Network.ActiveProtocol = Dcm_NetGetProtIdOfConnection(Dcm_NetConnIdWrpOnly(Dcm_InstanceContext.Diag.StartUpFbl.ConnId));
# endif
    /* #50 Leave critical section. */
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */

    /* #60 Perform the corresponding session transition. */
    Dcm_StateSetSession((Dcm_StateIndexMemType)Dcm_InstanceContext.Diag.StartUpFbl.SessStateRef);

    /* #70 Update P2 timings at once. */
    Dcm_DiagSetP2Timings((Dcm_StateIndexMemType)Dcm_InstanceContext.Diag.StartUpFbl.SessStateRef
                        ,Dcm_NetGetProtIdOfActiveProtocol());
  }
  /* #80 Unregister diagnostic client in order to consider any non-default session activated above. */
  Dcm_NetUnRegisterComMActivity(Dcm_NetConnIdWrpOnly(Dcm_InstanceContext.Diag.StartUpFbl.ConnId));

  return lResultEv;
}
#endif
#if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON) && \
    (DCM_DEV_RAM_SHREDDER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VarMgrRamShredder()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_VarMgrRamShredder(void)
{
 /* Depending on the configuration all PBL related RAM object shall be shredded for debug purposes.
  * The order is notfrom importance.
  */
# if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                         /* COV_DCM_UNSUPPORTED XF */
  Dcm_UtiRamShredderArray(Dcm_PbRamNetPeriodicTxObject, Dcm_NetPeriodicTxObjectType,  Dcm_PbCfgNetNumPerTxObjects,      DCM_RAM_PBCFG);              /* PRQA S 0310, 3109 */ /* MD_Dcm_DifferentPointerType_0310, MD_MSR_14.3 */
# endif
  Dcm_UtiRamShredderArray(Dcm_PbRamNetComMContext,      Dcm_NetComMContextType,       Dcm_PbCfgNetNumComMChannels,      DCM_RAM_PBCFG);              /* PRQA S 0310, 3109 */ /* MD_Dcm_DifferentPointerType_0310, MD_MSR_14.3 */
# if(DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_OFF)                                                                                                /* COV_DCM_UNSUPPORTED TX */
  Dcm_UtiRamShredderArray(Dcm_PbRamNetConnId2TObjMap,   Dcm_CfgNetTObjHandleMemType,  Dcm_PbCfgNetNumConnections,       DCM_RAM_PBCFG);              /* PRQA S 0310, 3109 */ /* MD_Dcm_DifferentPointerType_0310, MD_MSR_14.3 */
# endif
  Dcm_UtiRamShredderArray(Dcm_PbRamNetTransportObject,  Dcm_NetTransportObjectType,   Dcm_PbCfgNetNumTransportObjects,  DCM_RAM_PBCFG);              /* PRQA S 0310, 3109 */ /* MD_Dcm_DifferentPointerType_0310, MD_MSR_14.3 */
  Dcm_UtiRamShredderArray(Dcm_PbRamNetBufferContext,    Dcm_NetBufferContextType,     Dcm_PbCfgNetNumBuffers,           DCM_RAM_PBCFG);              /* PRQA S 0310, 3109 */ /* MD_Dcm_DifferentPointerType_0310, MD_MSR_14.3 */
# if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
  Dcm_UtiRamShredderArray(Dcm_PbRamNetComCtrlChannels,  Dcm_CommunicationModeType,    Dcm_PbCfgNetNumAllComMChannels,   DCM_RAM_PBCFG);              /* PRQA S 0310, 3109 */ /* MD_Dcm_DifferentPointerType_0310, MD_MSR_14.3 */
# endif
}                                                                                                                                                    /* PRQA S 6010, 6030 */ /* MD_MSR_STPTH, MD_MSR_STCYC */
#endif

#if (DCM_VARMGR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_VarMgrInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_VarMgrInit(Dcm_ConfigPtrType configPtr)
{
  boolean result = FALSE;
  uint8   lErrorId = DCM_E_NO_ERROR;

  if(configPtr == NULL_PTR)
  {
    Dcm_EcuMErrorNotification(ECUM_BSWERROR_NULLPTR);
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
  {
# if(DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON)
    if (configPtr->FinalMagicNumber != DCM_CFG_FINAL_MAGIC_NUMBER)
    {
      Dcm_EcuMErrorNotification(ECUM_BSWERROR_MAGICNUMBER);
      lErrorId = DCM_E_INVALID_CONFIG;
    }
    else if (configPtr->GenOutputType != DCM_CFG_GEN_COMPATIBILITY_VERSION)
    {
      Dcm_EcuMErrorNotification(ECUM_BSWERROR_COMPATIBILITYVERSION);
      lErrorId = DCM_E_INVALID_CONFIG;
    }
    else
# endif
    {
      /* configuration pointer is valid */
      /* communication variant handling */
# if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)                                                                                                        /* COV_DCM_SUPPORT_ALWAYS TX */
      Dcm_SingletonContext.VarMgr.ActiveComVariant = configPtr->ComVariant;
# endif
      /* Set bridge */
# if (DCM_DIAG_MULTI_SVC_TABLE_ENABLED == STD_ON)                                                                                                    /* COV_DCM_UNSUPPORTED XF */
      Dcm_UtiAssignStruct(Dcm_SingletonContext.VarMgr.ActiveBridgeVariant, configPtr->BridgeVariant, Dcm_CfgVarMgrBridgeVariantType);                /* PRQA S 0310 */ /* MD_Dcm_GenericStructAssign_0310 */
# endif
# if (DCM_VARMGR_MODE_POSTBUILD_LOAD_ENABLED == STD_ON)
      Dcm_UtiAssignStruct(Dcm_SingletonContext.VarMgr.ActiveRamVariant, *(configPtr->RamVariant), Dcm_CfgVarMgrRamVariantType);                      /* PRQA S 0310 */ /* MD_Dcm_GenericStructAssign_0310 */
      Dcm_UtiAssignStruct(Dcm_SingletonContext.VarMgr.ActiveRomVariant, *(configPtr->RomVariant), Dcm_CfgVarMgrRomVariantType);                      /* PRQA S 0310 */ /* MD_Dcm_GenericStructAssign_0310 */
# endif

      /* Init RAM */
      Dcm_VarMgrRamShredder();

      /* diagnostic service variant handling */
# if(DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)                                                                                                     /* COV_DCM_UNSUPPORTED XF */
#  if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)
      Dcm_VarMgrBitSetSetBit(Dcm_SingletonContext.VarMgr.ActiveCfgVariants, configPtr->DiagVariantId);/* activate base variant */
#  else
      Dcm_SingletonContext.VarMgr.ActiveCfgVariantId = configPtr->DiagVariantId;
#  endif
# endif
      result = TRUE;
    }
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_INIT, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
  return result;
}
#endif
#if (DCM_SVC_02_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc02ReadPidData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(uint8, DCM_CODE) Dcm_Svc02ReadPidData(uint8 pid, Dcm_MsgContextPtrType pMsgContext, uint32 maskValue)
{
  uint8 lResult = 1u;

  /* the response data starts with PID and FF */
  pMsgContext->resData[0] = pid;
  pMsgContext->resData[1] = 0x00u; /* Only FF 0x00 is supported */

  if(Dcm_ObdIdMgrIsAvailabilityId(pid)) /* availability PID */
  {
    (void)Dcm_ObdIdMgrReadSupportedId(maskValue
                                     ,&(pMsgContext->resData[2]));
    /* move on context */
    Dcm_DiagMoveOnResWithLength(pMsgContext, 6u);                                                                                                    /* PRQA S 3109, 0715 */ /* MD_MSR_14.3, MD_Dcm_Design_0715 */
  }
  else if(pid == 0x02u) /* read data PID from freeze frame */
  {
    uint32 lDtc;

    if(Dcm_DemAPI(GetDTCOfOBDFreezeFrame)(0x00u, &lDtc) != E_OK)
    {
      lDtc = 0x0000u;
    }

    /* PID 0x02: DTC that stored the freeze frame */
    pMsgContext->resData[2] = Dcm_UtiGetHiLoByte(lDtc);
    pMsgContext->resData[3] = Dcm_UtiGetLoHiByte(lDtc);
    Dcm_DiagMoveOnResWithLength(pMsgContext, 4u);                                                                                                    /* PRQA S 3109, 0715 */ /* MD_MSR_14.3, MD_Dcm_Design_0715 */
  }
  else
  {
    /* other PID: get data from freeze frame */
    Std_ReturnType lStdReturn;
    uint8 bufSize;

    /* Calculate maximum possible buffer size (reduce by two to compensate the place for PID and FF!) */
    bufSize = (uint8)Dcm_UtiMathMin((Dcm_MsgLenType)(pMsgContext->resMaxDataLen - 2), 0xFFu);
    lStdReturn = Dcm_DemAPI(ReadDataOfOBDFreezeFrame)(pid
                                                     ,0x00u /* DCM does not know the data index, so 0x00 is used here */
                                                     ,&(pMsgContext->resData[2])
                                                     ,&bufSize);
    if( (lStdReturn == E_OK)
      &&(bufSize > 0) )
    {
      /* PID have been successfully read */
      Dcm_DiagMoveOnResWithLengthAll(pMsgContext, (uint16)((uint16)bufSize + 2u));                                                                   /* PRQA S 3109 */ /* MD_MSR_14.3 */
    }
    else
    {
      /* else - PID can not be read or no data stored --> ignore */
      lResult = 0;
    }
  }

  return lResult;
}
#endif /* (DCM_SVC_02_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON)                                                 /* COV_DCM_UNSUPPORTED XF xf xf */
/**********************************************************************************************************************
 *  Dcm_Service06Process_SupportedMid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Service06Process_SupportedMid(Dcm_MsgContextPtrType pMsgContext
                                                                       ,Dcm_NegativeResponseCodePtrType errorCode)
{
  uint8 lSupportedMids[6];
  uint8_least lMidIter;
  uint8_least lNumberOfMids = (uint8) pMsgContext->reqDataLen;

  *errorCode = DCM_E_POSITIVERESPONSE;

  /* #10 Check if every MIDs in request is a availability MID (0x00, 0x20, 0x40...) */
  for (lMidIter = 0; lMidIter < lNumberOfMids; lMidIter++)
  {
    if (Dcm_ObdIdMgrIsAvailabilityId(pMsgContext->reqData[lMidIter]))
    {
      /* #20 If MID is a availabilty MID */
      /* #30 Copy MID value to local buffer */
      lSupportedMids[lMidIter] = pMsgContext->reqData[lMidIter];
    }
    else
    {
      /* Otherwise return NRC DCM_E_REQUESTOUTOFRANGE (Mix of Data and Availability MIDs is not allowed) */
      *errorCode = DCM_E_REQUESTOUTOFRANGE;
      break;
    }
  }

  if (*errorCode == DCM_E_POSITIVERESPONSE)
  {
    /* #50 If every MID is a availability MID */
    /* #60 Request from Dem value of each MID in local buffer */
    for (lMidIter = 0; lMidIter < lNumberOfMids; lMidIter++)
    {
      uint32 lObdMidAvailMask;
      if (Dem_DcmGetAvailableOBDMIDs(lSupportedMids[lMidIter], &lObdMidAvailMask) == E_OK)                                                           /* PRQA S 3353 */ /* MD_Dcm_3353 */
      {
        /* If request of a MID value is successful */

        /* #80 If response data buffer has not enough space */
        if (pMsgContext->resMaxDataLen < 5)
        {
          /* #81 Return NRC DCM_E_REQUESTOUTOFRANGE */
          *errorCode = DCM_E_REQUESTOUTOFRANGE;
          break;
        }
        /* #90 Otherwise copy MID and MID value to response buffer */
        else
        {
          pMsgContext->resData[0] = lSupportedMids[lMidIter];

          pMsgContext->resData[1] = Dcm_UtiGetHiHiByte(lObdMidAvailMask);
          pMsgContext->resData[2] = Dcm_UtiGetHiLoByte(lObdMidAvailMask);
          pMsgContext->resData[3] = Dcm_UtiGetLoHiByte(lObdMidAvailMask);
          pMsgContext->resData[4] = Dcm_UtiGetLoLoByte(lObdMidAvailMask);

          Dcm_DiagMoveOnResWithLengthAll(pMsgContext, 5u);/* move to next block of response */                                                       /* PRQA S 3109 */ /* MD_MSR_14.3 */
        }
      }
      /* else NRC will be set later if response length equal 0 -> none of the OBD MIDs could be read */
    }

    /* #110 If response data buffer is empty  */
    if (pMsgContext->resDataLen == 0)
    {
      /* #120 return NRC DCM_E_REQUESTOUTOFRANGE */
      *errorCode = DCM_E_REQUESTOUTOFRANGE;
    }
  }
}

/**********************************************************************************************************************
 *  Dcm_Service06Process_SingleMid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Service06Process_SingleMid(Dcm_MsgContextPtrType pMsgContext
                                                                    ,Dcm_NegativeResponseCodePtrType errorCode)
{
  uint8 lObdMid = pMsgContext->reqData[0];
  uint8 lNumOfTIDs;

  *errorCode = DCM_E_POSITIVERESPONSE;
  /* #10 Request number of TIDs for MID from Dem */
  if (Dem_DcmGetNumTIDsOfOBDMID(lObdMid, &lNumOfTIDs) == E_OK)
  {
    /* #20 If request is successful */
    uint8 lTidIter;
    uint8 lTIDValue;
    uint8 lUaSID;
    uint16 lTestValue;
    uint16 lTestValueMin;
    uint16 lTestValueMax;

    /* #30  Request Test Result of each TID from Dem */
    for (lTidIter = 0; lTidIter < lNumOfTIDs; lTidIter++)
    {
      if (Dem_DcmGetDTRData(lObdMid
                           ,lTidIter
                           ,&lTIDValue
                           ,&lUaSID
                           ,&lTestValue
                           ,&lTestValueMin
                           ,&lTestValueMax) == E_OK)
      {

        /* #40 If request is successful for a TID */

        /* #50 If response data buffer has not enough space */
        if (pMsgContext->resMaxDataLen < 9)
        {
          /* #51 Return NRC DCM_E_REQUESTOUTOFRANGE */
          *errorCode = DCM_E_REQUESTOUTOFRANGE;
          break;
        }
        /* #60 Otherwise copy response data to response buffer */
        else
        {
          pMsgContext->resData[0] = lObdMid;

          pMsgContext->resData[1] = lTIDValue;

          pMsgContext->resData[2] = lUaSID;

          pMsgContext->resData[3] = Dcm_UtiGetHiByte(lTestValue);
          pMsgContext->resData[4] = Dcm_UtiGetLoByte(lTestValue);

          pMsgContext->resData[5] = Dcm_UtiGetHiByte(lTestValueMin);
          pMsgContext->resData[6] = Dcm_UtiGetLoByte(lTestValueMin);

          pMsgContext->resData[7] = Dcm_UtiGetHiByte(lTestValueMax);
          pMsgContext->resData[8] = Dcm_UtiGetLoByte(lTestValueMax);

          /* move to next block of response */
          Dcm_DiagMoveOnResWithLengthAll(pMsgContext, 9u);                                                                                           /* PRQA S 3109 */ /* MD_MSR_14.3 */
        }
      }
      else
      {
        /* #70 Otherwise return NRC DCM_E_CONDITIONSNOTCORRECT */
        *errorCode = DCM_E_CONDITIONSNOTCORRECT;
        break;                                                                                                                                       /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
      }
    }
  }
  else
  {
    /* #80 Otherwise return NRC DCM_E_REQUESTOUTOFRANGE */
    *errorCode = DCM_E_REQUESTOUTOFRANGE;
  }
}
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON) */
#if (DCM_SVC_22_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_DIDMGR_22_ACCESS_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *   Dcm_Svc22IsDidAccessible()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_Svc22IsDidAccessible(Dcm_DidMgrDidInfoContextPtrType pDidInfoContext)                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  boolean lResult;

  /* #10 Check whether the DID is used by service 0x2A or 0x2C. */
  if( (pDidInfoContext->Did == Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadPeriodic)
#  if (DCM_DIDMGR_2C_ACCESS_LOCK_ENABLED == STD_ON)
    ||(pDidInfoContext->Did == Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadDynamic )
#  endif
    /* no periodic DID is a writeable or IO DID -> no need to check for race conditions! */
    )
  {
    lResult = FALSE;
  }
  else
  {
    lResult = TRUE;
  }

  return lResult;
}
# endif

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_OFF)
/**********************************************************************************************************************
 *  Dcm_Svc22CopyLinearData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22CopyLinearData(Dcm_OpStatusType opStatus
                                                                       ,Dcm_MsgContextPtrType pMsgContext)                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType                lStdResult;
  Dcm_NegativeResponseCodeType  lNrc;

#  if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
  if(opStatus == DCM_INITIAL)
#  endif
  {
    /* #10 Copy the ID of the DID to the buffer. */
    pMsgContext->resData[0] = Dcm_UtiGetHiByte(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidInfoContextPtr->Did);
    pMsgContext->resData[1] = Dcm_UtiGetLoByte(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidInfoContextPtr->Did);
    Dcm_DiagMoveOnResWithLength(pMsgContext, 2u);                                                                                                    /* PRQA S 3109 */ /* MD_MSR_14.3 */

    Dcm_DidMgrGetOpClassInfo(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidInfoContextPtr, DCM_DIDMGR_OPTYPE_READ);
  }

  {
    /* #20 Try to read the DID. */
    lStdResult = Dcm_DidMgrRead(opStatus
                              ,pMsgContext->resData
                              ,NULL_PTR
                              ,Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidInfoContextPtr
                              ,&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidOpTypeContext)
                              ,&lNrc);
    switch(lStdResult)
    {
#  if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
    case DCM_E_PENDING:
      /* #40 Try it the next task cycle. */
      return DCM_E_PENDING;
#  endif
#  if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
    case DCM_E_FORCE_RCRRP:
      /* #60 Send NRC 0x78. */
      return DCM_E_FORCE_RCRRP;
#  endif
    case DCM_E_OK:
      /* #80 Go on with next DID. */
      break;
    default:/* DCM_E_NOT_OK */
#  if (DCM_DIDMGR_22_ACCESS_LOCK_ENABLED == STD_ON)
      Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadOnce = 0u;
#  endif
      Dcm_SetNegResponse(lNrc); /* Default value if nothing set in the application. */
      /* #100 Finish service processing immediately by sending the appropriate NRC. */
      return DCM_E_PROCESSINGDONE;
    }
#  if (DCM_DIDMGR_22_ACCESS_LOCK_ENABLED == STD_ON)
    Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadOnce = 0u;
#  endif
    /* #110 Move to the next DID data position. */
    Dcm_DiagMoveOnResWithLength(pMsgContext, Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidInfoContextPtr->DidLength);                      /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }

  --Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.NumDids;
  /* #120 If all DIDs were read: */
  if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.NumDids == 0)
  {
    /* #130 Send response and exit. */
    return DCM_E_PROCESSINGDONE;
  }

  /* #140 Otherwise start over reading the next DID. */
  Dcm_UtiNextItemByPtr(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidInfoContextPtr, 1u);

#  if (DCM_DIDMGR_22_ACCESS_LOCK_ENABLED == STD_ON)
  Dcm_RepeaterSetCallee(Dcm_Svc22CheckAccess);
#  endif
  return DCM_E_LOOP; /* Speed up processing. */
}                                                                                                                                                    /* PRQA S 2006, 6030 */ /* MD_Dcm_Optimize_2006, MD_MSR_STCYC */
# endif /* (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_OFF) */

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc22CopyPagedDataInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22CopyPagedDataInit(Dcm_MsgType pData
                                                                          ,Dcm_CfgNetBufferSizePtrType pAvailLen
                                                                          ,Dcm_CfgNetBufferSizePtrType pCurrAvailLen)
{
  Std_ReturnType lResult;

#  if (DCM_DIDMGR_22_ACCESS_LOCK_ENABLED == STD_ON)
  /* #10 If this DID is currently used by another service: */
  boolean  lIsAccessible;
  lIsAccessible = Dcm_Svc22IsDidAccessible(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidInfoContextPtr);

  if(lIsAccessible == FALSE)
  {
    /* #20 Try to read the DID the next task cycle. */
    lResult = DCM_E_PENDING;
  }
  else
#  endif
  {
#  if (DCM_DIDMGR_22_ACCESS_LOCK_ENABLED == STD_ON)
    Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadOnce = Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidInfoContextPtr->Did;
#  endif
    /* #40 If there is enough buffer space available to copy the ID of the DID: */
    if(*pCurrAvailLen >= 2u)
    {
      /* #50 Copy the ID. */
      pData[Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.ReadProgress + 0] = Dcm_UtiGetHiByte(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidInfoContextPtr->Did);
      pData[Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.ReadProgress + 1] = Dcm_UtiGetLoByte(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidInfoContextPtr->Did);

      Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.ReadProgress += 2u;
      *pCurrAvailLen -= 2u;
      Dcm_DidMgrGetOpClassInfo(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidInfoContextPtr, DCM_DIDMGR_OPTYPE_READ);
      lResult = DCM_E_OK;
    }
    else
    {
      /* #60 Otherwise try it the next task cycle. */
      *pAvailLen -= Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.ReadProgress; /* commit data */
      Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.ReadProgress = 0u; /* reset progress */
      lResult = DCM_E_BUFFERTOOLOW;
    }
  }

  return lResult;
}
# endif

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc22ReadDidPaged()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22ReadDidPaged(Dcm_MsgType pData
                                                                     ,Dcm_CfgNetBufferSizePtrType pAvailLen
                                                                     ,Dcm_CfgNetBufferSizePtrType pCurrAvailLen)
{
  Std_ReturnType lResult;
  Dcm_NegativeResponseCodeType lNrc;

  /* #10 Try to read the DID data. */
  lResult = Dcm_DidMgrRead(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.OpStatus
                          ,&(pData[Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.ReadProgress])
                          ,pCurrAvailLen
                          ,Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidInfoContextPtr
                          ,&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidOpTypeContext)
                          ,&lNrc);

#  if(DCM_DEV_ERROR_DETECT == STD_ON)
  if((Dcm_CfgNetBufferSizeOptType)(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.ReadProgress + *pCurrAvailLen) > *pAvailLen)
  {
    lResult = DCM_E_NOT_OK;
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_BUFFER_OVERFLOW);
  }
#  endif

  switch(lResult)
  {
#  if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
  case DCM_E_PENDING:
    /* #30 Try it the next task cycle. */
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.OpStatus = DCM_PENDING;
    /* Do not commit any data */
    break;
#  endif
  case DCM_E_BUFFERTOOLOW:
    /* #50 Notify the page buffer and try it later. */
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.OpStatus = DCM_PENDING;
    /* Commit data */
    *pAvailLen -= (Dcm_CfgNetBufferSizeOptType)(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.ReadProgress + *pCurrAvailLen);
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.ReadProgress = 0u;
    break;
  case DCM_E_OK:
    /* #70 Go on with next DID. */
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.OpStatus = DCM_INITIAL;
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.ReadProgress += (Dcm_CfgNetBufferSizeMemType)*pCurrAvailLen;
#  if (DCM_DIDMGR_22_ACCESS_LOCK_ENABLED == STD_ON)
    Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadOnce = 0u;
#  endif
    break;
  default: /* DCM_E_NOT_OK */
    /* #90 Finish service processing immediately by sending the appropriate NRC. */
#  if (DCM_DIDMGR_22_ACCESS_LOCK_ENABLED == STD_ON)
    Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadOnce = 0u;
#  endif
    Dcm_SetNegResponse(lNrc); /* Default value if nothing set in the application */
    break;
  }

  return lResult;
}
# endif
#endif /* (DCM_SVC_22_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27UtiGetAttemptCntr()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc27UtiGetAttemptCntr(Dcm_OpStatusType opStatus
                                                                ,P2VAR(uint32, AUTOMATIC, DCM_VAR_NOINIT) levelMask)
{
  Std_ReturnType  lResult;
  uint8           lAttemptCount;
  uint8_least     lSecLvlIter = 0u;
  uint32          lMask = *levelMask;

  /* #10 For each security level: */
  DCM_UTI_BIT_SCAN_LOOP(lMask)
  {
    /* #20 If the attempt counter for that specific security level is not already read: */
    if(Dcm_TskIsLocalEventSet(lMask, 0x01u))
    {
      /* #30 Try to read the attempt counter from the application. */
      lResult = Dcm_CfgSvc27SecLevelInfo[lSecLvlIter].GetAttemptCntrFunc(opStatus, &lAttemptCount);

      /* #40 If everything was ok: */
      if(lResult == DCM_E_OK)
      {
        /*
         * Note: Using critical sections is not neccessary here because the features "power on delay" and
         *       "external attempt counter storage" are used mutually exclusive per security level.
         */

        /* #50 Mark the security level to prevent that this API is called again. */
        Dcm_UtiBitOpClr(uint32, *levelMask, Dcm_UtiGetBitFromIndex(uint32, lSecLvlIter));

        /* #60 If the already initialized attempt counter has to be updated: */
        if(lAttemptCount != 0)
        {
          /* #70 Store the attempt counter. */
          Dcm_Svc27CounterSet(lSecLvlIter, lAttemptCount);

          /* #80 If the current attemt counter value exceeded the maximum number of allowed attempts: */
          if(lAttemptCount >= Dcm_CfgStateSecurityInfo[lSecLvlIter].NumAttempts)
          {
            /* #90 Set the delay timer value. The timer will be started later with that value. */
            Dcm_Svc27TimerSet(lSecLvlIter, Dcm_CfgStateSecurityInfo[lSecLvlIter].DelayTimeInvKey);                                                   /* PRQA S 3109 */ /* MD_MSR_14.3 */
          }
        }
      }/* #91 If more time needed: */
      else if (lResult == DCM_E_PENDING)
      {
        /* #92 Try it later. */
      }
      else /* #100 If something went wrong: */
      {
        Dcm_DebugApiCheckRte((lResult == DCM_E_NOT_OK), DCM_SID_GETSECURITYATTEMPTCOUNTER, DCM_E_INTERFACE_RETURN_VALUE)

        /* #110 Mark the security level to prevent that this API is called again. */
        Dcm_UtiBitOpClr(uint32, *levelMask, Dcm_UtiGetBitFromIndex(uint32, lSecLvlIter));

        /* #120 Reset the attempt counter. */
        Dcm_Svc27CounterReset(lSecLvlIter);

#  if (DCM_STATE_SEC_DELAY_TIME_ON_FAILED_GET_ATT_CNTR_ENABLED == STD_ON)
        /* #130 If delay time on failed read of attempt counter is enabled: */
        if(Dcm_CfgStateSecurityInfo[lSecLvlIter].ReloadOnZeroDelay == TRUE)
        {
          /* #140 If the configured delay time is zero: */
          if(Dcm_CfgStateSecurityInfo[lSecLvlIter].ReloadTime == 0u)
          {
            /* #150 Set the delay timer value to infinity. */
            Dcm_Svc27ReloadReadFailedSet(lSecLvlIter);
            Dcm_Svc27TimerSet(lSecLvlIter, 1u);                                                                                                      /* PRQA S 3109 */ /* MD_MSR_14.3 */
          }
          else
          {
            /* #160 Otherwise set the configured delay timer value. */
            Dcm_Svc27TimerSet(lSecLvlIter, Dcm_CfgStateSecurityInfo[lSecLvlIter].ReloadTime);                                                        /* PRQA S 3109 */ /* MD_MSR_14.3 */
          }
        }
#  endif
      }
    }
    ++lSecLvlIter;
  }
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27ReadAttemptCounter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_Svc27ReadAttemptCounter(Dcm_TskTaskEvOptType ev
                                                                                 ,Dcm_TskTaskEvPtrType pPostEv)
{
  Dcm_TskTaskEvOptType lResultEv = ev;

  /* #10 Restore the attempt counter values from the application. */
  Dcm_Svc27UtiGetAttemptCntr(Dcm_InstanceContext.Diag.Services.Svc27.GetAttOpStatus
                            ,&Dcm_InstanceContext.Diag.Services.Svc27.GetAttCntrEventMask);

  /* #20 If all attempt counters were read. */
  if(Dcm_InstanceContext.Diag.Services.Svc27.GetAttCntrEventMask == 0u)
  {
    DCM_SVC27_TMR_ITER_DEF

    DCM_SVC27_TMR_LOOP_FOR_UP
    {
      /* #30 If the corresponding security timer value is not zero: */
      if(Dcm_Svc27TimerGet(DCM_SVC27_TMR_ITER_VALUE) != 0u)
      {
        /* #40 Start the appropriate security timer. */
        Dcm_Svc27TimerStart(DCM_SVC27_TMR_ITER_VALUE);                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
      }
    }
    /* Reset operation status. */
    Dcm_InstanceContext.Diag.Services.Svc27.GetAttOpStatus = DCM_INITIAL;
  }
  else
  {
    /* #50 Otherwise resume the job next task cycle. */
    Dcm_TskSetLocalEvent(*pPostEv, ev);
    Dcm_InstanceContext.Diag.Services.Svc27.GetAttOpStatus = DCM_PENDING;
  }

  return lResultEv;
}
# endif

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27WriteAttemptCounter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_TskTaskEvOptType, DCM_CODE) Dcm_Svc27WriteAttemptCounter(Dcm_TskTaskEvOptType ev
                                                                                  ,Dcm_TskTaskEvPtrType pPostEv)
{
  Dcm_TskTaskEvOptType lResultEv = ev;

  /* #10 Notify the application about changed attempt counters. */
  Dcm_Svc27UtiSetAttemptCntr(Dcm_InstanceContext.Diag.Services.Svc27.SetAttOpStatus
                            ,&Dcm_InstanceContext.Diag.Services.Svc27.SetAttCntrEventMask);

  /* #20 If all attempt counters were written: */
  if(Dcm_InstanceContext.Diag.Services.Svc27.SetAttCntrEventMask == 0u)
  {
    /* #30 Finish the job. */
    Dcm_InstanceContext.Diag.Services.Svc27.SetAttOpStatus = DCM_INITIAL;
  }
  else
  {
    /* #40 Otherwise resume the job next task cycle. */
    Dcm_TskSetLocalEvent(*pPostEv, ev);
    Dcm_InstanceContext.Diag.Services.Svc27.SetAttOpStatus = DCM_PENDING;
  }

  return lResultEv;
}
# endif
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc28ApplyCommControl()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc28ApplyCommControl(Dcm_CfgNetNetIdRefMemType networkRef
                                                               ,Dcm_CommunicationModeType mode)
{
  DCM_IGNORE_UNREF_PARAM(networkRef);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if ((DCM_SVC_28_CURNET_SUPPORT_ENABLED == STD_ON) || \
     (DCM_SVC_28_SUBNET_SUPPORT_ENABLED == STD_ON) ) && \
     (DCM_NET_COMCTRL_ALLNET_SUPPORT_ENABLED == STD_ON)                                                                                              /* COV_DCM_SUPPORT_PARTIALLY TF tf xf tf */
  if(networkRef == DCM_SVC_28_NETWORK_ALL)
# endif
  {
# if (DCM_NET_COMCTRL_ALLNET_SUPPORT_ENABLED == STD_ON)
    uint8_least lChannelIter;

    for(lChannelIter = Dcm_PbCfgNetComCtrlChannelListAll[0]; lChannelIter != 0; --lChannelIter)
    {
      Dcm_ModeSwitchCommControl(Dcm_PbCfgNetComCtrlChannelListAll[lChannelIter], mode);
    }
# endif
  }
# if ((DCM_SVC_28_CURNET_SUPPORT_ENABLED == STD_ON) || \
     (DCM_SVC_28_SUBNET_SUPPORT_ENABLED == STD_ON) ) && \
     (DCM_NET_COMCTRL_ALLNET_SUPPORT_ENABLED == STD_ON)                                                                                              /* COV_DCM_SUPPORT_PARTIALLY TF tf xf tf */
  else
# endif
  {
# if (DCM_SVC_28_CURNET_SUPPORT_ENABLED == STD_ON) || \
     (DCM_SVC_28_SUBNET_SUPPORT_ENABLED == STD_ON)                                                                                                   /* COV_DCM_SUPPORT_PARTIALLY TF tf xf */
    Dcm_ModeSwitchCommControl(networkRef, mode);
# endif
  }
}
#endif /* (DCM_SVC_28_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdNextEntryIdxInc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdNextEntryIdxInc(void)
{
# if (DCM_SVC_2A_SCHEDULER_SIZE_CONST > 1)
  ++Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NextEntryIdx;
  if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NextEntryIdx >= DCM_SVC_2A_SCHEDULER_SIZE)
# endif
  {
    /* Write always zero (also when only one scheduler element exists, to keep the safe aspect when the wrap-around is detected */
    Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NextEntryIdx = 0u;
  }
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdUpdateTimers()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(boolean, DCM_CODE) Dcm_Svc2ASchdUpdateTimers(void)
{
  boolean doActivateProcessorTask = FALSE;
  Dcm_Svc2ASchdItemHandleOptType schdIter;

  for(schdIter = 0; schdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++schdIter)
  {
    if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdIter].Timer != 0u)
    {
      --Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdIter].Timer;
      if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdIter].Timer == 0u)
      {
        if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdIter].Rate < DCM_SVC2A_RATE_TYPE_STOPPED) /* is it scheduled ? */
        {
          doActivateProcessorTask = TRUE;
        }
      }
    }
  }
  return doActivateProcessorTask;
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdFindFreeOrInUseItemByDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(sint16_least, DCM_CODE) Dcm_Svc2ASchdFindFreeOrInUseItemByDid(uint16 did)
{
  Dcm_Svc2ASchdItemHandleOptType schdIter;
  sint16_least firstFreePos = -1;

  for(schdIter = 0; schdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++schdIter)
  {
    if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdIter].Rate == DCM_SVC2A_RATE_TYPE_STOPPED)
    {
      if(firstFreePos < 0)
      {
        firstFreePos = (sint16_least)schdIter;      /* reserve first found free slot */
      }/* else - already set */
    }
    else if(did == Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdIter].DidContext.Did)
    {
      firstFreePos = (sint16_least)schdIter; /* found already in used or just reserved DID -> use the same slot */
      break;
    }
    else
    {
      /* do nothing */
    }
  }
  return firstFreePos;
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdProcessEntry()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ASchdProcessEntry(Dcm_Svc2ASchdEntryPtrType pSchedTableEntry)
{
  boolean doSendData = FALSE;

  /* allocate buffer for response data */
  if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle == DCM_NET_INVALID_PTXOBJ_HANDLE)/* still nothing reserved for this DID ? */
  {
    Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle = Dcm_NetPeriodicMsgAllocate();
    if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle == DCM_NET_INVALID_PTXOBJ_HANDLE)
    {
      /* no free message buffer try again later */
      return DCM_E_PENDING; /* exit loop and task */
    }
  }

  /* Allocate DID manager resource */
  if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.DidContextPtr == NULL_PTR)
  {
# if (DCM_DIDMGR_2A_ACCESS_LOCK_ENABLED == STD_ON)
    uint16 lDid = pSchedTableEntry->DidContext.Did;

    if( (lDid == Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadOnce)
#  if (DCM_DIDMGR_2C_ACCESS_LOCK_ENABLED == STD_ON)
      ||(lDid == Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadDynamic)
#  endif
#  if (DCM_DIDMGR_PERIODICWRITEDID_ENABLED == STD_ON)
      ||(lDid == Dcm_InstanceContext.DidMgr.DidRsrcContext.Write)
#  endif
#  if (DCM_DIDMGR_PERIODICIODID_ENABLED == STD_ON)
      ||(lDid == Dcm_InstanceContext.DidMgr.DidRsrcContext.Io)
#  endif
      )
    {
      /* DID is currently locked - try again later */
      return DCM_E_PENDING; /* exit loop and task */
    }
    Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadPeriodic = lDid;
# endif
    Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.DidContextPtr = &(pSchedTableEntry->DidContext);
    /* prepare first time reading */
# if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
    Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.OpStatus = DCM_INITIAL;
# endif

    Dcm_NetPeriodicMsgGetTxBuffer(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle)[0] = Dcm_UtiGetLoByte(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.DidContextPtr->Did); /* copy did header */ /* PRQA S 0504 */ /* MD_Dcm_QacIssue_0504 */
  }

  /* read the response data */
  {
    Std_ReturnType               lStdResult;
    Dcm_NegativeResponseCodeType lNrc; /* unused since no NR possible */
    Dcm_CfgNetBufferSizeOptType  lAvailLen = (Dcm_CfgNetBufferSizeOptType)(DCM_NET_PERIODIC_BUFFER_SIZE - 1u);

    lStdResult = Dcm_DidMgrRead(Dcm_DidMgrWrapAsyncDidOpStatus(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.OpStatus)
                              ,&Dcm_NetPeriodicMsgGetTxBuffer(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle)[1]
                              ,&lAvailLen
                              ,Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.DidContextPtr
                              ,&(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.DidOpTypeContext)
                              ,&lNrc);
    if(lStdResult == DCM_E_OK)
    {
      doSendData = TRUE; /* now the response can be sent */
    }
    else
# if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
    if(lStdResult == DCM_E_PENDING)
    {
      Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.OpStatus = DCM_PENDING; /* prepare for next call */
      return DCM_E_PENDING;
    }
    else
# endif
    {
      /* DCM_E_NOT_OK */
      /* something went wrong - skip this DID */
    }
  }

  /* reload the period timer from now on (see ISO14229-1 SID 0x2A scheduler example) */
  /*
    * No critical section for split tasks needed since:
    * - The timer that just has been processed is already stopped and will not be decrement in the Dcm_Svc2ASchdUpdateTimers utility.
    * - This tasks is a low-priority one and cannot interrupt the timer task (Dcm_OnTimeoutSvc2AScheduler). So setting a non-zero value will not be an issue.
    */
  pSchedTableEntry->Timer = Dcm_Svc2AGetSchedulingTimeOfEntry(pSchedTableEntry);

  /* Finish scheduled job */
  Dcm_Svc2ASchdFinishEntryProcessing(doSendData);

  return DCM_E_OK;
}                                                                                                                                                    /* PRQA S 2006 */ /* MD_Dcm_Optimize_2006 */
/**********************************************************************************************************************
 *  Dcm_Service2ASchedulerInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Service2ASchedulerInit(void)
{
  Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.DidContextPtr      = NULL_PTR;
  Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries = 0u;
  Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NextEntryIdx = 0u;
  Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle = DCM_NET_INVALID_PTXOBJ_HANDLE;

  {
    Dcm_Svc2ASchdItemHandleOptType schdIter;

    for(schdIter = 0; schdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++schdIter)
    {
      Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdIter].Timer = 0u;
      Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdIter].Rate = DCM_SVC2A_RATE_TYPE_STOPPED;
    }
  }
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdAddItemByDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdAddItemByDid(Dcm_DidMgrDidInfoContextPtrType pDidInfoContext)                                     /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  sint16_least schdHandle;
  schdHandle = Dcm_Svc2ASchdFindFreeOrInUseItemByDid(pDidInfoContext->Did);
  /* there shall always be free room when this function is called, otherwise check the SID 0x2A processor */
  Dcm_DebugAssert((schdHandle >=0), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                           /* COV_DCM_RTM_DEV_DEBUG XF */

  Dcm_UtiAssignStruct(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdHandle].DidContext                                                 /* PRQA S 0310 */ /* MD_Dcm_GenericStructAssign_0310 */
                     ,*pDidInfoContext
                     ,Dcm_DidMgrDidInfoContextType);                                                                                                 /* PRQA S 3109 */ /* MD_Dcm_CfgDepend_3109 */
  Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdHandle].Rate |= DCM_SVC2A_RATE_TYPE_RESERVED;
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdCommit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdCommit(Dcm_Svc2ASchedRateMemType rate)
{
  Dcm_Svc2ASchdItemHandleOptType schdIter;

  Dcm_SplitTaskEnterCS();/* protect against timer task update */                                                                                     /* PRQA S 3109 */ /* MD_MSR_14.3 */

  for(schdIter = 0; schdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++schdIter)
  {
    if((Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdIter].Rate & DCM_SVC2A_RATE_TYPE_RESERVED) != 0)
    {
      if((Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdIter].Rate & DCM_SVC2A_RATE_TYPE_STOPPED) != 0)
      {
        ++Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries; /* update statistic of first activation of this DID */
      }
      /* must not exceed the scheduler size */
      Dcm_DebugAssert((Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries <= DCM_SVC_2A_SCHEDULER_SIZE), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE) /* COV_DCM_RTM_DEV_DEBUG XF */
      Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdIter].Rate = rate; /* set the new rate. */
      Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdIter].Timer = 0u; /* enforce immediate timeout */
    }
  }
  Dcm_SplitTaskLeaveCS();                                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */

  if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries != 0u)
  {
# if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
    Dcm_TmrStartTimer(DCM_TMR_ID_SVC2A_SCHEDULER, 1u);/* start timer updater */
# endif
    Dcm_TskSetEvent(DCM_TSK_ID_SVC2A_SCHEDULER, (Dcm_TskTaskEvMemType)(DCM_TSK_EV_SVC2A_SCHEDULER_TMR_UPD|DCM_TSK_EV_SVC2A_SCHEDULER_PROCESS));/* start updating the timers/processing new DIDs */
  }
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdDiscard()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2ASchdDiscard(void)
{
  Dcm_Svc2ASchdItemHandleOptType schdIter;

  for(schdIter = 0; schdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++schdIter)
  {
    Dcm_UtiBitOpClr(Dcm_Svc2ASchedRateMemType, Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdIter].Rate, DCM_SVC2A_RATE_TYPE_RESERVED); /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
  }
}
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc2AStopScheduledDids()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AStopScheduledDids(Dcm_MsgContextPtrType pMsgContext)                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdReturn = DCM_E_PROCESSINGDONE;
  if(pMsgContext->reqDataLen == 0u)
  {
    Dcm_Svc2ASchdStopAll();
  }
  else
  {
    Dcm_RepeaterSetCallee(Dcm_Svc2AStoppedDidLookUp); /* delegate job */
    lStdReturn = DCM_E_LOOP;/* speed up processing */
  }

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc2ADoScheduleDids()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADoScheduleDids(Dcm_MsgContextPtrType pMsgContext)                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdReturn = DCM_E_PROCESSINGDONE;

  if(pMsgContext->reqDataLen == 0) /* no DID available in the request */
  {
    Dcm_SetNegResponse(DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT);
  }
  else if(pMsgContext->reqDataLen > Dcm_Svc2ASchdGetFreeSpace())  /* not enough room in the scheduler table (don't consider duplicates and unsupported DIDs in the request -> apply KISS) */
  {
    Dcm_SetNegResponse(DCM_E_REQUESTOUTOFRANGE);
  }
  else
  {
    Dcm_RepeaterSetCallee(Dcm_Svc2AScheduledDidLookUp); /* delegate job */
    lStdReturn = DCM_E_LOOP;/* speed up processing */
  }

  /* Reaching this point means diagnostic error was found */
  return lStdReturn;
}
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2CDefMgrInit(void)
{
  Dcm_CfgDidMgrDynDidHandleOptType dynDidIter;

  for(dynDidIter = 0; dynDidIter < DCM_NUM_DYNDIDS; ++dynDidIter)
  {
    Dcm_InstanceContext.Diag.Services.Svc2C.Items[dynDidIter].Length = 0u;
    Dcm_InstanceContext.Diag.Services.Svc2C.Items[dynDidIter].Count  = 0u;
  }

# if (DCM_DIDMGR_DYNDID_ASYNC_SUPPORT_ENABLED == STD_ON)
  Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.DynDidHandleInUse = DCM_SVC2C_INVALID_DYNDID_HDL;
# endif
# if(DCM_DEV_ERROR_REPORT == STD_ON)
  Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.Buffer[DCM_SVC_2C_READ_BUFFER_SIZE + 0] = Dcm_UtiGetHiByte(DCM_DEBUG_BUFFEROVFLPATTERN);
  Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.Buffer[DCM_SVC_2C_READ_BUFFER_SIZE + 1] = Dcm_UtiGetLoByte(DCM_DEBUG_BUFFEROVFLPATTERN);
# endif
}

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C01DefMgrRead()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C01DefMgrRead(Dcm_OpStatusType opStatus
                                                                     ,Dcm_CfgNetBufferSizePtrType pCopyOffset
                                                                     ,Dcm_CfgNetBufferSizePtrType pCopyLength)
{
  Std_ReturnType lStdResult;

#  if (DCM_DIDMGR_2C_ACCESS_LOCK_ENABLED == STD_ON)
  lStdResult = DCM_E_OK;

  if(Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadDynamic == 0u)
  {
#   if (DCM_SVC_2C_CANCELOP_READ_ENABLED == STD_ON)
    if(opStatus == DCM_CANCEL)
    {
      /* we have waited for too long to get access to the DID reader, but it was canceled -> Stop here since no reading has been started yet */
      lStdResult = DCM_E_NOT_OK;
    }
    else
#   endif
    /* Check for access rights (avoids race conditions) */
    if( (Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemInProgress].DidDescriptor.DidContext.Did == Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadPeriodic)
#   if (DCM_DIDMGR_2E_ACCESS_LOCK_ENABLED == STD_ON)
      ||(Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemInProgress].DidDescriptor.DidContext.Did == Dcm_InstanceContext.DidMgr.DidRsrcContext.Write )
#   endif
#   if (DCM_DIDMGR_22_ACCESS_LOCK_ENABLED == STD_ON)
      ||(Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemInProgress].DidDescriptor.DidContext.Did == Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadOnce )
#   endif
#   if (DCM_DIDMGR_2F_ACCESS_LOCK_ENABLED == STD_ON)
      ||(Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemInProgress].DidDescriptor.DidContext.Did == Dcm_InstanceContext.DidMgr.DidRsrcContext.Io )
#   endif
      /* no periodic DID is a writable or IO DID -> no need to check for race conditions! */
      )
    {
      lStdResult = DCM_E_PENDING;
    }
    else
    {
      /* Continue processing of source item. */
      Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadDynamic = Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemInProgress].DidDescriptor.DidContext.Did;
      opStatus = DCM_INITIAL; /* prepare for first reading */
    }
  }

  if(lStdResult == DCM_E_OK)
#  endif
  {
    Dcm_NegativeResponseCodeType lNrc;
    Dcm_CfgNetBufferSizeOptType  lAvailLen = DCM_SVC_2C_READ_BUFFER_SIZE;

    Dcm_DidMgrGetOpClassInfo(&(Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemInProgress].DidDescriptor.DidContext)
                            ,DCM_DIDMGR_OPTYPE_READ);

    lStdResult = Dcm_DidMgrRead(opStatus
                              ,Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.Buffer
                              ,&lAvailLen
                              ,&(Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemInProgress].DidDescriptor.DidContext)
                              ,&(Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].DidOpTypeContext)
                              ,&lNrc);

    Dcm_DebugAssert((  (Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.Buffer[DCM_SVC_2C_READ_BUFFER_SIZE + 0] == Dcm_UtiGetHiByte(DCM_DEBUG_BUFFEROVFLPATTERN))
                     &&(Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.Buffer[DCM_SVC_2C_READ_BUFFER_SIZE + 1] == Dcm_UtiGetLoByte(DCM_DEBUG_BUFFEROVFLPATTERN)) )
                    ,DCM_SID_SVCPORT_DATASVCS_OP_READDATA_ASYNC
                    ,DCM_E_ILLEGAL_STATE)                                                        /* no data has been overwritten */

    /* Finished processing a DIDSrcItem */
    if(lStdResult != DCM_E_PENDING)
    {
      *pCopyOffset = Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemInProgress].DidDescriptor.Offset;
      *pCopyLength = Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemInProgress].DidDescriptor.Size;
#  if (DCM_DIDMGR_2C_ACCESS_LOCK_ENABLED == STD_ON)
      Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadDynamic = 0u;
#  endif
    }
  }

  return lStdResult;
}
# endif

# if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C02DefMgrRead()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C02DefMgrRead(Dcm_OpStatusType opStatus
                                                                     ,Dcm_CfgNetBufferSizePtrType pCopyOffset
                                                                     ,Dcm_CfgNetBufferSizePtrType pCopyLength)
{
  Std_ReturnType lStdResult;

#  if (DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
  lStdResult = DCM_E_OK;

  if(Dcm_InstanceContext.MemMgr.LockedByClient == DCM_MEMMGR_ACCESS_REQ_INT)
  {
    /* Proceed with reading */
  }
  else
  {
    /* Still in process getting access! */
#   if (DCM_SVC_2C_CANCELOP_READ_ENABLED == STD_ON)
    if(opStatus == DCM_CANCEL)
    {
      lStdResult = DCM_E_NOT_OK;/* we have waited for too long to get access to the memory reader, but it was canceled -> Stop here since no reading has been started yet */
    }
    else
#   endif
    {
      if(Dcm_InstanceContext.MemMgr.LockedByClient == DCM_MEMMGR_ACCESS_NONE)
      {
        Dcm_InstanceContext.MemMgr.LockedByClient = DCM_MEMMGR_ACCESS_REQ_INT;
        opStatus = DCM_INITIAL; /* prepare for first reading */
      }
      else /* DCM_MEMMGR_ACCESS_REQ_EXT */
      {
        lStdResult = DCM_E_PENDING;
      }
    }
  }

  if(lStdResult == DCM_E_OK)
#  endif
  {
    Dcm_NegativeResponseCodeType lNrc;

    lNrc = DCM_E_GENERALREJECT;
    lStdResult = Dcm_MemMgrReadMemory(opStatus
                                    ,&(Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemInProgress].MemDescriptor.MemBlock)
                                    ,Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.Buffer
                                    ,&lNrc);

    if( (lStdResult != DCM_E_PENDING)
      &&(lStdResult != DCM_E_FORCE_RCRRP))
    {
      /* OK/NOT_OK -> proceed */
      *pCopyOffset = 0u;
      *pCopyLength = (Dcm_CfgNetBufferSizeOptType)Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemInProgress].MemDescriptor.MemBlock.Length; /*safe cast sin the code has already checked for overflows at DID definition time */
    }

    DCM_IGNORE_UNREF_PARAM(lNrc);                                                                                                                    /* PRQA S 3112 */ /* MD_Dcm_3112 */
  }

  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrReadSrcItems()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CDefMgrReadSrcItems(Dcm_OpStatusType opStatus)
{
  Std_ReturnType lStdReturn;

  Dcm_CfgNetBufferSizeOptType copyOffset = 0;
  Dcm_CfgNetBufferSizeOptType copyLength = 0;

  do
  {
# if (DCM_SVC_2C_HYBRID_MODE_ENABLED == STD_ON)
    if(Dcm_Svc2CIsDidSrcItem(Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemInProgress))
# endif
    {
# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
     /*-----------------------------------------------*
      * DID source item processing
      *-----------------------------------------------*/
      lStdReturn = Dcm_Svc2C01DefMgrRead(opStatus, &copyOffset, &copyLength);
# endif
    }
# if (DCM_SVC_2C_HYBRID_MODE_ENABLED == STD_ON)
    else
# endif
    {
# if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
      /*-----------------------------------------------*
       * Memory source item processing
       *-----------------------------------------------*/
      lStdReturn = Dcm_Svc2C02DefMgrRead(opStatus, &copyOffset, &copyLength);
# endif
    }

    /*-----------------------------------------------*
     * Common source item processing
     *-----------------------------------------------*/
    if(lStdReturn == DCM_E_OK)
    {
      /* extract and place data */
      Dcm_UtiMemCopy(&Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.Buffer[copyOffset]
                     ,Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ResData
                     ,copyLength);                                                                                                                   /* PRQA S 3109 */ /* MD_MSR_14.3 */

      /* prepare for next portion */
      Dcm_UtiNextItemByPtr(Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ResData, copyLength);

      /*-----------------------------------------------*
       * Loop end condition
       *-----------------------------------------------*/
      ++Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemInProgress;
      if(Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemInProgress >= Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemToStop)
      {
        break;
      }
      /* prepare for next item */
      opStatus = DCM_INITIAL;
    }/* else just delegate the return value */
  }
  while(lStdReturn == DCM_E_OK);

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrReadCheckAccessAndInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CDefMgrReadCheckAccessAndInit(
                                                              Dcm_CfgDidMgrDynDidHandleMemType dynDidHandle
                                                             ,P2VAR(Dcm_OpStatusType, AUTOMATIC, AUTOMATIC) pOpStatus)                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult = DCM_E_OK;

  DCM_IGNORE_UNREF_PARAM(dynDidHandle);                                                                                                              /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pOpStatus);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */
  /*-----------------------------------------------*
   * DynDID usage check and initialization
   *-----------------------------------------------*/
# if (DCM_DIDMGR_DYNDID_ASYNC_SUPPORT_ENABLED == STD_ON)
  if(Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.DynDidHandleInUse == DCM_SVC2C_INVALID_DYNDID_HDL)
  {
#  if (DCM_SVC_2C_CANCELOP_READ_ENABLED == STD_ON)
    if(*pOpStatus == DCM_CANCEL)
    {
      lStdResult = DCM_E_NOT_OK;/* we have waited for too long to get access to the DynDID reader, but it was canceled -> Stop here since no reading has been started yet */
    }
    else
#  endif
    {
      *pOpStatus = DCM_INITIAL;/* Reset opStatus in case some DCM_E_PENDING had to be returned due to concurrent access (i.e. 0x22 and 0x2A for different DDDIDs)*/
    }
  }
  else
  {
#  if (DCM_SVC_2C_RACE_CONDITION_READ_ENABLED == STD_ON)
    if(dynDidHandle != Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.DynDidHandleInUse)
    {
      lStdResult = DCM_E_PENDING;
    }/* else - same handle -> process it */
#  endif
  }
# endif
  return lStdResult;
}
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc2FReturnControlToEcu()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FReturnControlToEcu(void)
{
# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
  if(Dcm_InstanceContext.Diag.Services.Svc2F.HasAnyActiveIoDid == TRUE)
  {
    Dcm_InstanceContext.Diag.Services.Svc2F.HasAnyActiveIoDid = FALSE;
    {
      P2VAR(Dcm_UtiBitSetBaseType, AUTOMATIC, DCM_VAR_NOINIT) pActiveIoDids = Dcm_InstanceContext.Diag.Services.Svc2F.ActiveIoDids;
      Dcm_CfgDidMgrDidOpClassHandleOptType opInfoRefPage = 0;
      Dcm_CfgDidMgrIoDidHandleOptType ioDidIter = Dcm_UtiGenericBitSetCalcSize(DCM_NUM_IODIDS_CONST);

      for(; (ioDidIter != 0u); --ioDidIter)
      {
        Dcm_CfgDidMgrDidOpClassHandleOptType opInfoRef = opInfoRefPage;
        DCM_UTI_BIT_SCAN_LOOP(*pActiveIoDids)
        {
          if((*pActiveIoDids & 0x01u) != 0)
          {
            Dcm_DidMgrIoControlRtrnCtrl2Ecu(Dcm_DidMgrGetCtrlOpInfoRef(opInfoRef));
          }
          ++opInfoRef;
        }
        Dcm_UtiNextItemByPtr(pActiveIoDids, 1u);
        opInfoRefPage += (Dcm_CfgDidMgrDidOpClassHandleOptType)Dcm_UtiGetNumBitsOfXintType(Dcm_UtiBitSetBaseType);/* next bunch of IoDids */
      }
    }
  }
# endif
}

# if (DCM_DIDMGR_OPCLS_IO_ANY_WITH_EXT_CEMR_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FExtractCEMR()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(uint32, DCM_CODE) Dcm_Svc2FExtractCEMR(Dcm_ReadOnlyMsgType                 cemrStream
                                                            ,Dcm_CfgDidMgrIoDidCemrLengthMemType cemrSize)
{
  uint32 lResult = 0;

  if(cemrSize <= 4)
  {
    Dcm_CfgDidMgrIoDidCemrLengthOptType lCemrIter;

    /* Extract byte-wise the CEMR */
    for( lCemrIter = 0; lCemrIter < cemrSize; ++lCemrIter)
    {
      lResult <<= 8u;
      lResult |= cemrStream[lCemrIter];
    }

    /* For a 3 byte CEMR a 32bit value will be passed -> move to the MSB to fulfill the IO C/S API convention */
    if(cemrSize == 3)
    {
      lResult <<= 8u;
    }
  }/* else - leave the result = 0 (invalid value) */

  return lResult;
}
# endif

# if (DCM_DIDMGR_IO_MASKRECORD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FProcessCEMR()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FProcessCEMR(Dcm_MsgContextPtrType pMsgContext)                                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_CfgDidMgrIoDidCemrLengthMemType lCemrSize;

  /* Consider requests with and without CEMR */

  lCemrSize = Dcm_DidMgrGetCtrlEnblMaskLength(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidInfoContext.Descriptor.DidInfoPtr);

  if(lCemrSize != 0)
  {
    /* Subtract CEMR length from request length to get only the requested DID size in order to get the concrete length of the last DID signal (if variable length). */
    Dcm_DiagUpdateReqLength(pMsgContext, lCemrSize);
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidOpTypeContext.OpType.Io.EnableMaskPtr = &(pMsgContext->reqData[pMsgContext->reqDataLen]);

#  if (DCM_DIDMGR_OPCLS_IO_ANY_WITH_EXT_CEMR_ENABLED == STD_ON)
    /* Extract CEMR as a value */
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidOpTypeContext.OpType.Io.ControlEnableMaskRecord = Dcm_Svc2FExtractCEMR(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidOpTypeContext.OpType.Io.EnableMaskPtr
                                                                                                                                 ,lCemrSize);
#  endif
  }
  else
  {
    /*else - the request does not contain any CEMR */
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidOpTypeContext.OpType.Io.EnableMaskPtr = NULL_PTR;
  }
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2FCalculateExpectedReqLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(void, DCM_CODE) Dcm_Svc2FCalculateExpectedReqLength(Dcm_DidMgrDidLengthPtrType expLengthMin
                                                                         ,Dcm_DidMgrDidLengthPtrType expLengthMax)
{
# if (DCM_DIDMGR_OPTYPE_IO_SHRTTERMADJ_ENABLED == STD_ON)
  if((Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.OpType & DCM_DIDMGR_OPTYPE_IO_SHRTTRMADJ) != 0)
  {
    /* short term adjustment - consider optional enable mask record and the DID data! */
    *expLengthMax = Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidInfoContext.Descriptor.DidInfoPtr->Length;
#  if (DCM_DIDMGR_IODID_DYNLEN_ENABLED == STD_ON)
    *expLengthMin = Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidInfoContext.Descriptor.DidInfoPtr->MinLength;
    if(*expLengthMin == 0) /* If IO DID with dynamic length AND single signal... */
    {
#   if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_RES_NCEMR_ERROR_ENABLED == STD_ON)
      /* Non-"Supported IDs" must have at least one request data byte! */
      if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidInfoContext.Descriptor.DidSignalOpClassInfoPtr->FuncClass != DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_RES_NCEMR_ERROR)
#   endif
      {
        ++(*expLengthMin); /* ... minimum lenght is one byte! */
      }
    }
#  else
    /* Constant IODID length -> min == max */
    *expLengthMin = *expLengthMax;
#  endif
  }
  else
# endif
  {
    *expLengthMin = 0u; /* no data */
    *expLengthMax = 0u; /* no data */
  }

  *expLengthMin += Dcm_DidMgrGetCtrlEnblMaskLength(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidInfoContext.Descriptor.DidInfoPtr);
  *expLengthMax += Dcm_DidMgrGetCtrlEnblMaskLength(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidInfoContext.Descriptor.DidInfoPtr);
}

/**********************************************************************************************************************
 *  Dcm_Svc2FCheckReqLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_Svc2FCheckReqLength(Dcm_MsgContextPtrType pMsgContext)                             /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_NegativeResponseCodeType lNrc = DCM_E_POSITIVERESPONSE;
  Dcm_DidMgrDidLengthType      expMinReqLen;
  Dcm_DidMgrDidLengthType      expMaxReqLen;

  Dcm_Svc2FCalculateExpectedReqLength(&expMinReqLen, &expMaxReqLen);

  /* Check DID specific length */
  if( (pMsgContext->reqDataLen < expMinReqLen)
    ||(pMsgContext->reqDataLen > expMaxReqLen) )
  {
    lNrc = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
  }

  return lNrc;
}

/**********************************************************************************************************************
 *  Dcm_Svc2FIoDidOperationProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL_INLINE FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FIoDidOperationProcessor(Dcm_MsgContextPtrType pMsgContext)                                  /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType  lStdResult;
  Dcm_NegativeResponseCodeType lNrc;

  /* Initialize the IO-Control operation class from now for any checks that may come
   * (i.e. within Dcm_Svc2FCheckReqLength or later for the IO Control execution)  */
  Dcm_DidMgrGetOpClassInfo(&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidInfoContext)
                            ,Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.OpType);

  /* Validate request length */
  lNrc = Dcm_Svc2FCheckReqLength(pMsgContext);

  if(lNrc == DCM_E_POSITIVERESPONSE)
  {
    /* Validate remaining state preconditions */
    lNrc = Dcm_DidMgrStaticDidStateCheck(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidInfoContext.Descriptor.DidOpInfoPtr->ExecCondRef);
    if(lNrc == DCM_E_POSITIVERESPONSE)
    {
# if (DCM_DIDMGR_IO_MASKRECORD_ENABLED == STD_ON)
      /* Process any eventually supported CEMR */
      Dcm_Svc2FProcessCEMR(pMsgContext);
# endif
# if (DCM_DIDMGR_2F_ACCESS_LOCK_ENABLED == STD_ON)
      Dcm_RepeaterSetCallee(Dcm_Svc2FCheckAccess); /* delegate job */
# else
      Dcm_RepeaterSetCallee(Dcm_Svc2FExecuteOp); /* delegate job */
# endif
      lStdResult = DCM_E_LOOP;/* speed up processing */
    }
    else
    {
      /* lNrc already set */
      Dcm_SetNegResponse(lNrc);
      lStdResult = DCM_E_PROCESSINGDONE;
    }
  }
  else
  {
    Dcm_SetNegResponse(lNrc);
    lStdResult = DCM_E_PROCESSINGDONE;
  }
  return lStdResult;
}
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
/*lint -save -esym(961, 19.1)*/
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore*/
/* ----------------------------------------------
 ~&&&   Module internal function implementations
---------------------------------------------- */
#define DCM_START_SEC_CODE
/*lint -save -esym(961, 19.1)*/
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore*/
#if (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_MemMgrCheckMemBlock()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_MemMgrCheckMemBlock(Dcm_MemMgrMemBlockPtrType pMemBlock                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                              ,Dcm_MemMgrMemoryOpType memOp)
{
  Dcm_CfgMemMgrMemMapInfoPtrType pUsedMemMap;
  Dcm_CfgMemMgrMemMapIdxOptType  memMapSize;

# if (DCM_MEMMGR_MID_SUPPORT_ENABLED == STD_ON)
  {
    sint16_least midIdx = Dcm_UtiLookUpUint8(Dcm_CfgMemMgrMidLookUpTable, pMemBlock->Mid);
    if(midIdx < 0)
    {
      return DCM_E_REQUESTOUTOFRANGE;
    }/* else - the mid is supported */
#  if (DCM_MEMMGR_MULTIMID_SUPPORT_ENABLED == STD_ON)
    pUsedMemMap = Dcm_CfgMemMgrMidInfo[midIdx].MemMapTable;
    memMapSize  = Dcm_CfgMemMgrMidInfo[midIdx].Size;
#  else
    pUsedMemMap = Dcm_CfgMemMgrMemMap;
    memMapSize  = DCM_MEMMGR_MEMMAP_NUM_ENTRIES;
#  endif
  }
# else
  pUsedMemMap = Dcm_CfgMemMgrMemMap;
  memMapSize  = DCM_MEMMGR_MEMMAP_NUM_ENTRIES;
# endif

  /*--- Inlined check memory range */
  {
    Dcm_CfgMemMgrReqAddrType       reqEndAddress;

    reqEndAddress = (Dcm_CfgMemMgrReqAddrType)(pMemBlock->Address + (Dcm_CfgMemMgrReqSizeType)(pMemBlock->Length - 1u)); /* possible overflows does not take any effect for now */

    /* Check for address overflow or no data required (length == 0)*/
    if( (pMemBlock->Length != 0u)
      &&(reqEndAddress >= pMemBlock->Address) )
    {
      Dcm_NegativeResponseCodeType   lNrc = DCM_E_POSITIVERESPONSE;
      Dcm_CfgMemMgrMemMapIdxOptType  memMapIter = 0;
      Dcm_CfgMemMgrMemAddrType       lastEndAddr = pUsedMemMap->EndAddr;
      boolean                        isBlockBeginFound = FALSE;

      for(;memMapIter < memMapSize;++memMapIter)
      {
        if(pUsedMemMap->EndAddr >= pMemBlock->Address)/* first block that may contain the requested range */
        {
          if(isBlockBeginFound == FALSE)
          {
            isBlockBeginFound = TRUE;
            if(pUsedMemMap->StartAddr > pMemBlock->Address)/* the start address must be within the configured block  */
            {
              break; /* return DCM_E_REQUESTOUTOFRANGE - the requested start address is not belonging to the memory block */
            }/* else - OK, let's analyze the other properties of the configuration block */
          }
          else /* scanning subsequent blocks */
          {
            ++lastEndAddr;/* prepare for the potential next concatenated range startAddr */
            if(pUsedMemMap->StartAddr != lastEndAddr)      /* no concatenated ranges */
            {
              break; /* return DCM_E_REQUESTOUTOFRANGE */                                                                                            /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
            }/* else - the end address block was not found yet, check this range borders and conditions */
          }

          if( (pUsedMemMap->ExecCondRefs[memOp] == 0u) /* memory operation supported for this block in currently active variant(s) ? */
# if(DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)
            ||(Dcm_VarMgrIsEnabledInActiveVariants((Dcm_CfgStateRefOptType)(pUsedMemMap->ExecCondRefs[memOp] - 1u)) == FALSE)
# endif
            )
          {
            break; /* return DCM_E_REQUESTOUTOFRANGE */                                                                                              /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
          }/* else - range supports operation - go on with state checks */

          if(lNrc == DCM_E_POSITIVERESPONSE) /* still no error found */
          {
            lNrc = Dcm_StateCheck((Dcm_CfgStateRefOptType)(pUsedMemMap->ExecCondRefs[memOp] - 1u), DCM_DIAG_CHK_LVL_PARAMETER);
          }/* else - lNrc already set, let see if the range is at least OK */

          if(((Dcm_CfgMemMgrReqAddrType)pUsedMemMap->EndAddr) >= reqEndAddress)
          {
            return lNrc; /* either POS_RES or first condition error */
          }/* else - try next range (if any still available) */
          lastEndAddr = pUsedMemMap->EndAddr;/* update for next iteration */
        }/* else - not reached a range from the bottom */
        Dcm_UtiNextItemByPtr(pUsedMemMap, 1u);
      }/* no valid range found */
    }/* else - length == 0 or req_addr > blockEnd */
  }
  return DCM_E_REQUESTOUTOFRANGE;
}                                                                                                                                                    /* PRQA S 2006, 6030, 6080 */ /* MD_Dcm_Optimize_2006, MD_MSR_STCYC, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_MemMgrExecuteMemoryOperation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_MemMgrExecuteMemoryOperation(Dcm_MemMgrOpFuncType memOpFunc
                                                                         ,Dcm_OpStatusType opStatus
                                                                         ,Dcm_MemMgrMemBlockPtrType pMemBlock                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                         ,Dcm_MsgType data
                                                                         ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Dcm_MemMgrOpResultType memOpResult;
  Std_ReturnType lStdResult;
  Dcm_NegativeResponseCodeType lNrc;

  lNrc = *ErrorCode;
  *ErrorCode = DCM_E_POSITIVERESPONSE;

  memOpResult = memOpFunc(opStatus
# if (DCM_MEMMGR_MID_SUPPORT_ENABLED == STD_ON)
                         ,pMemBlock->Mid
# else
                         ,0u
# endif
                         ,pMemBlock->Address
                         ,pMemBlock->Length
                         ,data
# if (DCM_DCM_AR_VERSION >= DCM_DCM_AR_VERSION_422)
                         ,ErrorCode
# endif
                         );

# if (DCM_DIAG_CANCEL_OP_ENABLED     == STD_ON) && \
     (DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
  if (opStatus == DCM_CANCEL)
  {
    lStdResult = DCM_E_NOT_OK;
    *ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
  }
  else
# endif
  {
    switch(memOpResult)
    {
    case DCM_MEMMGR_OP_RSLT_OK:
      lStdResult = DCM_E_OK;
      break;
    case DCM_MEMMGR_OP_RSLT_PENDING:
      lStdResult = DCM_E_PENDING;
      break;
    case DCM_MEMMGR_OP_RSLT_FORCE_RCRRP:
      lStdResult = DCM_E_FORCE_RCRRP;
      break;
    default: /* DCM_MEMMGR_OP_RSLT_FAILED */
      lStdResult = DCM_E_NOT_OK;
# if(DCM_DEV_ERROR_REPORT == STD_ON)
      if(memOpResult != DCM_MEMMGR_OP_RSLT_FAILED)
      {
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
      }
# endif
# if (DCM_DCM_AR_VERSION < DCM_DCM_AR_VERSION_422)
      *ErrorCode = lNrc; /* restore default NRC */
# endif
      break;
    }
  }

# if (DCM_DCM_AR_VERSION >= DCM_DCM_AR_VERSION_422)
  Dcm_DiagHandleApplNrc(lStdResult, ErrorCode, lNrc);                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
# endif

# if (DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
  if( (lStdResult != DCM_E_PENDING)
    &&(lStdResult != DCM_E_FORCE_RCRRP))
  {
    /* Release resource */
    Dcm_InstanceContext.MemMgr.LockedByClient = DCM_MEMMGR_ACCESS_NONE;
  }
# endif
  return lStdResult;
}
/**********************************************************************************************************************
 *  Dcm_MemMgrValidateAlfid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_MemMgrValidateAlfid(Dcm_MsgType streamData                                                /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                              ,Dcm_MsgLenPtrType pStreamLength)
{
  Dcm_NegativeResponseCodeType lNrc;

  if(*pStreamLength != 0u)
  {
    /* else - at least one byte for ALFID is available */
    uint8 addrSize = Dcm_MemMgrGetMemBlockAddrSize(*streamData);
    uint8 lenSize  = Dcm_MemMgrGetMemBlockLenSize(*streamData);
    uint8 headLen  = (uint8)(addrSize + lenSize + 1u); /* (ALFID + memory address + memory size) */

# if (DCM_MEMMGR_ALFID_RESTRICTION_ENABLED == STD_ON)
    if(Dcm_UtiLookUpUint8(Dcm_CfgMemMgrAlfidLookUpTable, *streamData) < 0)
# else
#  if (DCM_MEMMGR_MID_SUPPORT_ENABLED == STD_ON)
    --addrSize; /* subtract the MID from the real address carrier */
#  endif
    if(
#  if (DCM_MEMMGR_MID_SUPPORT_ENABLED == STD_ON)
      (addrSize < 1u)  /* a request with only a MID does not make any sense! */
#  else
      (addrSize == 0u)
#  endif
      ||((uint8)sizeof(Dcm_CfgMemMgrReqAddrType) < addrSize)
      ||(lenSize == 0u)  || ((uint8)sizeof(Dcm_CfgMemMgrReqSizeType) < lenSize ) )
# endif
    {
      lNrc = DCM_E_REQUESTOUTOFRANGE;
    }
    else if(headLen <= *pStreamLength)
    {
      *pStreamLength -= headLen; /* extract the length */
      lNrc = DCM_E_POSITIVERESPONSE;
    }
    else
    {
      lNrc = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
    }
  }
  else
  {
    lNrc = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
  }

  return lNrc;
}

/**********************************************************************************************************************
 *  Dcm_MemMgrParseAlfid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_MsgType, DCM_CODE) Dcm_MemMgrParseMemStream(uint8 alfid
                                                              ,Dcm_MsgType streamData
                                                              ,Dcm_MemMgrMemBlockPtrType pMemBlock)
{
  uint8_least iter;
  uint32 dwordExtract;

  iter = Dcm_MemMgrGetMemBlockAddrSize(alfid);

# if (DCM_MEMMGR_MID_SUPPORT_ENABLED == STD_ON)
  --iter; /* skip mid */
  pMemBlock->Mid = *streamData;
  Dcm_UtiNextItemByPtr(streamData, 1u);
# endif

  /* extract address */
  dwordExtract = 0u;
  do
  {
    --iter;
    dwordExtract <<= 8u;
    dwordExtract |= *streamData;
    Dcm_UtiNextItemByPtr(streamData, 1u);
  }
  while(iter != 0u);

  pMemBlock->Address = (Dcm_CfgMemMgrReqAddrType)dwordExtract;

  /* extract size  */
  dwordExtract = 0u;
  iter = Dcm_MemMgrGetMemBlockLenSize(alfid);
  do
  {
    --iter;
    dwordExtract <<= 8u;
    dwordExtract |= *streamData;
    Dcm_UtiNextItemByPtr(streamData, 1u);
  }
  while(iter != 0u);

  pMemBlock->Length = (Dcm_CfgMemMgrReqSizeType)dwordExtract;

  return streamData;
}
#endif /* (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
# if (DCM_SVC_22_OBD_CALIBRATION_ENABLED == STD_ON) || \
     (DCM_SVC_31_OBD_CALIBRATION_ENABLED == STD_ON) || \
     (DCM_OBDUDSIDMGR_CALIBRATION_ENABLED    == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrIsIdEnabled()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(boolean, DCM_CODE) Dcm_ObdIdMgrIsIdEnabled(uint8 obdId
                                              ,P2CONST(Dcm_ObdIdMgrMaskValueTableType, AUTOMATIC, DCM_CONST) pMaskData)
{
  Dcm_DebugAssert((pMaskData != NULL_PTR), DCM_SID_INTERNAL, DCM_E_PARAM_POINTER)                                                                    /* COV_DCM_RTM_DEV_DEBUG XF */
  /* depends on if the first availability ID is requested or another one */
  return (boolean) ((obdId == 0x00u) ? (pMaskData[0] != 0) /* ID 0x00 is only available if any other IDs are supported too */
                                     : Dcm_ObdIdMgrIsIdSupported(pMaskData[Dcm_ObdIdMgrGetAvailabilityIdIdx(obdId-1)], obdId)); /* else - another ID (i.e. [0x01-0xFF]) is requested */
}
# endif
#endif /* (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                         /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrGetAvailabilityMask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_ObdIdMgrGetAvailabilityMask(uint8 id
                                                                      ,Dcm_Uint8ConstDataPtrType lookUpTable
                                                                      ,Dcm_VarRefMemPtrType lookUpFilterTable
                                                                      ,Dcm_ObdMaskConstDataPtrType pMaskData
                                                                      ,P2VAR(uint32, AUTOMATIC, AUTOMATIC) pMaskValue)
{
  sint16_least lLookUpResult;
  uint32 lResultMask;
  uint8 lAID;

  DCM_IGNORE_UNREF_PARAM(pMaskData);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(lookUpFilterTable);                                                                                                         /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* #10 Initially the mask value is zero. */
  lResultMask = 0;

  /* #20 Get the corresponding AID. */
  lAID = Dcm_ObdIdMgrGetAvailabilityId(id);

  /* #30 Check if the corresponding AID is supported (in variant). */
  lLookUpResult = Dcm_VarMgrLookUpFilter(Dcm_UtiLookUpUint8(lookUpTable, lAID), lookUpFilterTable);

  /* #40 If the corresponding AID is supported, then the OBD ID might be supported too. Continue with mask calculation.*/
  if(lLookUpResult >= 0)
  {
    /* #50 Define a zero-based iterator (i.e. for tables without leading-size-byte element) */
    sint16_least lLookUpIter;

    /* #60 Skip the AID and continue with next DataID or AID. */
    lLookUpIter = (sint16_least)(lLookUpResult + 1);

    if(Dcm_ObdIdMgrIsAvailabilityId(id))
    {
      /* #70 AID lookup index already found and stored (lLookUpResult). */
    }
    else
    {
      /* #80 If the requested ID is a DataID, assume it is not supported. */
      lLookUpResult = -1;
    }

    /* #90 Iterate within the AID range or end of table and calculate bit mask. */
    for(; lLookUpIter < (sint16_least)lookUpTable[0]; ++lLookUpIter)
    {
      uint8 lId = lookUpTable[lLookUpIter+1]; /* Consider the leading-size-byte offset in the lookup table. */

# if (DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)
      /* #100 Consider variant availability. */
      if(Dcm_VarMgrIsEnabledInActiveVariants(lookUpFilterTable[lLookUpIter]) == TRUE)
# endif
      {
        /* #110 If available in the variant set corresponding bit. */
        Dcm_UtiBitOpSet(uint32, lResultMask, Dcm_ObdIdMgrGetObdIdMaskBit(lId));

        /* #120 If the ID matches the requested one, update the lookup result. */
        if(lId == id)
        {
          lLookUpResult = lLookUpIter;
        }
      }

      /* #130 Iterate until the next AID is reached. This AID shall be reported in bit0 of the mask too, therefore use post-condition-check. */
      if(Dcm_ObdIdMgrIsAvailabilityId(lId))
      {
        break;
      }
    }

# if (DCM_OBDUDSIDMGR_CALIBRATION_ENABLED == STD_ON)
    /* #140 Consider calibration dependent availability. */
    lResultMask &= Dcm_ObdIdMgrGetMaskValue(id, pMaskData);

    /* #150 Check if the requested ID is still enabled. Note: if the id == AID, the lResultMask will not contain it, therefore call the corresponding API. */
    if(Dcm_ObdIdMgrIsIdEnabled(id, pMaskData) == FALSE)
    {
      lLookUpResult = -1; /* currently suppressed */
    }
# endif
  }/* #160 Otherweise the AID or DataId within the AID range is not available at all. */

  /* #170 Return the calculated mask */
  *pMaskValue = lResultMask;

  return lLookUpResult;
}

# if (DCM_OBDIDMGR_REQ_PARSER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrParseReqAndPrepRes()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_ObdIdMgrParseReqAndPrepRes(Dcm_ObdIdMgrDescPtrType idDescPtr
                                                                                    ,Dcm_MsgContextPtrType pMsgContext)
{
  Dcm_NegativeResponseCodeType lNrc = DCM_E_REQUESTOUTOFRANGE;

  if ( (pMsgContext->reqDataLen > 0u)         /* At least one ID must be there */
     &&( (pMsgContext->reqDataLen <= 6u)      /* Up to 6 IDs possible */
       ||((idDescPtr->ParseFlags & DCM_OBDIDMGR_PFLAG_REQHASDATA) != 0)) )  /* on request data - the parser will stop immediately on the first DataID */
  {
    Dcm_ObdIdMgrHandleOptType idSrcIter;
    sint16_least idIdx;
    Dcm_ObdIdMgrListItemPtrType lIdList = idDescPtr->ParseResult;
    uint8 lId;
    uint8 idTypeMask = 0x00u;

    idDescPtr->ParseCount = 0u;/* reset count */
    idSrcIter = (Dcm_ObdIdMgrHandleOptType)Dcm_UtiMathMin(pMsgContext->reqDataLen, 6u);/* up to 6 in case of request data is available */
    do /* at least one ID is inside */
    {
      --idSrcIter;

      lId = pMsgContext->reqData[0];
      Dcm_UtiNextItemByPtr(pMsgContext->reqData, 1u);
      /* analyze single ID */

      /* Check for valid data Id by getting the corresponding mask  */
      idIdx = idDescPtr->GetMaskFunc(lId, &(lIdList->Result.MaskValue));
      idDescPtr->IsAvailabilityId = (boolean)Dcm_ObdIdMgrIsAvailabilityId(lId);
      if(idDescPtr->IsAvailabilityId == TRUE)
      {
        idTypeMask |= 0x01u;
        /* lIdList->Result.MaskValue already set, "Handle" not needed. */
      }
      else
      {
        idTypeMask |= 0x02u;
        lIdList->Result.Handle = (Dcm_ObdIdMgrHandleMemType)(idIdx - Dcm_ObdIdMgrGetAvailabilityIdIdx(lId) - 1); /* skip "availability ID" gaps and make it zero based */
        if(((idDescPtr->ParseFlags & (Dcm_ObdIdMgrParserFlagsType)(DCM_OBDIDMGR_PFLAG_SINGLEDATAID|DCM_OBDIDMGR_PFLAG_REQHASDATA)) != 0) ) /* single ID only OR has data */
        {
          /* if has data - only one ID is allowed in the request.
           * If previously a SuppPid is found -> a later check below will issue error result!
           */
          idSrcIter = 0; /* finish this iteration (consider supported data ID "idIdx>=0") and stop */
        }/* else - no restrictions -> go on */
      }
      /* Found ? */
      if(idIdx >= 0)
      {
        idDescPtr->ParseCount++;
        /* Common processing */
        lIdList->Id = lId;
        /* Prepare for next item */
        Dcm_UtiNextItemByPtr(lIdList, 1u);
      }/* else - not supported/enabled ID */
    }
    while(idSrcIter != 0);

    /* Analyze summary */
    if( (idDescPtr->ParseCount != 0) /* at least one ID supported */
      &&(idTypeMask != 0x03u ) ) /* no mixed types */
    {
      if(idDescPtr->IsAvailabilityId == FALSE)/* it is a data ID */
      {
        if((DCM_OBDIDMGR_PFLAG_REQHASDATA & idDescPtr->ParseFlags) != 0) /* if has any data, then it is OK for now - the service processor shall check the data length! */
        {
          /* OK - it can only be a single DATA ID, otherwise idTypeMask would be 0x03! */
        }
        else if((DCM_OBDIDMGR_PFLAG_SINGLEDATAID & idDescPtr->ParseFlags) != 0) /* only one data ID allowed */
        {
          if(pMsgContext->reqDataLen != 1u)
          {
            /* single ID only allowed */
            return lNrc;
          }/* else - OK */
        }
        else /* (idDescPtr->ParseFlags == DCM_OBDIDMGR_PFLAG_NONE) - no restrictions */
        {
          /* OK */
        }
      }
      else
      {
        /* an availability ID request */
        if( ((DCM_OBDIDMGR_PFLAG_SINGLEDATAID & idDescPtr->ParseFlags) != 0) /* on data ID with request data */
          &&(pMsgContext->reqDataLen > 6u) ) /* not more than 6 availability IDs allowed! */
        {
          return lNrc;
        }/* else - OK */

        /* iterate over all of them */
        {
          Dcm_ObdIdMgrHandleOptType idIter = idDescPtr->ParseCount;
          lIdList = idDescPtr->ParseResult;
          do
          {
            pMsgContext->resData[0] = lIdList->Id;
            (void)Dcm_ObdIdMgrReadSupportedId(lIdList->Result.MaskValue
                                             ,&(pMsgContext->resData[1]));
            Dcm_DiagMoveOnResWithLength(pMsgContext, 5u);/* Commit data: ID byte + 4Byte DATA */                                                     /* PRQA S 3109 */ /* MD_MSR_14.3 */
            Dcm_UtiNextItemByPtr(lIdList, 1u);/* next item */
            --idIter;
          }
          while(idIter != 0);
        }
      }
      lNrc = DCM_E_POSITIVERESPONSE;
    }/* else - either mixed request or no valid IDs */
  }/* else - too less/many IDs */
  return lNrc;
}                                                                                                                                                    /* PRQA S 2006, 6010, 6030, 6080 */ /* MD_Dcm_Optimize_2006, MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */
# endif
#endif /* (DCM_OBDIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_UTI_LOOKUP_U16_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_UtiLookUpUint16()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_UtiLookUpUint16(P2CONST(uint16, AUTOMATIC, DCM_CONST) lookUpTable
                                                          ,uint16 value)
{
  sint16_least  lResult;
  uint16_least  loIdx;
  uint16_least  hiIdx;
  uint16_least  lPosition;

  /* #10 Initialize look-up: assume nothing will be found. */
  lResult = -1;
  loIdx= 1;
  hiIdx= lookUpTable[0];

  /* #20 If any sub-array exists: */
  while (loIdx <= hiIdx)
  {
    /* #30 Calculate entry position for comparison. */
    lPosition = (uint16_least)(loIdx + ((hiIdx - loIdx) / 2)); /* avoids overflows on value addition*/

    /* #40 If item found: */
    if(lookUpTable[lPosition] == value)
    {
      /* #50 Return valid entry position (compensate offset). */
      lResult = (sint16_least)(lPosition-1);
      break;
    }
    /* #60 Otherwise - continue searching */

    /* #70 Determine which sub-array shall be taken as a next. */
    if (value < lookUpTable[lPosition])
    {
      /* not needed lPosition zero value check, since loIdx >=1 */
      hiIdx = (uint16_least)(lPosition - 1);
    }
    else
    {
      /* Use upper half of interval... */
      loIdx = (uint16_least)(lPosition + 1);
    }
  }
  /* #80 Otherwise - report nothing found. */

  return lResult;
}
#endif

/**********************************************************************************************************************
 *  Dcm_UtiGetBitPosition()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(uint8, DCM_CODE) Dcm_UtiGetBitPosition(uint32 bitSet)
{
  uint8 bitCtr;

  /* This API shall be called with a single bit set in the bit-mask. */
  Dcm_DebugAssert(Dcm_UtiIsPowerOfTwo(uint32, bitSet), DCM_SID_INTERNAL, DCM_E_PARAM)                                                                /* COV_DCM_RTM_DEV_DEBUG XF */

  /* #10 Initialize result counter with 0 (in case no bit or only bit0 is set) */
  bitCtr = 0;

  /* #20 The result is zero based -> skip the first bit in the bitset */
  bitSet >>= 1;

  /* #30 Count zero bits in the set until the set bit is reached. */
  while(bitSet != 0)
  {
    bitSet >>= 1;
    ++bitCtr;
  }

  /* #40 Return bit position. */
  return bitCtr;
}

#if (DCM_UTI_NVM_READ_ENABLED  == STD_ON) || \
    (DCM_UTI_NVM_WRITE_ENABLED == STD_ON)                                                                                                            /* COV_DCM_UNSUPPORTED XF xf xf */
/**********************************************************************************************************************
 *  Dcm_UtiNvMGetErrorStatus()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_UtiNvMGetErrorStatus(uint16 blockId)
{
  Std_ReturnType lStdResult;
  NvM_RequestResultType nvmStatus;

  /* #10 Get current NvM job status. */
  lStdResult = Dcm_UtiArEnvNvMGetErrorStatus(blockId, &nvmStatus);

  /* #20 If status report successful: */
  if(lStdResult == E_OK)
  {
    /* #30 If NvM operation succeeded: */
    if (nvmStatus == NVM_REQ_OK )
    {
      /* #40 Return the result to the callee. */
      /* result is already E_OK */
    }
    /* #50 If the NvM needs more time: */
    else if (nvmStatus == NVM_REQ_PENDING)
    {
      /* #60 Notify callee to retry later. */
      lStdResult = DCM_E_PENDING;
    }
    else
    {
      /* #70 Otherwise: NvM operation failed for other reason; report back to callee. */
      lStdResult = E_NOT_OK;
    }
  }
  else
  {
    /* #80 Otherwise: Gathering NvM job status failed; report back to callee. */
    lStdResult = E_NOT_OK;
  }

  /* #90 Return final result. */
  return lStdResult;
}
#endif
#if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)                                                                                                 /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetTaskTaMonitor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetTaskTaMonitor(Dcm_TskTaskEvOptType ev
                                                   ,Dcm_TskTaskEvPtrType pPostEv)                                                                    /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  DCM_NETTOBJ_CNTR_DEF

  /* #10 Check whether any request which has to be canceled is in progress. */
  if(((DCM_DIAG_QUEUE_FLAG_IS_ACTIVE | DCM_DIAG_QUEUE_FLAG_IS_WAITING) & Dcm_InstanceContext.Diag.QueuedSet.Flags) != 0)
  {
    /* #20 Enter critical section (Reason: the transport object may not be modified from outside). */
    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
    BEGIN CRITICAL SECTION
    *=================================*/

    /* #30 If a request is in progress */
    if((DCM_DIAG_QUEUE_FLAG_IS_ACTIVE & Dcm_InstanceContext.Diag.QueuedSet.Flags) != 0)
    {
      Dcm_TskTaskEvOptType tObjEv = Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvOptType, Dcm_DiagGetTranspObj()->Handle);

      /* #40 If the ongoing request is from the same tester as the new request with the foreign N_TA */
      if(Dcm_TskIsLocalEventSet(ev, tObjEv))
      {
        /* #50 Cancel the request processing. */
        Dcm_DiagCancelProcessing();
      }/* else - post processing or idle are to be handled in a normal way */
    }

    /* #60 If a waiting new request is in the queue */
    if((DCM_DIAG_QUEUE_FLAG_IS_WAITING & Dcm_InstanceContext.Diag.QueuedSet.Flags) != 0)
    {
       Dcm_TskTaskEvOptType tObjEv = Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvOptType, Dcm_DiagGetQueuedTranspObj()->Handle);

       /* #70 If the queued request is from the same tester as the new request with the foreign N_TA */
       if(Dcm_TskIsLocalEventSet(ev, tObjEv))
       {
         /* #80 Cancel the queued request in the next task cycle. */
         *pPostEv = tObjEv;/* retry later */
       }
    }
    /*=================================*
    END CRITICAL SECTION
    *=================================*/
    /* #90 Leave critical section. */
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }

  /* #100 Scan all affected transport objects. */
  DCM_NETTOBJ_CNTR_INIT
  DCM_TSK_EVENT_SCAN_LOOP(ev)
  {
    if(Dcm_TskIsLocalEventSet(ev, 0x01u))
    {
      Dcm_NetTransportObjectPtrType pTranspObj = Dcm_NetGetTranspObjByHandle(DCM_NETTOBJ_CNTR_VALUE);

      /* #110 If a received but not yet processed request was interrupted by another request with a foreign N_TA */
      if(pTranspObj->State == DCM_NET_TOBJ_STATE_RX_END)
      {
        /* #120 Prevent the processing of the received but not yet processed request. */
        Dcm_TskClrEvent(DCM_TSK_ID_NET_RX, Dcm_UtiGetBitFromIndex(Dcm_TskTaskEvMemType, pTranspObj->Handle));

        /*
         * In order to free the correct connection assigned to the transport object, a one-to-one mapping between
         * transport objects and connections shall be guaranteed (i.e. DCM_NET_TRANSP_OBJ_DYN_ALLOC_ENABLED == STD_OFF)
         */

        /* #130 Deallocate the transport object and free the connection. */
        Dcm_NetUnRegisterComMActivity(Dcm_NetTranspObjGetConnIdOnly(pTranspObj)); /* Deallocate transport object. */
        Dcm_NetBufferRelease(Dcm_NetTranspObjGetBufferHandleValue(pTranspObj)); /* The buffer is free now. */
        Dcm_NetUnRegisterActiveConnection(pTranspObj); /* No further processing needed. */
      }
    }
    DCM_NETTOBJ_CNTR_NEXT
  }
}                                                                                                                                                    /* PRQA S 6030 */ /* MD_MSR_STCYC */
#endif

#if (DCM_NET_TASK_RX_ENABLED == STD_ON)                                                                                                              /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetTaskRx()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetTaskRx(Dcm_TskTaskEvOptType ev
                                            ,Dcm_TskTaskEvPtrType pPostEv)                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
# if (DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)
  /* #10 If multi protocol is enabled, start request prioritization. */
  Dcm_NetRxPrioritisation(ev, pPostEv);
# elif (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)
  /*
   * In case that multi protocol is disabled and interruption on a request with foreign N_TA is enabled:
   * When a new request is received instead of calling Dcm_DiagRxIndication directly the new request has to be
   * delegated by this task. This is necessary to be able to cancel already received but not yet processed requests
   * when another request with a foreign N_TA is received. That cancellation would be done by the Dcm_NetTaskTaMonitor.
   */
  DCM_IGNORE_UNREF_PARAM(pPostEv);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */
  /* Only one transport object can be processed. */
  Dcm_DebugAssert(Dcm_UtiIsPowerOfTwo(Dcm_TskTaskEvOptType, ev), DCM_SID_INTERNAL, DCM_E_PARAM)                                                      /* COV_DCM_RTM_DEV_DEBUG XF */

  /* #20 Otherwise, delegate the received request to the task. */
  Dcm_DiagRxIndication(Dcm_NetGetTranspObjByHandle(Dcm_UtiGetBitPosition(ev)));
# else
#  error "Invalid configuration!"
# endif
}
#endif

/**********************************************************************************************************************
 *  Dcm_NetTaskTx()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetTaskTx(Dcm_TskTaskEvOptType ev
                                            ,Dcm_TskTaskEvPtrType pPostEv)                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  DCM_IGNORE_UNREF_PARAM(pPostEv);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ev);                                                                                                                        /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /*DCM_TSK_EV_NET_TX_SEND is the only event of this task -> no need to check it explicitly */
#if (DCM_TSK_EV_NET_TX_MSB != 0x01u)
# error "New events have been added for Dcm_NetTaskTx! Make set event check here!"
#endif
  {
    DCM_NETTOBJ_ITER_DEF

    /* find candidate for NRC 0x21 or final response */
    DCM_NETTOBJ_LOOP_FOR_UP
    {
#if(DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
      if( ((DCM_NET_TOBJ_STATE_RX_END & Dcm_PbRamNetTransportObject[DCM_NETTOBJ_ITER_VALUE].State) != 0) /* Completely received ... */
        &&((DCM_NET_TOBJ_FLAG_BUSY   & Dcm_PbRamNetTransportObject[DCM_NETTOBJ_ITER_VALUE].Flags)  != 0))/* a busy request. */
      {
        /* Do send busy response */
        Dcm_NetComposeAddNegResponse(&(Dcm_PbRamNetTransportObject[DCM_NETTOBJ_ITER_VALUE])
                                    ,DCM_NET_TOBJ_RESTYPE_SIMPLE
                                    ,DCM_E_BUSYREPEATREQUEST);
      }
#endif

#if (DCM_NET_MULTI_TRANSP_OBJ_ENABLED == STD_ON)
      if((Dcm_PbRamNetTransportObject[DCM_NETTOBJ_ITER_VALUE].State & DCM_NET_TOBJ_STATE_PREPTX) != 0u)
#endif
      {
        Dcm_NetTransmitUsdtResponse(&Dcm_PbRamNetTransportObject[DCM_NETTOBJ_ITER_VALUE]);
      }
    }
  }
}

/**********************************************************************************************************************
 *  Dcm_NetRegisterComMActivity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetRegisterComMActivity(Dcm_NetTransportObjectPtrType pTranspObj)                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  DCM_IGNORE_UNREF_PARAM(pTranspObj);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */
#if(DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
  if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_INTERNAL) == 0)/* internal requests do not manage the ComM activity */
#endif
  {
    DCM_NETCHNL_COMM_LOCVAR_DEF

#if(DCM_NET_COMM_MULTI_CHANNEL_ENABLED == STD_ON)
    DCM_NETCHNL_COMM_LOCVAR_NAME  = Dcm_PbCfgNetConnectionInfo[Dcm_NetTranspObjGetConnIdOnly(pTranspObj)].NetworkIdRef;
#endif
    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
     BEGIN CRITICAL SECTION
     *=================================*/
    {
      if(Dcm_PbRamNetComMContext[DCM_NETCHNL_COMM_LOCVAR_VALUE].RegisteredNetworks == 0u)
      {
        /* activate only if default session is active, otherwise already active */
        if(   Dcm_StateIsDefaultSessionActive()
          && (Dcm_SingletonContext.Network.ActiveDiagnostic == DCM_NET_COMM_ACTIVE)
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
          && (Dcm_SingletonContext.Network.KeepAlive == FALSE)
#endif
          )
        {
          /* Register one connection */
          Dcm_NetArEnvComMActiveDiag(Dcm_PbCfgNetAllComMChannelMap[Dcm_PbCfgNetConnComMChannelMap[DCM_NETCHNL_COMM_LOCVAR_VALUE]]);
        }
      }
    }

    if(Dcm_PbRamNetComMContext[DCM_NETCHNL_COMM_LOCVAR_VALUE].RegisteredNetworks < Dcm_UtiMaxValueOfUintType(Dcm_NetConnRefMemType))
    {
      ++Dcm_PbRamNetComMContext[DCM_NETCHNL_COMM_LOCVAR_VALUE].RegisteredNetworks;
    }
    else
    {
      /* Too many activations! */
      Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                   /* COV_DCM_RTM_DEV_DEBUG XF */
    }
    /*=================================*
     END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }
}

/**********************************************************************************************************************
 *  Dcm_NetUnRegisterComMActivity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUnRegisterComMActivity(DCM_NETCONNID_PARAMDEF_ONLY)
{
  DCM_NETCHNL_COMM_LOCVAR_DEF

#if(DCM_NET_MULTI_CONNECT_ENABLED == STD_ON)
  DCM_IGNORE_UNREF_PARAM(DCM_NETCONNID_PARAM_NAME);                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
#endif
#if(DCM_NET_COMM_MULTI_CHANNEL_ENABLED == STD_ON)
  DCM_NETCHNL_COMM_LOCVAR_NAME  = Dcm_PbCfgNetConnectionInfo[DCM_NETCONNID_PARAM_VALUE].NetworkIdRef;
#endif

  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
   BEGIN CRITICAL SECTION
   *=================================*/
  if(Dcm_PbRamNetComMContext[DCM_NETCHNL_COMM_LOCVAR_VALUE].RegisteredNetworks != 0u)
  {
    /* Unregister one connection */
    --Dcm_PbRamNetComMContext[DCM_NETCHNL_COMM_LOCVAR_VALUE].RegisteredNetworks;
    if(Dcm_PbRamNetComMContext[DCM_NETCHNL_COMM_LOCVAR_VALUE].RegisteredNetworks == 0u)
    {
      /* return only if default session is active */
      if (Dcm_StateIsDefaultSessionActive()
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
         &&(Dcm_SingletonContext.Network.KeepAlive == FALSE)
#endif
         )
      {
        Dcm_NetArEnvComMInactiveDiag(Dcm_PbCfgNetAllComMChannelMap[Dcm_PbCfgNetConnComMChannelMap[DCM_NETCHNL_COMM_LOCVAR_VALUE]]);
      }
    }
  }
  else
  {
    /* when sending, there shall be at least one active request still unregistered */
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
  }
  /*=================================*
   END CRITICAL SECTION
   *=================================*/
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
}

/**********************************************************************************************************************
 *  Dcm_NetUnRegisterAllComMActivity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUnRegisterAllComMActivity(void)
{
  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
   BEGIN CRITICAL SECTION
   *=================================*/
  {
    DCM_NETCHNL_COMM_ITER_DEF
    DCM_NETCHNL_COMM_LOOP_FOR_UP
    {
      /* unregister only if no connection is ongoing */
      if(Dcm_PbRamNetComMContext[DCM_NETCHNL_COMM_ITER_VALUE].RegisteredNetworks == 0u)
      {
        Dcm_NetArEnvComMInactiveDiag(Dcm_PbCfgNetAllComMChannelMap[Dcm_PbCfgNetConnComMChannelMap[DCM_NETCHNL_COMM_ITER_VALUE]]);
      }
    }
  }
  /*=================================*
  END CRITICAL SECTION
  *=================================*/
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
}

/**********************************************************************************************************************
 *  Dcm_NetUnRegisterActiveConnection()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUnRegisterActiveConnection(Dcm_NetTransportObjectPtrType pTranspObj)
{
#if(DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
  if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_INTERNAL) == 0)/* internal requests do not manage the S3 timer */
#endif
  {
#if(DCM_NET_MULTI_TRANSP_OBJ_ENABLED == STD_ON)
    /*=================================*
     END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */

    if(Dcm_SingletonContext.Network.NumActiveConnections != 0)                                                                                       /* COV_DCM_RTM_UNREACHABLE TX */
    {
      --Dcm_SingletonContext.Network.NumActiveConnections;
    }
    else
    {
      /* Too many activations! */
      Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                   /* COV_DCM_RTM_DEV_DEBUG XF */
    }

    if(Dcm_SingletonContext.Network.NumActiveConnections == 0u)
#endif
    {
      Dcm_TmrStartTimer(DCM_TMR_ID_S3, DCM_DIAG_TIME_S3);
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
      Dcm_TmrStartTimer(DCM_TMR_ID_KEEP_ALIVE, DCM_NET_KEEP_ALIVE_TIME);
#endif
    }

#if(DCM_NET_MULTI_TRANSP_OBJ_ENABLED == STD_ON)
    /*=================================*
     END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
#endif
  }
  Dcm_NetTranspObjRelease(pTranspObj);
}

#if(DCM_NET_TRANSP_OBJ_DYN_ALLOC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetAllocateOrGetTranspObject()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_CfgNetTObjHandleMemType, DCM_CODE) Dcm_NetAllocateOrGetTranspObject(DCM_NETCONNID_PARAMDEF_ONLY)
{
  DCM_IGNORE_UNREF_PARAM(DCM_NETCONNID_PARAM_NAME);                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  if(Dcm_PbRamNetConnId2TObjMap[DCM_NETCONNID_PARAM_VALUE] >= DCM_NET_INVALID_TOBJID)/* check if already assigned */
  {
    DCM_NETTOBJ_ITER_DEF

    DCM_NETTOBJ_LOOP_FOR_UP
    {
      if(Dcm_PbRamNetTransportObject[DCM_NETTOBJ_ITER_VALUE].State == DCM_NET_TOBJ_STATE_FREE)
      {
        Dcm_PbRamNetConnId2TObjMap[DCM_NETCONNID_PARAM_VALUE] = (Dcm_CfgNetTObjHandleMemType)DCM_NETTOBJ_ITER_VALUE;/* assign ownership information */
        return (Dcm_CfgNetTObjHandleMemType)DCM_NETTOBJ_ITER_VALUE;
      }/* Transport Object is in use - check next one */
    }
    return DCM_NET_INVALID_TOBJID; /* no free transport object found */
  }/* else - already allocated -> return it */
  return Dcm_NetGetTranspObjIdOfConnection(DCM_NETCONNID_PARAM_VALUE);
}                                                                                                                                                    /* PRQA S 2006 */ /* MD_Dcm_Optimize_2006 */
#endif

/**********************************************************************************************************************
 *  Dcm_NetTranspObjRelease()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetTranspObjRelease(Dcm_NetTransportObjectPtrType pTranspObj)
{
  Dcm_DebugAssert((pTranspObj != NULL_PTR), DCM_SID_INTERNAL, DCM_E_PARAM_POINTER)                                                                   /* COV_DCM_RTM_DEV_DEBUG XF */

  /* #10 If the transport object is still in use: */
  if(pTranspObj->State != DCM_NET_TOBJ_STATE_FREE) /* assure the object has validly initialized fields */
  {
    /* #20 Its states are valid and can be used if needed. */
    /* #30 Reset only the relevant states of the transport object. */
#if(DCM_NET_TRANSP_OBJ_DYN_ALLOC_ENABLED == STD_ON)
    Dcm_PbRamNetConnId2TObjMap[Dcm_NetTranspObjGetConnIdValue(pTranspObj)] = DCM_NET_INVALID_TOBJID;/* clear the ownership information */
#endif
    pTranspObj->ResType = DCM_NET_TOBJ_RESTYPE_NONE;
    pTranspObj->Flags   = DCM_NET_TOBJ_FLAG_NONE;
    /* #40 Reset the guard state (object in use) at last to avoid critical section usage. */
    pTranspObj->State   = DCM_NET_TOBJ_STATE_FREE;
  }
  /* #50 Otherwise nothing to do. */
}

/**********************************************************************************************************************
 *  Dcm_NetGetConnIdByTesterAddress()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NetConnRefMemType, DCM_CODE) Dcm_NetGetConnIdByTesterAddress(uint16 testerAddress)
{
  DCM_NETCONNID_ITER_DEF
  Dcm_NetConnRefMemType lResult = DCM_NET_INVALID_CONNID;

  DCM_NETCONNID_LOOP_FOR_UP
  {
    if (testerAddress == Dcm_PbCfgNetConnectionInfo[DCM_NETCONNID_ITER_VALUE].ClientSrcAddr)
    {
      lResult = (Dcm_NetConnRefMemType)DCM_NETCONNID_ITER_VALUE;
      DCM_NETCONNID_ITER_BREAK
    }
  }
  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_NetUsdtTxConfirmation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetUsdtTxConfirmation(Dcm_NetTransportObjectPtrType pTranspObj
                                                        ,Dcm_NetTransmissionResultType result)
{
#if (DCM_NET_PROCESSING_CANCELLATION_ENABLED == STD_ON)                                                                                              /* COV_DCM_UNSUPPORTED XF */
  if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_CANCELED) != 0)
  {
    Dcm_NetBufferRelease(Dcm_NetTranspObjGetBufferHandleValue(pTranspObj));   /* the buffer is free now */
    /* ComM is already released in the DiagPostProcessing task */
    Dcm_NetUnRegisterActiveConnection(pTranspObj);/* no further processing needed */                                                                 /* SBSW_DCM_INT_API_PARAM_PTR_PASSED_THROUGH */
  }
  else
#endif
  {
#if (DCM_NET_MULTI_CLIENT_ENABLED == STD_ON) || \
    (DCM_NET_PROTOCOL_SWITCH_NOTIFICATION_ENABLED == STD_ON)                                                                                         /* COV_DCM_UNSUPPORTED TF tf xf */
    if(pTranspObj->ResType == DCM_NET_TOBJ_RESTYPE_SIMPLE)
    {
      Dcm_NetUnRegisterComMActivity(Dcm_NetTranspObjGetConnIdOnly(pTranspObj));
      Dcm_NetUnRegisterActiveConnection(pTranspObj);/* no further processing needed */                                                               /* SBSW_DCM_INT_API_PARAM_PTR_PASSED_THROUGH */
    }
    else
#endif
    {
      Dcm_DiagOnTxFinished(pTranspObj, result);                                                                                                      /* SBSW_DCM_INT_API_PARAM_PTR_PASSED_THROUGH */
    }
  }
}
#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_OnTimeoutPeriodicTx()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutPeriodicTx(void)
{
# if(DCM_NET_PTXOBJ_SOFT_TIMER_ENABLED == STD_ON)
  DCM_NET_PTXOBJ_ITER_DEF
  Dcm_TmrTimerCntrMemType lReloadTick = 0u;

  DCM_NET_PTXOBJ_LOOP_FOR_UP_GEN
  {
    Dcm_UtiArEnvEnterCriticalSection(); /* protect against high level interrupts from the network interface */                                       /* PRQA S 3109 */ /* MD_MSR_14.3 */
    if(!Dcm_NetPTxObjTimerExpired(DCM_NET_PTXOBJ_ITER_VALUE))
    {
      Dcm_NetPTxObjTimerDec(DCM_NET_PTXOBJ_ITER_VALUE);
      if(!Dcm_NetPTxObjTimerExpired(DCM_NET_PTXOBJ_ITER_VALUE))
      {
        lReloadTick = 1u;/* at least one active timer - reload by one tick */
      }
      else
      {
        (void)Dcm_NetArEnvPduRCancelTransmit(Dcm_NetPeriodicMsgGetTxPduIdCurrConn(DCM_NET_PTXOBJ_ITER_VALUE));/* try to cancel still ongoing TX */
        Dcm_NetPeriodicMsgRelease(DCM_NET_PTXOBJ_ITER_ONLY);
      }
    }
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }

  return lReloadTick;/* start with one tick */
# else
  Dcm_UtiArEnvEnterCriticalSection(); /* protect against high level interrupts from the network interface */                                         /* PRQA S 3109 */ /* MD_MSR_14.3 */
  Dcm_NetPeriodicMsgRelease();
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  return 0u; /* no reload */
# endif
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgAllocate()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_CfgNetPTxObjHandleMemType, DCM_CODE) Dcm_NetPeriodicMsgAllocate(void)
{
  Dcm_CfgNetPTxObjHandleMemType perTxObjHdl = DCM_NET_INVALID_PTXOBJ_HANDLE;

# if (DCM_NET_PTXOBJ_LIMITER_ENABLED == STD_ON)
  if(Dcm_SingletonContext.Network.PeriodicTxContext.TxObjectCntr != 0)
# endif
  {
    DCM_NET_PTXOBJ_ITER_CTR_DEF

# if (DCM_NET_PTXOBJ_LIMITER_ENABLED == STD_OFF)
    DCM_NET_PTXOBJ_LOOP_FOR_UP_SPEC /* use forward-loop to have always a zero based match between the use txPduId index and the resource handle! */
# endif
    {
      if(Dcm_PbRamNetPeriodicTxObject[DCM_NET_PTXOBJ_ITER_CTR_VALUE].IsReserved == FALSE)
      {
        Dcm_PbRamNetPeriodicTxObject[DCM_NET_PTXOBJ_ITER_CTR_VALUE].IsReserved = TRUE;
        perTxObjHdl = (Dcm_CfgNetPTxObjHandleMemType)DCM_NET_PTXOBJ_ITER_CTR_VALUE;
        Dcm_NetPeriodicMsgDecMsgCounter(); /* decrement MSG counter */
        Dcm_NetPeriodicMsgNextMsgHdl(); /* next object to be used */                                                                                 /* PRQA S 3109 */ /* MD_Dcm_CfgDepend_3109 */
# if (DCM_NET_PTXOBJ_LIMITER_ENABLED == STD_OFF)
        DCM_NET_PTXOBJ_LOOP_BREAK
# endif
      }/* else - retry later with the same object (limiter) or next free object (hi-performance) */
    }
  }
  return perTxObjHdl;
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgRelease()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgRelease(DCM_NET_PTXOBJ_PARAMDEF_ONLY)
{
# if (DCM_NET_MULTI_PERIODIC_TX_OBJ_ENABLED == STD_ON)
  Dcm_DebugAssert((DCM_NET_PTXOBJ_PARAM_VALUE < Dcm_NetPeriodicMsgNumMsgsCurrConnection()), DCM_SID_INTERNAL, DCM_E_PARAM)                           /* COV_DCM_RTM_DEV_DEBUG XF */
# endif
  Dcm_NetPTxObjTimerStop(DCM_NET_PTXOBJ_PARAM_VALUE);                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  Dcm_PbRamNetPeriodicTxObject[DCM_NET_PTXOBJ_PARAM_VALUE].IsReserved  = FALSE;
}
#endif

#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetPeriodicMsgTransmit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetPeriodicMsgTransmit(DCM_NET_PTXOBJ_PARAMDEF_FIRST
                                                          PduLengthType length)
{
  Std_ReturnType lStdResult;
# if(DCM_NET_MULTI_CONNECT_ENABLED == STD_ON)
  Dcm_DebugAssert((Dcm_NetPeriodicMsgGetConnection() < DCM_NET_INVALID_CONNID), DCM_SID_INTERNAL, DCM_E_PARAM)                                       /* COV_DCM_RTM_DEV_DEBUG XF */
# endif
# if (DCM_NET_MULTI_PERIODIC_TX_OBJ_ENABLED == STD_ON)
  Dcm_DebugAssert((DCM_NET_PTXOBJ_PARAM_VALUE < Dcm_NetPeriodicMsgNumMsgsCurrConnection()), DCM_SID_INTERNAL, DCM_E_PARAM)                           /* COV_DCM_RTM_DEV_DEBUG XF */
# endif

  if((DCM_NET_COMM_STATE_FLAG_TX_EN & Dcm_NetGetComStateByConnection(Dcm_NetPeriodicMsgGetConnection())) != 0)
  {
    Dcm_NetPTxObjTimerStart(DCM_NET_PTXOBJ_PARAM_VALUE, Dcm_PbCfgNetConnectionInfo[Dcm_NetPeriodicMsgGetConnection()].PeriodicTxConfTimeout);        /* PRQA S 3109 */ /* MD_MSR_14.3 */
# if (DCM_NET_PERIODIC_MSG_PADDING_ENABLED == STD_ON)
    while(length < DCM_NET_PERIODIC_BUFFER_SIZE)
    {
      Dcm_PbRamNetPeriodicTxObject[DCM_NET_PTXOBJ_PARAM_VALUE].TxPduInfo.SduDataPtr[length] = DCM_NET_PERIODIC_MSG_PADDING_PATTERN;
      ++length;
    }
# endif
    Dcm_PbRamNetPeriodicTxObject[DCM_NET_PTXOBJ_PARAM_VALUE].TxPduInfo.SduLength = length;
    lStdResult = PduR_DcmTransmit(Dcm_NetPeriodicMsgGetTxPduIdCurrConn(DCM_NET_PTXOBJ_PARAM_VALUE)
                                 ,&(Dcm_PbRamNetPeriodicTxObject[DCM_NET_PTXOBJ_PARAM_VALUE].TxPduInfo));

    /* Depending on result - wait for TxConfirmation or just close transmission with immedate release of resource. */
  }
  else
  {
    /* else - finish with TX failed! */
    lStdResult = DCM_E_NOT_OK;
  }

  if(lStdResult != DCM_E_OK)
  {
    /* Do not retry transmission -> make a loop-back and finalize transmission */
    Dcm_NetPeriodicMsgRelease(DCM_NET_PTXOBJ_PARAM_ONLY);
  }
}
#endif
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)                                                                                                  /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetProvideRxBuffer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetProvideRxBuffer(PduIdType DcmRxPduId
                                                              ,PduLengthType TpSduLength
                                                              ,P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) *PduInfoPtr
                                                              ,Dcm_NetTransportObjectFlagType addTObjFlags)
{
  DCM_NETCONNID_LOCVAR_DEF
  BufReq_ReturnType lResult = BUFREQ_E_NOT_OK;

# if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
  if( (DcmRxPduId < Dcm_PbCfgNetNumRxPduIds)
    &&(Dcm_NetGetConnIdOfRxPduId(DcmRxPduId) < Dcm_PbCfgNetNumConnections) ) /* keep evaluation order to guard the connRef indirection */
# endif
  {
# if (DCM_NET_MULTI_CONNECT_ENABLED == STD_ON)
    DCM_NETCONNID_LOCVAR_NAME = Dcm_NetGetConnIdOfRxPduId(DcmRxPduId);
# endif

    /* Check ComM state - no request reception on NoCommMode */
    if(  ((DCM_NET_COMM_STATE_FLAG_RX_EN & Dcm_NetGetComStateByConnection(DCM_NETCONNID_LOCVAR_VALUE)) != 0)
# if (DCM_NET_RX_BLOCKING_ENABLED == STD_ON)
       &&(Dcm_SingletonContext.Network.RxAllowed == TRUE)
# endif
       )
    {
      Dcm_CfgNetTObjHandleMemType tObjHdl;

      Dcm_NetMultiChannelEnterCS();/* Protect against parallel request from another CAN channel */                                                   /* PRQA S 3109 */ /* MD_MSR_14.3 */
      /*=================================*
       BEGIN CRITICAL SECTION
       *=================================*/
      tObjHdl = Dcm_NetAllocateOrGetTranspObject(DCM_NETCONNID_LOCVAR_ONLY);

      /* A free or an already assigned to this connection object found? */
# if(DCM_NET_TRANSP_OBJ_DYN_ALLOC_ENABLED == STD_ON)
      if(tObjHdl < DCM_NET_INVALID_TOBJID)
# endif
      {
        Dcm_NetTransportObjectPtrType pTranspObj = Dcm_NetGetTranspObjByHandle(tObjHdl);

        if(pTranspObj->State == DCM_NET_TOBJ_STATE_FREE) /* the connection is free (assure half-duplex mode)? */
        {
          Dcm_NetTranspObjSetBufferHandle(pTranspObj, Dcm_NetGetProtObjOfConnection(DCM_NETCONNID_LOCVAR_VALUE)->RxTxBufferRef);

          /* Will it fit our buffer? */
          if(TpSduLength <= Dcm_NetGetBufferSizeOfTranspObj(pTranspObj))
          {
            /* Store relevant information for later use */
            pTranspObj->RxPduId  = DcmRxPduId;
            Dcm_NetTranspObjSetConnId(pTranspObj, (Dcm_NetConnRefMemType)DCM_NETCONNID_LOCVAR_VALUE);

            /* Set up RX message context */
            pTranspObj->RxLength = (Dcm_CfgNetBufferSizeMemType)TpSduLength; /* safe cast, since tpSduLength <= bufferSize = value fits Dcm_CfgNetBufferSizeMemType */
            pTranspObj->BuffPos  = 0u;                                       /* start writing from the buffer begin */
            pTranspObj->State    = DCM_NET_TOBJ_STATE_ONRX;

            if(
               Dcm_NetBufferIsFree(Dcm_NetTranspObjGetBufferHandleValue(pTranspObj))/* Is the buffer in use? */
# if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
             &&( ((DCM_STATE_VALUE_SESSION_INIT & Dcm_StateGetPendingSession()) != 0) /* a non-default session is/will be active */
               ||(Dcm_NetGetSessionConnection() == DCM_NETCONNID_LOCVAR_VALUE)/* not the owner of the session */
#  if (DCM_NET_PROTOCOL_PRIORITISATION_ENABLED == STD_ON)
               ||( Dcm_NetGetProtObjOfConnection(DCM_NETCONNID_LOCVAR_VALUE)->Priority
                 < Dcm_NetGetProtObjOfConnection(Dcm_NetGetSessionConnection())->Priority )               /* if higher priority -> let it through */
#  endif
               )
# endif
              )
            {
              Dcm_NetBufferLock(Dcm_NetTranspObjGetBufferHandleValue(pTranspObj));   /* the buffer is in use now */
              /* Report available buffer */
              pTranspObj->BuffInfo.SduLength  = (PduLengthType)Dcm_NetGetBufferSizeOfTranspObj(pTranspObj);
              pTranspObj->RxData = Dcm_NetGetBufferPtrOfTranspObj(pTranspObj);
              pTranspObj->Flags = addTObjFlags;
              lResult = BUFREQ_OK;
            }
# if(DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
            else
            {
              /* only provide enough buffer for the first frame; the TP will then have to request a new buffer */
              pTranspObj->BuffInfo.SduLength  = 7u;
              pTranspObj->RxData = &(pTranspObj->AddBuffer[1]); /* offset=1, so SID and SUBSID are written to the correct position */
              /* no free "real buffer" object - ignore or simulate reception for NRC 0x21 */
              pTranspObj->Flags = (Dcm_NetTransportObjectFlagType)(addTObjFlags | DCM_NET_TOBJ_FLAG_BUSY);
              lResult = BUFREQ_OK;
            }
# endif
          }
          else
          {
            /* Buffer too small. */
            lResult = BUFREQ_E_OVFL;
          }

          if(lResult == BUFREQ_OK)
          {
            pTranspObj->BuffInfo.SduDataPtr = pTranspObj->RxData;
            *PduInfoPtr = &pTranspObj->BuffInfo;
            Dcm_NetRegisterActiveConnection(pTranspObj);
          }
          else
          {
            Dcm_NetTranspObjRelease(pTranspObj);/* no further processing needed */
          }
        }
# if(DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
        else
        {
          if ( (pTranspObj->State == DCM_NET_TOBJ_STATE_ONRX) &&
               (pTranspObj->RxPduId == DcmRxPduId) && /* guarantee that even a parallel request from the same tester that was concurrent to another one will not be overwritten (i.e. 0x3E functional to a multi-frame parallel physical request) */
               ((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_BUSY) != 0) )
          {
            /* parallel reception already in progress; continue to use temporary buffer */
            pTranspObj->BuffInfo.SduDataPtr = &(pTranspObj->AddBuffer[3]); /* offset=3, so received SID is left in byte[1], SubSID in byte[2]; received data will be discarded anyway */
            pTranspObj->BuffInfo.SduLength  = 7u;
            lResult = BUFREQ_OK;
          } /* else: reception neither real nor simulated; ignore reception */
        }
# endif
      }/* else no free transport objects - ignore reception */

     /*=================================*
      END CRITICAL SECTION
      *=================================*/
      Dcm_NetMultiChannelLeaveCS();                                                                                                                  /* PRQA S 3109 */ /* MD_MSR_14.3 */
    }
  }/* else - no valid/deleted rxPduId used */
  return lResult;
} /* Dcm_NetProvideRxBuffer */                                                                                                                       /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)                                                                                                  /* COV_DCM_SUPPORT_PARTIALLY TX tx xf */
/**********************************************************************************************************************
 *  Dcm_NetSetComModeEntered()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_NetSetComModeEntered(NetworkHandleType networkId
                                                       ,Dcm_NetComMStateType newComState)
{
  /* used to always verify for valid parameter */
  sint16_least lDcmComMHandle = Dcm_UtiLookUpUint8(Dcm_PbCfgNetNetworkHdlLookUp, networkId);

  if(lDcmComMHandle >= 0) /* consider only DCM relevant channels */
  {
    Dcm_UtiArEnvEnterCriticalSection(); /* Avoid concurrent access on registerNetworks from an interrupt  */                                         /* PRQA S 3109 */ /* MD_MSR_14.3 */
    Dcm_PbRamNetComMContext[lDcmComMHandle].ComState = newComState;
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }/* else - not a DCM channel -> ignore */
}

/**********************************************************************************************************************
 *  Dcm_NetStartOfReception()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(BufReq_ReturnType, DCM_CODE) Dcm_NetStartOfReception(PduIdType rxPduId
                                                                    ,PduLengthType tpSduLength
                                                                    ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) bufferSizePtr
                                                                    ,Dcm_NetTransportObjectFlagType addTObjFlags)
{
  DCM_NETCONNID_LOCVAR_DEF
  BufReq_ReturnType lResult = BUFREQ_E_NOT_OK;

# if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
  if( (rxPduId < Dcm_PbCfgNetNumRxPduIds)
    &&(Dcm_NetGetConnIdOfRxPduId(rxPduId) < Dcm_PbCfgNetNumConnections) ) /* keep evaluation order to guard the connRef indirection */
# endif
  {
# if (DCM_NET_MULTI_CONNECT_ENABLED == STD_ON)
    DCM_NETCONNID_LOCVAR_NAME = Dcm_NetGetConnIdOfRxPduId(rxPduId);
# endif

    /* Check ComM state - no request reception on NoCommMode */
    if( ((DCM_NET_COMM_STATE_FLAG_RX_EN & Dcm_NetGetComStateByConnection(DCM_NETCONNID_LOCVAR_VALUE)) != 0)
# if (DCM_NET_RX_BLOCKING_ENABLED == STD_ON)
      &&(Dcm_SingletonContext.Network.RxAllowed == TRUE)
# endif
      )
    {
      Dcm_CfgNetTObjHandleMemType tObjHdl;

      Dcm_NetMultiChannelEnterCS();/* Protect against parallel request from another CAN channel */                                                   /* PRQA S 3109 */ /* MD_MSR_14.3 */
      /*=================================*
       BEGIN CRITICAL SECTION
       *=================================*/
      tObjHdl = Dcm_NetAllocateOrGetTranspObject(DCM_NETCONNID_LOCVAR_ONLY);

      /* A free or an already assigned to this connection object found? */
# if(DCM_NET_TRANSP_OBJ_DYN_ALLOC_ENABLED == STD_ON)
      if(tObjHdl < DCM_NET_INVALID_TOBJID)
# endif
      {
        Dcm_NetTransportObjectPtrType pTranspObj = Dcm_NetGetTranspObjByHandle(tObjHdl);

        if(pTranspObj->State == DCM_NET_TOBJ_STATE_FREE) /* the connection is free (assure half-duplex mode)? */
        {
          Dcm_NetTranspObjSetBufferHandle(pTranspObj, Dcm_NetGetProtObjOfConnection(DCM_NETCONNID_LOCVAR_VALUE)->RxTxBufferRef);

          /* Will it fit our buffer? */
          if(tpSduLength <= Dcm_NetGetBufferSizeOfTranspObj(pTranspObj))
          {
            /* Report available buffer size */
            *bufferSizePtr = (PduLengthType)Dcm_NetGetBufferSizeOfTranspObj(pTranspObj);                                                             /* SBSW_DCM_INT_API_PARAM_PTR_WRITE */

            /* Store relevant information for later use */
            pTranspObj->RxPduId   = rxPduId;                                                                                                         /* SBSW_DCM_ALLOC_TRANSP_OBJECT_WRITE */
            Dcm_NetTranspObjSetConnId(pTranspObj, (Dcm_NetConnRefMemType)DCM_NETCONNID_LOCVAR_VALUE);                                                /* SBSW_DCM_ALLOC_TRANSP_OBJECT_WRITE */

            /* Set up RX message context */
            pTranspObj->RxLength= (Dcm_CfgNetBufferSizeMemType)tpSduLength;/* safe cast, since tpSduLength <= bufferSize = value fits Dcm_CfgNetBufferSizeMemType */ /* SBSW_DCM_ALLOC_TRANSP_OBJECT_WRITE */
            pTranspObj->BuffPos = 0u; /* start writing from the buffer begin */                                                                      /* SBSW_DCM_ALLOC_TRANSP_OBJECT_WRITE */
            pTranspObj->State   = DCM_NET_TOBJ_STATE_ONRX;                                                                                           /* SBSW_DCM_ALLOC_TRANSP_OBJECT_WRITE */
            pTranspObj->Flags   = addTObjFlags;                                                                                                      /* SBSW_DCM_ALLOC_TRANSP_OBJECT_WRITE */

            if(
               Dcm_NetBufferIsFree(Dcm_NetTranspObjGetBufferHandleValue(pTranspObj))/* Is the buffer in use? */
# if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
             &&( ((DCM_STATE_VALUE_SESSION_INIT & Dcm_StateGetPendingSession()) != 0) /* a non-default session is/will be active */
               ||(Dcm_NetGetSessionConnection() == DCM_NETCONNID_LOCVAR_VALUE)/* not the owner of the session */
#  if (DCM_NET_PROTOCOL_PRIORITISATION_ENABLED == STD_ON)                                                                                            /* COV_DCM_UNSUPPORTED XF */
               ||( Dcm_NetGetProtObjOfConnection(DCM_NETCONNID_LOCVAR_VALUE)->Priority
                 < Dcm_NetGetProtObjOfConnection(Dcm_NetGetSessionConnection())->Priority )               /* if higher priority -> let it through */
#  endif
               )
# endif
              )
            {
              pTranspObj->RxData = Dcm_NetGetBufferPtrOfTranspObj(pTranspObj);                                                                       /* SBSW_DCM_ALLOC_TRANSP_OBJECT_WRITE */
              Dcm_NetBufferLock(Dcm_NetTranspObjGetBufferHandleValue(pTranspObj));   /* the buffer is in use now */
              lResult = BUFREQ_OK;
            }
# if(DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
            else
            {
              pTranspObj->RxData = &pTranspObj->AddBuffer[1];           /* Redirect to additional buffer */
              /* no free "real buffer" object - ignore or simulate reception for NRC 0x21 */
              pTranspObj->Flags |= (Dcm_NetTransportObjectFlagType)(DCM_NET_TOBJ_FLAG_BUSY| DCM_NET_TOBJ_FLAG_COPYHEAD);                             /* SBSW_DCM_ALLOC_TRANSP_OBJECT_WRITE */
              lResult = BUFREQ_OK;
            }
# endif
          }
          else
          {
            /* Buffer too small. */
            lResult = BUFREQ_E_OVFL;
          }

          if(lResult == BUFREQ_OK)
          {
             Dcm_NetRegisterActiveConnection(pTranspObj);                                                                                            /* SBSW_DCM_ALLOC_TRANSP_OBJECT_PASS_THROUGH */
          }
          else
          {
            Dcm_NetTranspObjRelease(pTranspObj);/* no further processing needed */                                                                   /* SBSW_DCM_ALLOC_TRANSP_OBJECT_PASS_THROUGH */
          }
        }/* else no free transport objects - ignore reception */
      }/* else no free transport objects - ignore reception */
     /*=================================*
      END CRITICAL SECTION
      *=================================*/
      Dcm_NetMultiChannelLeaveCS();                                                                                                                  /* PRQA S 3109 */ /* MD_MSR_14.3 */
    }
  }/* else - no valid/deleted rxPduId used */
  return lResult;
}                                                                                                                                                    /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferCancel()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_PagedBufferCancel(void)
{
  Std_ReturnType lResult = DCM_E_OK;

  /* #10 If page buffer is currently activated: */
  if(Dcm_InstanceContext.PagedBuffer.State != DCM_PAGEDBUFFER_STATE_INACTIVE)
  {
    /* #20 If not all data was written by the application: */
    if(Dcm_InstanceContext.PagedBuffer.UpdateFinished == FALSE)
    {
      /* #30 Notify the application about the cancellation. */
      if(Dcm_InstanceContext.PagedBuffer.CancelFunc != NULL_PTR)                                                                                     /* COV_DCM_RTM_DESIGN_LOWER_LAYER XF */
      {
        Dcm_InstanceContext.PagedBuffer.CancelFunc();
      }
    }

    /* #40 If no transmission was started yet: */
    if(Dcm_InstanceContext.PagedBuffer.State == DCM_PAGEDBUFFER_STATE_ACTIVATED)                                                                     /* COV_DCM_RTM_DESIGN_LOWER_LAYER XF */
    {
      /* #50 Send the appropriate NRC by using the linear buffer if needed. */
      Dcm_SetNegResponse(DCM_DIAG_CANCEL_OP_NRC);
      lResult = DCM_E_PROCESSINGDONE;
    }

    /* #60 Initialize the page buffer. */
    Dcm_PagedBufferInit();
    Dcm_TskClrEvent(DCM_TSK_ID_PGDBUF, DCM_TSK_EV_ALL_EVENTS);
  }

  return lResult;
}
#endif /* (DCM_PAGED_BUFFER_ENABLED == STD_ON) */

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferTask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_PagedBufferTask(Dcm_TskTaskEvOptType ev
                                                  ,Dcm_TskTaskEvPtrType pPostEv)
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(ev);                                                                                                                        /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* currently no other events are possible to be set for this task -> no need to check any flags */
# if (DCM_TSK_EV_PGDBUF_MSB != 0x01u)
#  error "New events have been added Dcm_PagedBufferTask! Make set event check here!"
# endif

  /*=================================*
   BEGIN CRITICAL SECTION
   *=================================*/
  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */

  /* If any diagnostic job is open: */
  if( ((Dcm_InstanceContext.Diag.State & (DCM_DIAG_STATE_PROCESS | DCM_DIAG_STATE_ON_TX)) != 0)
    && (!Dcm_NetBufferIsFree(Dcm_InstanceContext.PagedBuffer.BufferHdl)) )                                                                           /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY TX tx tx */
  {
    /* Avoid buffer releasing on asynchronous TxConfirmation with failed status. */
    Dcm_NetBufferUsageEnter(Dcm_InstanceContext.PagedBuffer.BufferHdl);
    /*=================================*
     END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */

    /* Update paged data. */
    lStdResult = Dcm_PagedBufferUpdatePage();

    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /*=================================*
     BEGIN CRITICAL SECTION
     *=================================*/
    Dcm_NetBufferUsageLeave(Dcm_InstanceContext.PagedBuffer.BufferHdl);

    /* If the application needs more time: */
    if(lStdResult == DCM_E_PENDING)
    {
      /* If the paged buffer was the last user, then do nothing later. */
      if(!Dcm_NetBufferIsFree(Dcm_InstanceContext.PagedBuffer.BufferHdl))                                                                            /* COV_DCM_RTM_UNREACHABLE_COMPLEXITY TX */
      {
        Dcm_TskSetLocalEvent(*pPostEv, DCM_TSK_EV_PGDBUF_UPDATE_PAGE);
      }/* else - buffer is free - no more data is to be expected */
    }/* else - that is all */
    /*=================================*
     END CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }
  else
  {
   /*=================================*
    END CRITICAL SECTION
    *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }
}
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferDataPadding()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_PagedBufferDataPadding(Dcm_MsgType pData
                                                                   ,Dcm_CfgNetBufferSizePtrType pAvailData)
{
  /* Check for remaining parts to be padded. */
  Dcm_UtiMemSetUintX(pData, Dcm_MsgItemType, 0x00u, *pAvailData);                                                                                    /* PRQA S 3109 */ /* MD_MSR_14.3 */

  /* Signalize that all requested data are provided. */
  *pAvailData = 0;

  /* Enforce transmission of the current part. */
  return DCM_E_BUFFERTOOLOW;
}
#endif

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_PagedBufferStart()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_PagedBufferStart(Dcm_PagedBufferUpdateFuncType updateFunc
                                                   ,Dcm_PagedBufferCancelFuncType cancelFunc
                                                   ,Dcm_MsgLenType resDataLen)
{
  /* Once multiple multi frame response started, can not be started again */
  Dcm_DebugAssert((Dcm_InstanceContext.PagedBuffer.State == DCM_PAGEDBUFFER_STATE_INACTIVE), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                  /* COV_DCM_RTM_DEV_DEBUG XF */
  /* No multiple multi frame response if a NRC has been already registered */
  Dcm_DebugAssert((Dcm_InstanceContext.Diag.ErrorRegister == DCM_E_OK), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                       /* COV_DCM_RTM_DEV_DEBUG XF */

  /* #10 Initialize paged-buffer response transmission. */
  Dcm_InstanceContext.PagedBuffer.UpdateFunc     = updateFunc;
  Dcm_InstanceContext.PagedBuffer.CancelFunc     = cancelFunc;
# if (DCM_NET_MULTI_BUFFER_ENABLED == STD_ON)                                                                                                        /* COV_DCM_UNSUPPORTED XF */
  Dcm_InstanceContext.PagedBuffer.BufferHdl      = Dcm_NetTranspObjGetBufferHandleValue(Dcm_DiagGetTranspObj());
# endif
  Dcm_InstanceContext.PagedBuffer.BufferInfoPtr  = Dcm_NetGetBufferObjOfTranspObj(Dcm_DiagGetTranspObj());
  Dcm_InstanceContext.PagedBuffer.WriteIndex     = (Dcm_CfgNetBufferSizeMemType)(Dcm_InstanceContext.Diag.MsgContext.resDataLen + 1u); /* Write behind SId and the prepared data */
  Dcm_InstanceContext.PagedBuffer.ReadIndex      = 0u;
  Dcm_InstanceContext.PagedBuffer.RemainingLen   = resDataLen; /* Keep track of response data to be copied. */
  Dcm_InstanceContext.PagedBuffer.State          = DCM_PAGEDBUFFER_STATE_ACTIVATED;
  Dcm_InstanceContext.PagedBuffer.UpdateFinished = FALSE;
  Dcm_InstanceContext.PagedBuffer.IsInUnderrun   = FALSE;

  /* #20 Calculate total response length, considering any already linearly written data. */
  Dcm_InstanceContext.Diag.MsgContext.resDataLen += (Dcm_MsgLenType)resDataLen;

  /* #30 Initiate paged-data reader. */
  Dcm_TskSetEvent(DCM_TSK_ID_PGDBUF, DCM_TSK_EV_PGDBUF_UPDATE_PAGE);
}
#endif
/**********************************************************************************************************************
 *  Dcm_RepeaterExecute()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_RepeaterExecute(void)
{
  Std_ReturnType lStdResult;
  DCM_UTIRTLMTR_CTR_DEF

#if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
  Dcm_OpStatusType opStatusBckp = Dcm_InstanceContext.Repeater.Contexts.OpStatus;/* make a backup in case the processor uses the Dcm_RepeaterSetCallee API */
#endif

  DCM_UTIRTLMTR_CTR_INIT
  DCM_UTI_LOOP_FOR_EVER
  {
    lStdResult = Dcm_InstanceContext.Repeater.Callee(Dcm_InstanceContext.Repeater.Contexts.OpStatus
                                                   ,&Dcm_InstanceContext.Diag.MsgContext);

#if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
    if(opStatusBckp == DCM_CANCEL)
    {
# if (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) || \
     (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
      if(Dcm_InstanceContext.Repeater.Contexts.User == DCM_REPEATER_USER_DEM)
      {
        Dcm_DemAPI_CancelOperation();/* signal to DEM not to expect any further calls */
      }
# endif
# if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
      Dcm_DidMgrCancelOperation();
# endif
      Dcm_InstanceContext.Diag.ErrorRegister = DCM_DIAG_CANCEL_OP_NRC;/* always return the cancellation NRC! */
      lStdResult = DCM_E_PROCESSINGDONE;/* enforce finalization */
    }
#endif
    if(lStdResult != DCM_E_LOOP)
    {
      break;
    }/* else - just loop again */

    Dcm_RepeaterResetOpStatus();

    DCM_UTIRTLMTR_CTR_NEXT /* if link-time and limit = 0 -> leads to overflow and practically no limitation (at least 255 iterations to "pending")*/
    DCM_UTIRTLMTR_CTR_HANDLE_AND_BREAK(lStdResult, DCM_E_PENDING_LIMITER) /* signal retry */                                                         /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_RepeaterDeadEnd()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_RepeaterDeadEnd(Dcm_OpStatusType opStatus
                                                            ,Dcm_MsgContextPtrType pMsgContext)                                                      /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  return DCM_E_OK;
}
#if (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON)                                                                                                          /* COV_DCM_SUPPORT_ALWAYS TX */
# if (DCM_MODEMGR_MONITORING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeTaskMonitor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_ModeTaskMonitor(Dcm_TskTaskEvOptType ev
                                                  ,Dcm_TskTaskEvPtrType pPostEv)                                                                     /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  DCM_IGNORE_UNREF_PARAM(pPostEv);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(ev);                                                                                                                        /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_MODE_CTRLDTCSETTING_MONITOR_ENABLED == STD_ON)
  if( Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_MODE_MON_SVC85) )
  {
    uint8 lNrc;/* the value is not used, just the standard API requires it */
    if (Dcm_CfgModeMgrRules[DCM_MODE_CTRLDTCSETTING_MONITOR_MODERULE_REF](&lNrc) == FALSE)/* condition failed - consider the returned NRC */
    {
      Dcm_Svc85EnableDtcSetting();
    }
    else
    {
      Dcm_TskSetLocalEvent(*pPostEv,DCM_TSK_EV_MODE_MON_SVC85); /* try next task */
    }
  }
#  endif

#  if (DCM_MODE_COMMCTRL_MONITOR_ENABLED == STD_ON)
  if( Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_MODE_MON_SVC28) )
  {
    uint8 lNrc;/* the value is not used, just the standard API requires it */
    if (Dcm_CfgModeMgrRules[DCM_MODE_COMMCTRL_MONITOR_MODERULE_REF](&lNrc) == FALSE)/* condition failed - consider the returned NRC */
    {
      Dcm_Svc28EnableCommunication();
    }
    else
    {
      Dcm_TskSetLocalEvent(*pPostEv, DCM_TSK_EV_MODE_MON_SVC28); /* try next task */
    }
  }
#  endif
}
# endif

# if (DCM_MODE_CTRLDTCSETTING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchDtcSetting()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_ModeSwitchDtcSetting(Rte_ModeType_DcmControlDtcSetting newMode, uint32 DTCGroup)
{
  Std_ReturnType lStdResult;

  /* execute transition */
  lStdResult = Rte_Switch_DcmControlDtcSetting_DcmControlDtcSetting(newMode);

  DCM_IGNORE_UNREF_PARAM(lStdResult);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(DTCGroup);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  Dcm_DebugApiCheckRte((lStdResult == RTE_E_OK), DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)

  /* Update lokal states */
  Dcm_ModeSetControlDtcSettingGroup(DTCGroup);
  Dcm_ModeSetControlDtcSettingMode(newMode);

#  if (DCM_MODE_CTRLDTCSETTING_MONITOR_ENABLED == STD_ON)
  /* Start polling for a leave condition mode rule */
  if(newMode == RTE_MODE_DcmControlDtcSetting_ENABLEDTCSETTING)
  {
    Dcm_TskClrEvent(DCM_TSK_ID_MODE_MONITOR, DCM_TSK_EV_MODE_MON_SVC85);
  }
  else
  {
    Dcm_TskSetEvent(DCM_TSK_ID_MODE_MONITOR, DCM_TSK_EV_MODE_MON_SVC85);
  }
#  endif
}
# endif

# if (DCM_MODE_COMMCTRL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ModeSwitchCommControl()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_ModeSwitchCommControl(Dcm_CfgNetNetIdRefOptType networkRef
                                                        ,Dcm_CommunicationModeType newMode)
{
  NetworkHandleType lNetwork = Dcm_PbCfgNetAllComMChannelMap[networkRef];

  Dcm_ModeArEnvBswMComControlModeChange(lNetwork, newMode);/* notify BswM */
  Dcm_ModeOnComControlModeChange(lNetwork, Dcm_ModeComCtrlModeMap[newMode]); /* notify the application */

  Dcm_ModeSetCommControlState(networkRef, newMode);

#  if (DCM_MODE_COMMCTRL_MONITOR_ENABLED == STD_ON)
  if((newMode & DCM_SVC_28_CTRL_OP_MASK) == 0)/* operation is without any disabling */
  {
    Dcm_TskClrEvent(DCM_TSK_ID_MODE_MONITOR, DCM_TSK_EV_MODE_MON_SVC28);
  }
  else
  {
    Dcm_TskSetEvent(DCM_TSK_ID_MODE_MONITOR, DCM_TSK_EV_MODE_MON_SVC28);
  }
#  endif
}
# endif
#endif /* (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_StateCheck()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_StateCheck(Dcm_CfgStateRefOptType stateRef
                                                                     ,Dcm_DiagCheckLvlType chkLevel)
{
  Dcm_NegativeResponseCodeType lNrcResult;

  CONSTP2CONST(Dcm_CfgStateDiagStateInfoType, AUTOMATIC, DCM_CONST) pStatePreconditions = &Dcm_StateGetPreconditionStates(stateRef);

  Dcm_DebugAssert((chkLevel < DCM_NUM_DIAG_CHK_LVLS), DCM_SID_INTERNAL, DCM_E_PARAM)                                                                 /* COV_DCM_RTM_DEV_DEBUG XF */

  if(!Dcm_StateIsSupportedInSession(*pStatePreconditions))                                                                                           /* COV_DCM_RTM_DESIGN_LOWER_LAYER XF */
  {
    lNrcResult = Dcm_StateSessionNrcs[chkLevel]; /* Special handling on session state group */
  }
  else
#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
  if(!Dcm_StateIsSupportedInSecurityLevel(*pStatePreconditions))
  {
    lNrcResult = DCM_E_SECURITYACCESSDENIED;
  }
  else
#endif
  {
#if(DCM_MODEMGR_CHECK_SUPPORT_ENABLED == STD_ON)
    lNrcResult = Dcm_ModeCheck(Dcm_CfgStatePreconditions[stateRef].ModeRuleRef);
#else
    lNrcResult = DCM_E_POSITIVERESPONSE;
#endif
  }

  return lNrcResult;
}

/**********************************************************************************************************************
 *  Dcm_StateSetSession()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_StateSetSession(Dcm_StateIndexOptType stateRef)
{
  Std_ReturnType lStdResult;

#if (DCM_SVC_86_RST_ON_DSC_ENABLED == STD_ON) || \
    (DCM_STATE_SESSION_NOTIFICATION_ENABLED == STD_ON)                                                                                               /* COV_DCM_UNSUPPORTED TF xf tf */
  Dcm_CfgStateGroupOptType oldSession;

  oldSession = Dcm_SingletonContext.StateMgr.Preconditions.Session;
#endif

  Dcm_SplitTaskEnterCS();/* avoid interruption from the Dcm_NetTaskRx */                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
 /*=================================*
  BEGIN CRITICAL SECTION
  *=================================*/
  Dcm_SingletonContext.StateMgr.Preconditions.Session = Dcm_UtiGetBitFromIndex(Dcm_CfgStateGroupMemType, stateRef);
  Dcm_StateSyncPendingSession();/* synchronize with the currently active session */
 /*=================================*
  END CRITICAL SECTION
  *=================================*/
  Dcm_SplitTaskLeaveCS();                                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */

  /* Notify application */
  lStdResult = Rte_Switch_DcmDiagnosticSessionControl_DcmDiagnosticSessionControl(Dcm_CfgStateSessionInfo[stateRef].Mode);

  DCM_IGNORE_UNREF_PARAM(lStdResult);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */
  Dcm_DebugApiCheckRte((lStdResult == RTE_E_OK),DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)

#if (DCM_STATE_SESSION_NOTIFICATION_ENABLED == STD_ON)
  Dcm_StateExecOnStateChangeFunc(Dcm_CfgStateSessionNotificationInfo, Dcm_StateGetSessionValue(Dcm_UtiGetBitPosition(oldSession)), Dcm_StateGetSessionValue(stateRef));
#endif

  /* release all communication requests */
  if(Dcm_StateIsDefaultSessionActive())
  {
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
    if(Dcm_SingletonContext.Network.KeepAlive == FALSE)
#endif
    {
      Dcm_NetUnRegisterAllComMActivity();
    }

#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
    Dcm_Svc85EnableDtcSetting();
#endif
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
    Dcm_Svc28EnableCommunication();
#endif
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
    Dcm_Svc2ASchdStopAll();
#endif
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
    Dcm_Svc2FReturnControlToEcu();
#endif
  }

#if (DCM_SVC_86_RST_ON_DSC_ENABLED == STD_ON)                                                                                                        /* COV_DCM_UNSUPPORTED XF */
  Dcm_ExtSvc86OnChangeSession(oldSession, Dcm_SingletonContext.StateMgr.Preconditions.Session);
#endif

#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
  /* Reset security access too (including service processor notification for a state change) */
  Dcm_StateSetSecurity(0);
#else
  /* Notify all service processors that are interested in a state change. */
  Dcm_StateNotifyServiceProcessors();
#endif
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */

#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_StateSetSecurity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_StateSetSecurity(Dcm_StateIndexOptType stateRef)
{
# if (DCM_MODE_SECURITY_ACCESS_ENABLED == STD_ON) || \
     (DCM_STATE_SECURITY_NOTIFICATION_ENABLED == STD_ON)
  Dcm_CfgStateGroupOptType oldLevel;
# endif

# if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
  Dcm_Svc27ResetSequence();
# endif

# if (DCM_MODE_SECURITY_ACCESS_ENABLED == STD_ON) || \
     (DCM_STATE_SECURITY_NOTIFICATION_ENABLED == STD_ON)
  oldLevel = Dcm_SingletonContext.StateMgr.Preconditions.Security;
# endif

  Dcm_SingletonContext.StateMgr.Preconditions.Security = Dcm_UtiGetBitFromIndex(Dcm_CfgStateGroupMemType, stateRef);

# if (DCM_MODE_SECURITY_ACCESS_ENABLED == STD_ON) || \
     (DCM_STATE_SECURITY_NOTIFICATION_ENABLED == STD_ON)
  if((oldLevel & Dcm_SingletonContext.StateMgr.Preconditions.Security) == 0) /* consider only non-self transitions (i.e. Locked->Locked) */
  {
#  if (DCM_MODE_SECURITY_ACCESS_ENABLED == STD_ON)
    Std_ReturnType                 lStdResult;
    Rte_ModeType_DcmSecurityAccess newMode;

    newMode = (Rte_ModeType_DcmSecurityAccess)((stateRef == 0)?RTE_MODE_DcmSecurityAccess_LockedLevel
                                                              :Dcm_CfgStateSecurityInfo[stateRef - 1].Mode);

    /* Notify application */
    lStdResult = Rte_Switch_DcmSecurityAccess_DcmSecurityAccess(newMode);

    DCM_IGNORE_UNREF_PARAM(lStdResult);                                                                                                              /* PRQA S 3112 */ /* MD_Dcm_3112 */
    Dcm_DebugApiCheckRte((lStdResult == RTE_E_OK), DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)
#  endif

#  if (DCM_STATE_SECURITY_NOTIFICATION_ENABLED == STD_ON)
    {
      Dcm_SecLevelType secLev = Dcm_UtiGetBitPosition(oldLevel); /* Local variable needed to avoid warnings for side-effects on macro Dcm_StateGetSecurityValue(). */
      Dcm_StateExecOnStateChangeFunc(Dcm_CfgStateSecurityNotificationInfo, Dcm_StateGetSecurityValue(secLev), Dcm_StateGetSecurityValue(stateRef));
    }
#  endif
  }
# endif
  /* Notify all service processors that are interested in a state change. */
  Dcm_StateNotifyServiceProcessors();
}
#endif
/**********************************************************************************************************************
 *  Dcm_TskScheduler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_TskScheduler(Dcm_TskTaskPrioMemType tskPrio)
{
  DCM_IGNORE_UNREF_PARAM(tskPrio);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if(Dcm_SingletonContext.TaskMgr.TaskScheduler[Dcm_TskWrapPrioValue(tskPrio)].SchdIsActive == TRUE)
  {
    Dcm_TskTaskIdOptType taskIter;
    Dcm_TskTaskEvOptType ev;

    /*
     * No interrupt protection needed since:
     * If a SetEvent is called and interrupts this assignment, then it sets this flag to true. Two scenarios are possible:
     * - The TRUE signal may be gone - it does not matter since the scheduler is already activated.
     * - The TRUE signal remains - in the worst case the scheduler will be executed once more later but will not have any active tasks.
     */
    Dcm_SingletonContext.TaskMgr.TaskScheduler[Dcm_TskWrapPrioValue(tskPrio)].SchdIsActive = FALSE; /* per default - no active tasks any more. If any SetEvent executed during the task execution -> the flag will be set again */

    for(taskIter = 0; taskIter < DCM_TSK_NUM_TASKS; ++taskIter)
    {
#if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
      if(tskPrio == Dcm_TskTaskInfo[taskIter].TskPrio)
#endif
      {
        ev = Dcm_TskGetEvent(taskIter);
        if(ev != 0u)
        {
          Dcm_TskTaskEvOptType postEv = 0u;

          do
          {
            Dcm_TskClrEvent(taskIter, (Dcm_TskTaskEvMemType)ev); /* clear only already known events */

#if (DCM_TSK_TRACING_ENABLED == STD_ON)
            /* Register task */
            Dcm_SplitTaskEnterCS();
            Dcm_DebugAssert(!Dcm_TskTraceIsFull(), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)

            Dcm_TskTraceTskPush(taskIter);                                                                                                           /* PRQA S 3440 */ /* MD_Dcm_OptimizedInlineCode_3440 */

            Dcm_SplitTaskLeaveCS();
#endif

            /* activate task */
            Dcm_TskTaskInfo[taskIter].TskFunc(ev, &postEv);

#if (DCM_TSK_TRACING_ENABLED == STD_ON)
            /* Unregister task */
            Dcm_SplitTaskEnterCS();
            Dcm_DebugAssert(!Dcm_TskTraceIsEmpty(), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)

            Dcm_TskTraceTskPop();

            Dcm_SplitTaskLeaveCS();
#endif

            if((Dcm_TskTaskInfo[taskIter].TskAtr & DCM_TSK_ATR_EXEC_MULTI) != 0)
            {
              ev = Dcm_TskGetEvent(taskIter);/* still something to do now? */
            }
            else
            {
              ev = 0u;/* execute only once */
            }
          }
          while(ev != 0u);

          if(postEv != 0u) /* Consider any post events */
          {
            Dcm_TskSetEvent(taskIter, (Dcm_TskTaskEvMemType)postEv);
          }
        }
      }
    }
  }
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */

#if (DCM_TSK_TASK_COMPLEX_KILL_ENABLED == STD_ON)                                                                                                    /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_TskReviveAllTasks()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_TskReviveAllTasks(void)
{
   Dcm_TskTaskIdOptType tskIter;

   for(tskIter = 0; tskIter < DCM_TSK_NUM_TASKS; ++tskIter)
   {
     Dcm_TskClrFlag(tskIter, DCM_TSK_TASK_FLAG_KILLED);                                                                                              /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
   }
}
#endif
/**********************************************************************************************************************
 *  Dcm_TimerTask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_TimerTask(Dcm_TskTaskEvOptType ev
                                            ,Dcm_TskTaskEvPtrType pPostEv)
{
  Dcm_TmrMaskOptType    expired = 0u;
  Dcm_TmrTimerIdOptType timerIter;

#if (DCM_TSK_EV_TIMER_MSB != 0x01u)
# error "New events have been added for Dcm_TimerTask! Make set event check here!"
#endif
  /* the only event here is the DCM_TSK_EV_TIMER_ACTIVE. If not set, this task will not be called -> no additional event check is necessary */
  DCM_IGNORE_UNREF_PARAM(ev);                                                                                                                        /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
   BEGIN CRITICAL SECTION
   *=================================*/
  for(timerIter = 0; timerIter < DCM_TMR_NUM_TIMERS_CASTED; ++timerIter)
  {
    expired <<=1; /* next timer */
    if(Dcm_SingletonContext.TimerMgr.Timer[timerIter] != 0u)
    {
      --Dcm_SingletonContext.TimerMgr.Timer[timerIter];
      if(Dcm_SingletonContext.TimerMgr.Timer[timerIter] == 0u)
      {
        expired |= 0x01u;
      }
      else
      {
        *pPostEv |= DCM_TSK_EV_TIMER_ACTIVE;/* reactivate the task next time since at least one timer still active */
      }
    }
  }
 /*=================================*
  END CRITICAL SECTION
  *=================================*/
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */

  DCM_UTI_BIT_SCAN_LOOP(expired)
  {
    --timerIter; /* pre-decrement since the iterator equals at first DCM_TMR_NUM_TIMERS_CASTED */
    if((expired & 0x01u) != 0)
    {
      Dcm_TmrTimerCntrMemType reloadTicks = Dcm_TmrTimerInfo[timerIter].ToFunc();
      if(reloadTicks != 0)                                                                                                                           /* COV_DCM_RTM_DESIGN_LOWER_LAYER XF */
      {
        Dcm_TmrStartTimer(timerIter, reloadTicks);
      }
    }
  }
}
#if (DCM_DEMAPIMGR_SUPPORT_ENABLED == STD_ON)
# if (DCM_DEMAPI_RETVAL_TO_NRC_MAP_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DemApiGetNrcForDemRetValue()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
static FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_DemApiGetNrcForDemRetValue(uint8 demResult, Dcm_Uint8ConstDataPtrType demResult2NrcMap)
{
  Dcm_NegativeResponseCodeType lNrcResult = DCM_E_PANIC_NRC;
  do
  {
    if(demResult2NrcMap[0] == demResult)
    {
      lNrcResult = demResult2NrcMap[1];
      break;
    }
    demResult2NrcMap = &demResult2NrcMap[2];
  }
  while(demResult2NrcMap[0] != E_OK);

#  if(DCM_DEV_ERROR_REPORT == STD_ON)
  if(demResult2NrcMap[0] == E_OK)
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
  }
#  endif
  return lNrcResult;
}
# endif

# if (DCM_DEMAPI_GETNEXTFILTEREDITEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DemApiConvDemRsltGetNextFilteredItem()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
static FUNC(Std_ReturnType, DCM_CODE) Dcm_DemApiConvDemRsltGetNextFilteredItem(Dcm_DemReturnGetNextFilteredItemType demResult)
{
  Std_ReturnType lDcmResult;
  switch(demResult)
  {
  case DCM_DEM_RET_FILTERED_NO_ITEMS:
    lDcmResult = DCM_E_OK;/* signal end of list */
    break;
  case DCM_DEM_RET_FILTERED_PENDING:
    lDcmResult = DCM_E_PENDING;/* signal end of list */
    break;
#  if defined(DCM_DEM_RET_FILTERED_BUFFER_TOO_SMALL)                                                                                                 /* COV_DCM_SUPPORT_RESTRICTED TX */
  case DCM_DEM_RET_FILTERED_BUFFER_TOO_SMALL:
    lDcmResult = DCM_E_BUFFERTOOLOW;
    break;
#  endif
  default:
    Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);

    lDcmResult = DCM_E_NOT_OK;
    Dcm_SetNegResponse(DCM_E_PANIC_NRC);
    break;
  }
  return lDcmResult;
}
# endif
#endif /* (DCM_DEMAPIMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_DIDMGR_DYNDID_DEEP_CHECK_ON_READ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrDynDidStateCheck()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_DidMgrDynDidStateCheck(
                                                                      Dcm_DidMgrDidInfoContextPtrType pDidInfoContext)                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_NegativeResponseCodeType lNrc;
  lNrc = Dcm_StateCheck(pDidInfoContext->Descriptor.DidOpInfoPtr->ExecCondRef, DCM_DIAG_CHK_LVL_PARAMETER);
  if(lNrc == DCM_E_POSITIVERESPONSE)
  {
    if(Dcm_DidMgrIsOpSupported(pDidInfoContext->Descriptor.DidInfoPtr, DCM_DIDMGR_OP_DEFINE)) /* for DynDID check source states */
    {
      lNrc = Dcm_Svc2CStateCheckSrcItems(pDidInfoContext->Descriptor.DidInfoPtr->OpRef);
    }
  }/* else - lNrc already set */
  return lNrc;
}
# endif

# if (DCM_DIDMGR_CANCEL_OP_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrCancelOperation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DidMgrCancelOperation(void)
{
  Dcm_DidMgrInitMainResources();
}
# endif

# if (DCM_DIDMGR_OPTYPE_READ_LENGTH_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadLength(Dcm_OpStatusType                opStatus
                                                             ,Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                             ,Dcm_NegativeResponseCodePtrType errorCode)                                             /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
#  if (DCM_DIDMGR_MSIG_OPTYPE_READ_LENGTH_ENABLED == STD_ON)
#   error "Only one signal (the last one of a DID) can have dynamic length!"
#  else
  Std_ReturnType lStdResult = DCM_E_OK;

  /* read length */
  if(Dcm_DidMgrIsOpTypeSupported(pDidInfoContext->Descriptor.DidOpInfoPtr, DCM_DIDMGR_OPTYPE_READLENGTH))
  {
    Dcm_DidMgrDidLengthType signalLength;

    Dcm_DidMgrGetOpClassInfo(pDidInfoContext, DCM_DIDMGR_OPTYPE_READLENGTH);
    lStdResult = Dcm_DidMgrReadLengthSignal(opStatus, pDidInfoContext, &signalLength, errorCode);

    if(lStdResult == DCM_E_OK)
    {
      /* Set concrete DID length */
      pDidInfoContext->DidLength = (uint16)(pDidInfoContext->Descriptor.DidInfoPtr->MinLength + signalLength);
    }
    /* else - DCM_E_PENDING, DCM_E_NOT_OK -> just delegate */
  }/* else - static length -> length already set in pDidInfoContext */
  return lStdResult;
#  endif
}
# endif

# if (DCM_DIDMGR_OPTYPE_READ_CHECKCOND_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadCheckCond()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadCheckCond(Dcm_OpStatusType opStatus
                                                                ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                                ,Dcm_NegativeResponseCodePtrType errorCode)
{
#  if (DCM_DIDMGR_MSIG_OPTYPE_READ_CHKCOND_ENABLED == STD_ON)
  Std_ReturnType lStdResult;

  if(opStatus == DCM_INITIAL)
  {
    /* Initialize DID handler */
    Dcm_DidMgrOpTypeHandlerInit(pDidInfoContext, pDidOpTypeContext);
  }

  DCM_UTI_LOOP_FOR_EVER
  {
    lStdResult = Dcm_DidMgrReadCheckCondSignal(opStatus
                                              ,pDidOpTypeContext->Base.SignalOpList
                                              ,errorCode);
    if(lStdResult != DCM_E_OK)
    {
      /* on pending or not OK -> just leave */
      break;/* try later */
    }

    pDidOpTypeContext->Base.NumSignals--;
    if(pDidOpTypeContext->Base.NumSignals == 0u)
    {
      break;                                                                                                                                         /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
    }
    /* next signal */
    Dcm_UtiNextItemByPtr(pDidOpTypeContext->Base.SignalOpList,  1u);
    opStatus = DCM_INITIAL;/* reset op status */
  }

  return lStdResult;
#  else
  DCM_IGNORE_UNREF_PARAM(pDidOpTypeContext);                                                                                                         /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_DidMgrReadCheckCondSignal(opStatus
                                      ,pDidInfoContext->Descriptor.DidSignalOpClassInfoPtr
                                      ,errorCode);
#  endif
}
# endif

/**********************************************************************************************************************
 *  Dcm_DidMgrGetDidOpInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DidMgrGetDidOpInfo(Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                     ,Dcm_DidMgrOpOptType didOp)
{
  pDidInfoContext->Descriptor.DidOpInfoPtr = &Dcm_CfgDidMgrOpInfo[pDidInfoContext->Descriptor.DidInfoPtr->OpBaseIdx];
  /* 0x01 ->0x00 -> already found
   * 0x02 ->0x01 -> iterate once
   * .Etc*/
  --didOp; /* there is always at least one operation configured */
  didOp &= pDidInfoContext->Descriptor.DidInfoPtr->Operations;  /* clear all flags above this operation index (not relevant)*/

  while(didOp != 0)
  {
    Dcm_UtiNextItemByPtr(pDidInfoContext->Descriptor.DidOpInfoPtr,1u);
    didOp &= (Dcm_DidMgrOpOptType)(didOp - 1); /* clear the least significant bit set */
  }
}

/**********************************************************************************************************************
 *  Dcm_DidMgrGetOpClassInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DidMgrGetOpClassInfo(Dcm_DidMgrDidInfoContextPtrType pDidInfoContext
                                                       ,Dcm_DidMgrOpCallOptType opType)
{
# if (DCM_DIDMGR_MULTISIGNAL_ENABLED == STD_ON)
  pDidInfoContext->Descriptor.DidOpClassInfoPtr = &Dcm_CfgDidMgrDidOpClassInfo[pDidInfoContext->Descriptor.DidOpInfoPtr->OpTypeBaseIdx];
# else
  pDidInfoContext->Descriptor.DidSignalOpClassInfoPtr = &Dcm_CfgDidMgrSignalOpClassInfo[pDidInfoContext->Descriptor.DidOpInfoPtr->OpTypeBaseIdx];
# endif

  /* 0x01 ->0x00 -> already found
   * 0x02 ->0x01 -> iterate once
   * .Etc*/
  --opType; /* there is always at least one operation configured */
  opType &= pDidInfoContext->Descriptor.DidOpInfoPtr->CallTypes; /* clear all flags above this operation index (not relevant)*/

  while(opType != 0)
  {
# if (DCM_DIDMGR_MULTISIGNAL_ENABLED == STD_ON)
    Dcm_UtiNextItemByPtr(pDidInfoContext->Descriptor.DidOpClassInfoPtr, 1u);
# else
    Dcm_UtiNextItemByPtr(pDidInfoContext->Descriptor.DidSignalOpClassInfoPtr,1u);
# endif
    opType &= (Dcm_DidMgrOpOptType)(opType - 1); /* clear the least significant bit set */
  }

# if (DCM_DIDMGR_MULTISIGNAL_ENABLED == STD_ON)
  pDidInfoContext->Descriptor.DidSignalOpClassInfoPtr = &Dcm_CfgDidMgrSignalOpClassInfo[pDidInfoContext->Descriptor.DidOpClassInfoPtr->OpClassRef];
# endif
}

/**********************************************************************************************************************
 *  Dcm_DidMgrGetDidInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrGetDidInfo(Dcm_OpStatusType                  opStatus
                                                             ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                             ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext                                    /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                             ,Dcm_DidMgrOpOptType               didOp)
{
  Std_ReturnType  lStdReturn;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pDidOpTypeContext);                                                                                                         /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_DIDMGR_ASYNC_LOOKUP_ENABLED == STD_ON)
  lStdReturn = DCM_E_NOT_OK;

  /* #10 On the very first call: */
  if(opStatus == DCM_INITIAL)
  {
    /* #20 Determine the lookup engine to run first (DID range or concrete DID). */
#  if (DCM_DIDMGR_RANGE_SUPPORT_ENABLED == STD_ON)
    pDidOpTypeContext->OpType.LookUp.State = DCM_DIDMGR_LOOKUP_STATE_DIDRANGE;
#  else
    pDidOpTypeContext->OpType.LookUp.State = DCM_DIDMGR_LOOKUP_STATE_CONCRETEDID;
#  endif
  }
  /* #25 Otherwise: proceed with next steps. */
# endif

# if (DCM_DIDMGR_RANGE_SUPPORT_ENABLED == STD_ON)
  /* #30 If current progress is to (still) lookup for a DID range: */
  if(pDidOpTypeContext->OpType.LookUp.State == DCM_DIDMGR_LOOKUP_STATE_DIDRANGE)
  {
    /* #40 Delegate search to the DID range lookup engine. */
    lStdReturn = Dcm_DidMgrDidRangeLookUp(opStatus, pDidInfoContext, didOp);

    /* #50 Evaluate result: */
#  if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
    if(opStatus == DCM_CANCEL)
    {
      /* #60 If the current call is a cancellation event: Terminate immediately any further processing. */
      lStdReturn = DCM_E_NOT_OK;
    }
    else
#  endif
    if(lStdReturn == DCM_E_NOT_OK)
    {
      /* #70 Otherwise: If no match found: Continue with concrete DID look up. */
      pDidOpTypeContext->OpType.LookUp.State = DCM_DIDMGR_LOOKUP_STATE_CONCRETEDID;
    }
    else
#  if (DCM_DIDMGR_EXTENDED_LOOKUP_ENABLED == STD_ON)
    if(lStdReturn == DCM_E_OK)
    {
      /* #80 Otherwise: If match found: Go on with optional DID look up result filtering. */
      pDidOpTypeContext->OpType.LookUp.State = DCM_DIDMGR_LOOKUP_STATE_DIDFILTER_EXTERN;
    }
    else
#  endif
#  if (DCM_DIDMGR_OPTYPE_RANGE_ISAVAIL_ENABLED == STD_ON)
    if(lStdReturn == DCM_E_LOOKUP_MATCH_FOUND)
    {
      /* #90 Otherwise: If range match found but it was a gap: Report DID as not supported. */
      lStdReturn = DCM_E_NOT_OK;
    }
    else
#  endif
    {
      /* #100 Otherwise: Just return the final result: (DCM_E_PENDING | DCM_E_OK (if no extended look up) | DCM_E_NOT_OK (if no gaps) ) */
    }
  }
  /* #110 Otherwise - keep current result: DCM_E_NOT_OK */
# endif

# if (DCM_DIDMGR_ASYNC_LOOKUP_ENABLED == STD_ON)
  /* #120 If current progress is to lookup for a concrete DID: */
  if(pDidOpTypeContext->OpType.LookUp.State == DCM_DIDMGR_LOOKUP_STATE_CONCRETEDID)
# endif
  {
    /* #130 Start concrete DID lookup engine. */
    lStdReturn = Dcm_DidMgrConcreteDidLookUp(pDidInfoContext, didOp);

    /* #140 Evaluate result: */
# if (DCM_DIDMGR_EXTENDED_LOOKUP_ENABLED == STD_ON)
    if(lStdReturn == DCM_E_OK)
    {
      /* #150 If valid DID found: proceed with optional lookup result filtering. */
      opStatus = DCM_INITIAL; /* Prepare for new asyncrhonous calling sequence. */
      pDidOpTypeContext->OpType.LookUp.State = DCM_DIDMGR_LOOKUP_STATE_DIDFILTER_EXTERN;
    }
# endif
  }
  /* #155 Otherwise - keep current result: DCM_E_OK, DCM_E_NOT_OK, DCM_E_PENDING */

# if (DCM_DIDMGR_EXTENDED_LOOKUP_ENABLED == STD_ON)
  /* #160 If any valid DID(range) found: */
  if(pDidOpTypeContext->OpType.LookUp.State == DCM_DIDMGR_LOOKUP_STATE_DIDFILTER_EXTERN)
  {
    /* #170 Proceed with optional lookup result filtering. */
    lStdReturn = Dcm_FilterDidLookUpResult(opStatus, pDidInfoContext->Did, (Dcm_DidOpType)didOp);

    /* #180 Evaluate result: */
#  if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
    if(opStatus == DCM_CANCEL)
    {
      /* #190 If the current call is a cancellation event: Terminate immediately any further processing. */
      lStdReturn = DCM_E_NOT_OK;
    }
#  endif

#  if (DCM_DEV_ERROR_DETECT == STD_ON)
    /* #200 If an valid/unexpected return value: */
    if( (lStdReturn != DCM_E_OK)
      &&(lStdReturn != DCM_E_PENDING)
      &&(lStdReturn != DCM_E_NOT_OK) )
    {
      /* #210 Unexpected return value is treated as "DID not supported". */
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
      lStdReturn = DCM_E_NOT_OK;
    }
#  endif
  }
  /* #220 Otherwise - keep current result: DCM_E_OK, DCM_E_NOT_OK, DCM_E_PENDING */
# endif

  /* #230 If final result available and it is that the DID is supported: */
  if(lStdReturn == DCM_E_OK)
  {
    /* #240 Always perform standard filtering (variant, session, etc.). */
    lStdReturn = Dcm_DidMgrFilterDidLookUp(pDidInfoContext, didOp);

  }
  /* #250 Otherwise just return the current state or not supported DID: DCM_E_PENDING or DCM_E_NOT_OK */

  return lStdReturn;
}                                                                                                                                                    /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */

# if (DCM_DIDMGR_MULTISIGNAL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrOpTypeHandlerInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DidMgrOpTypeHandlerInit(Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                          ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext)
{
  pDidOpTypeContext->Base.NumSignals          = (Dcm_CfgDidMgrSignalIterMemType)(pDidInfoContext->Descriptor.DidOpClassInfoPtr[1].OpClassRef
                                                                               - pDidInfoContext->Descriptor.DidOpClassInfoPtr[0].OpClassRef);/* number of operations to be iterated (number signals) */
  pDidOpTypeContext->Base.SignalOpList        = pDidInfoContext->Descriptor.DidSignalOpClassInfoPtr;/* start position of the operations to be called */
  pDidOpTypeContext->Base.SignalInfoList      = &(Dcm_CfgDidMgrSignalInfo[pDidInfoContext->Descriptor.DidInfoPtr->SignalRef]);/* start position of the signal offsets */
}
# endif

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_OFF)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadLinear()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadLinear(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgType pData
                                                             ,Dcm_CfgNetBufferSizePtrType pAvailLen
                                                             ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                             ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                             ,Dcm_NegativeResponseCodePtrType errorCode)
{
  /* #10 If multi signal is supported for read operation: */
#  if (DCM_DIDMGR_MSIG_OPTYPE_READ_ENABLED == STD_ON)
  Std_ReturnType lStdResult;

  if(opStatus == DCM_INITIAL)
  {
    /* #20 Initialize DID handler. */
    Dcm_DidMgrOpTypeHandlerInit(pDidInfoContext, pDidOpTypeContext);
    pDidOpTypeContext->OpType.Read.Offset = pDidOpTypeContext->Base.SignalInfoList->Offset;
  }

  /* #30 For each signal of the DID: */
  DCM_UTI_LOOP_FOR_EVER
  {
    /* #40 Read the signal data. */
    lStdResult = Dcm_DidMgrReadSignal(opStatus
                                    ,&(pData[pDidOpTypeContext->OpType.Read.Offset])
                                    ,pAvailLen
                                    ,pDidInfoContext
                                    ,pDidOpTypeContext
                                    ,errorCode);

    /* #50 If the application needs more time or some error occurred: */
    if(lStdResult != DCM_E_OK)
    {
      /* #60 Just leave and try later if applicable. */
      break;
    }

    pDidOpTypeContext->Base.NumSignals--;
    if(pDidOpTypeContext->Base.NumSignals == 0u)
    {
      break;                                                                                                                                         /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
    }

    /* Go on with next signal. */
    Dcm_UtiNextItemByPtr(pDidOpTypeContext->Base.SignalOpList,  1u);
    Dcm_UtiNextItemByPtr(pDidOpTypeContext->Base.SignalInfoList, 1u);
    pDidOpTypeContext->OpType.Read.Offset += (Dcm_CfgDidMgrOptimizedDidLengthType)(pDidOpTypeContext->Base.SignalInfoList->Offset);
    opStatus = DCM_INITIAL; /* reset op status */
  }

  return lStdResult;
#  else
  /* #70 Otherwise read the signal data. */
  return Dcm_DidMgrReadSignal(opStatus
                             ,pData
                             ,pAvailLen
                             ,pDidInfoContext
                             ,pDidOpTypeContext
                             ,errorCode);
#  endif
}                                                                                                                                                    /* PRQA S 6060 */ /* MD_Dcm_Design_6060 */
# endif /* (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_OFF) */

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadPaged()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrReadPaged(Dcm_OpStatusType opStatus
                                                            ,Dcm_MsgType pData
                                                            ,Dcm_CfgNetBufferSizePtrType pAvailLen
                                                            ,Dcm_DidMgrDidInfoContextPtrType   pDidInfoContext
                                                            ,Dcm_DidMgrDidOpTypeContextPtrType pDidOpTypeContext
                                                            ,Dcm_NegativeResponseCodePtrType errorCode)
{
  Std_ReturnType  lResult;

  /* #10 If any read operation has to be cancelled: */
  if(opStatus == DCM_CANCEL)
  {
    lResult = DCM_E_NOT_OK;
    /* #20 If DID signal already in processing: */
    if(pDidOpTypeContext->OpType.Read.OpStatus != DCM_INITIAL)
    {
      /* #30 Notify application about cancellation. */
      (void)Dcm_DidMgrReadSignal(opStatus
                                ,pData
                                ,pAvailLen
                                ,pDidInfoContext
                                ,pDidOpTypeContext
                                ,errorCode);
    } /* #40 Otherwise no cancellation shall be notified. */
  }
  else  /* #50 If multi signal is supported for read operation: */
  {
#  if (DCM_DIDMGR_MSIG_OPTYPE_READ_ENABLED == STD_ON)
    if(opStatus == DCM_INITIAL)
    {
      /* #60 Initialize DID handler. */
      Dcm_DidMgrOpTypeHandlerInit(pDidInfoContext, pDidOpTypeContext);
      pDidOpTypeContext->OpType.Read.Offset       = pDidOpTypeContext->Base.SignalInfoList->Offset;
      pDidOpTypeContext->OpType.Read.OpStatus     = DCM_INITIAL;
      pDidOpTypeContext->OpType.Read.Progress     = 0u;
      pDidOpTypeContext->OpType.Read.PageProgress = 0u;
    }

    /* #70 Read all signals. */
    lResult = Dcm_DidMgrReadPagedMultiSignal(pData, pAvailLen, pDidInfoContext, pDidOpTypeContext,  errorCode);
#  else
    /* #80 Otherwise, if there is not enough buffer space available for the signal: */
    if( (pDidInfoContext->Descriptor.DidSignalOpClassInfoPtr->FuncClass != DCM_DIDMGR_OPCLS_READ_PAGE)
      &&(*pAvailLen < pDidInfoContext->DidLength) )
    {
      /* #90 Try it the next task cycle. */
      lResult = DCM_E_BUFFERTOOLOW;
    }
    else
    {
      /* #100 Otherwise, read the signal data. */
      lResult = Dcm_DidMgrReadSignal(opStatus
                                    ,pData
                                    ,pAvailLen
                                    ,pDidInfoContext
                                    ,pDidOpTypeContext
                                    ,errorCode);
    }
#  endif
  }
  return lResult;
}                                                                                                                                                    /* PRQA S 6060 */ /* MD_Dcm_Design_6060 */
# endif /* (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON) */
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON)                                                                                                        /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrDemGetNumFltrdDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdDtcMgrDemGetNumFltrdDtc(Dcm_OpStatusType opStatus
                                                                       ,Dcm_MsgContextPtrType pMsgContext)                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  Dem_ReturnGetNumberOfFilteredDTCType demResult;
  uint16 lNumDtc;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  demResult = Dcm_DemAPI(GetNumberOfFilteredDTC)(&lNumDtc);
  switch(demResult)
  {
  case DEM_NUMBER_OK:
    if(lNumDtc <= 0xFFu)
    {
      pMsgContext->resData[0] = Dcm_UtiGetLoByte(lNumDtc);
      Dcm_DiagMoveOnResWithLengthAll(pMsgContext, 1u);                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
# if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_ON)
      Dcm_PagedBufferStart(Dcm_ObdDtcMgrCpyDemGetNxtFltrdDtc, NULL_PTR, (Dcm_MsgLenType)(lNumDtc * 2));
      lStdResult = DCM_E_OK;
# else
      Dcm_InstanceContext.ObdDtcMgr.ReadDtcContextPtr->CopyFunc = Dcm_ObdDtcMgrCpyDemGetNxtFltrdDtc;
      Dcm_RepeaterSetCallee(Dcm_ObdDtcMgrCopyLinearData); /* delegate job */
      lStdResult = DCM_E_LOOP;
# endif
    }
    else
    {
      /* else - NRC 0x22 */
      Dcm_SetNegResponse(DCM_E_CONDITIONSNOTCORRECT);
      lStdResult = DCM_E_PROCESSINGDONE;
    }
    break;
  case DEM_NUMBER_PENDING:
    lStdResult = DCM_E_PENDING;
    break;
  default:/* DEM_NUMBER_FAILED or unknown */
    Dcm_DemApiSetNegResponse(demResult, Dcm_DemApiNrcMapGetNumberOfFilteredDTC);
    lStdResult = DCM_E_PROCESSINGDONE;
    break;
  }
  return lStdResult;
}

# if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_OFF)
/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrCopyLinearData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdDtcMgrCopyLinearData(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType              lStdResult;
  Dcm_CfgNetBufferSizeOptType remainingData = (Dcm_CfgNetBufferSizeOptType)pMsgContext->resMaxDataLen;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdResult = Dcm_InstanceContext.ObdDtcMgr.ReadDtcContextPtr->CopyFunc(pMsgContext->resData, &remainingData);

  /* commit copied data */
  remainingData = (Dcm_CfgNetBufferSizeOptType)(pMsgContext->resMaxDataLen - remainingData);
  Dcm_DiagMoveOnResWithLengthAll(pMsgContext, remainingData);                                                                                        /* PRQA S 3109 */ /* MD_MSR_14.3 */

  if(lStdResult != DCM_E_PENDING)
  {
    if(lStdResult == DCM_E_BUFFERTOOLOW)/* buffer too low OR all data reported - finish processing */
    {
      Dcm_SetNegResponse(DCM_E_REQUESTOUTOFRANGE);/* for OBD send (suppress with) NRC 0x31 since 0x14 (ResponseTooLong is not defined!) */
    }
    lStdResult = DCM_E_PROCESSINGDONE;
  }
  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrCpyDemGetNxtFltrdDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdDtcMgrCpyDemGetNxtFltrdDtc(Dcm_MsgType pData
                                                                          ,Dcm_CfgNetBufferSizePtrType pAvailLen)
{
  uint32                                lDtc;
  Dcm_CfgNetBufferSizeOptType           lAvailLen;
  uint8                                 dtcStatus;
  Dcm_DemReturnGetNextFilteredItemType  demResult;
  Std_ReturnType                        lStdResult;
  DCM_UTIRTLMTR_CTR_DEF

  DCM_UTIRTLMTR_CTR_INIT
  lAvailLen = *pAvailLen;
  lStdResult = DCM_E_BUFFERTOOLOW;

  while (lAvailLen >= 2u)
  {
    demResult =  Dcm_DemAPI(GetNextFilteredDTC)(&lDtc, &dtcStatus);
    if(demResult == DCM_DEM_RET_FILTERED_OK)
    {
      pData[0] = Dcm_UtiGetHiLoByte(lDtc);
      pData[1] = Dcm_UtiGetLoHiByte(lDtc);

      /* commit data */
      Dcm_UtiNextItemByPtr(pData, 2u);
      lAvailLen -= 2u;
    }
    else
    {
      lStdResult = Dcm_DemApiConvDemRsltGetNextFilteredItem(demResult);
      break;
    }
    DCM_UTIRTLMTR_CTR_NEXT /* if link-time and limit = 0 -> leads to overflow and practically no limitation (at least 255 iterations to "pending")*/
    DCM_UTIRTLMTR_CTR_HANDLE_AND_BREAK(lStdResult, DCM_E_PENDING) /* signal retry */                                                                 /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
  }

  *pAvailLen = (Dcm_CfgNetBufferSizeOptType)lAvailLen; /* commit all copied data */
  return lStdResult; /*lint !e438 pData is always post incremented */
}

/**********************************************************************************************************************
 *  Dcm_ObdDtcMgrReadDtcByStatusMask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdDtcMgrReadDtcByStatusMask(
                                                                     Dcm_ObdDtcMgrReadDtcContextPtrType pReadDtcContext
                                                                    ,Dcm_MsgContextPtrType pMsgContext)                                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdReturn;

  if(pMsgContext->reqDataLen == 0u)
  {
    Dem_ReturnSetFilterType  resultSetDtcFilter;

    resultSetDtcFilter = Dcm_DemAPI(SetDTCFilter)(pReadDtcContext->StatusMask
                                                  ,DEM_DTC_KIND_EMISSION_REL_DTCS
                                                  ,DEM_DTC_FORMAT_OBD
                                                  ,pReadDtcContext->Origin
                                                  ,DEM_FILTER_WITH_SEVERITY_NO
                                                  ,DEM_SEVERITY_NO_SEVERITY
                                                  ,DEM_FILTER_FOR_FDC_NO);
    if(resultSetDtcFilter == DEM_FILTER_ACCEPTED)
    {
      Dcm_InstanceContext.ObdDtcMgr.ReadDtcContextPtr = pReadDtcContext;
      Dcm_RepeaterSetUser(DCM_REPEATER_USER_DEM);/* set user for central repeater handling */
      Dcm_RepeaterSetCallee(Dcm_ObdDtcMgrDemGetNumFltrdDtc);
      lStdReturn = DCM_E_LOOP;
    }
    else
    {/* else - set NRC */
      Dcm_SetNegResponse(Dcm_DemApiGetNrcForDemRetValue(resultSetDtcFilter, Dcm_DemApiNrcMapSetDTCFilter));
      lStdReturn = DCM_E_PROCESSINGDONE;
    }
  }
  else
  {
    Dcm_SetNegResponse(DCM_E_REQUESTOUTOFRANGE);
    lStdReturn = DCM_E_PROCESSINGDONE;
  }

  return lStdReturn;
}
#endif /* (DCM_OBDDTCMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_TSK_NUM_DIAG_GARB_COL > 0)                                                                                                                  /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_DiagTaskGarbageCollector()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskGarbageCollector(Dcm_TskTaskEvOptType ev
                                                           ,Dcm_TskTaskEvPtrType pPostEv)                                                            /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  DCM_NETTOBJ_CNTR_DEF

  DCM_IGNORE_UNREF_PARAM(pPostEv);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Cleanup or reject all transport objects that never succeeded and are now canceled */
  DCM_NETTOBJ_CNTR_INIT
  DCM_TSK_EVENT_SCAN_LOOP(ev)
  {
    /* Check who shall be removed */
    if(Dcm_TskIsLocalEventSet(ev, 0x01u))
    {
      Dcm_NetTransportObjectPtrType pTranspObj = Dcm_NetGetTranspObjByHandle(DCM_NETTOBJ_CNTR_VALUE);
      /* Always unregister ComM activity here, since CANCELED flag will not clean it up!
       * If no RCR-RP on transmission: everything has to be cleaned up here!
       */
      Dcm_NetUnRegisterComMActivity(Dcm_NetTranspObjGetConnIdOnly(pTranspObj));

      /* If just requested, then only this TObject could be the trigger for P2 timer - avoid any RCR-RP transmission */
      if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ) != 0)
      {
        Dcm_TskClrEvent(DCM_TSK_ID_DIAG_TX, DCM_TSK_EV_DIAG_TX_SEND_RCRRP);
      }

      Dcm_UtiArEnvEnterCriticalSection();                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
      /*=================================*
       BEGIN CRITICAL SECTION
       *=================================*/
      /* Check if any RCR-RP for this object is on Tx (DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ is excluded since the high-prio Dcm_DiagTaskTx() shall already have switched to ON_TX!) */
      if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_RCRRP_ON_TX) != 0)
      {
        pTranspObj->Flags |= DCM_NET_TOBJ_FLAG_CANCELED;/* isolate this connection */

        /* Try cancel any ongoing response. The return value does not matter:
          * OK -> there will be a confirmation for this cancellation
          * N_OK -> request rejected, but there will be a confirmation due to the ongoing transmission */
        (void)Dcm_NetArEnvPduRCancelTransmit(Dcm_PbCfgNetConnectionInfo[Dcm_NetTranspObjGetConnIdValue(pTranspObj)].TxPduIdMain);
        /* Any RCR-RP will just end with releasing the connection assigned to the tObject! No confirmation post-processing will be performed! */
      }
      else
      {
        Dcm_NetBufferRelease(Dcm_NetTranspObjGetBufferHandleValue(pTranspObj));   /* the buffer is free now */
        Dcm_NetUnRegisterActiveConnection(pTranspObj);/* no further processing needed */
      }
      /*=================================*
       END CRITICAL SECTION
       *=================================*/
      Dcm_UtiArEnvLeaveCriticalSection();                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
    }
    DCM_NETTOBJ_CNTR_NEXT
  }
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagRcrRpTxFinished()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagRcrRpTxFinished(Dcm_NetTransportObjectPtrType pTranspObj                                                      /* COV_DCM_RTM_NO_RCR_RP_TX */ /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                      ,Dcm_NetTransmissionResultType txStatus)
{
  Dcm_InstanceContext.Diag.TxStatus   = txStatus;/* store current TX state */
  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_TX_END_RCRRP);  /* Notify for sent RCR_RP */

  pTranspObj->ResType = DCM_NET_TOBJ_RESTYPE_NONE;
  /* Set appropriate RCR-RP transmissions state */
  Dcm_UtiBitOpClr(Dcm_NetTransportObjectFlagType, pTranspObj->Flags, DCM_NET_TOBJ_FLAG_RCRRP_ON_TX);                                                 /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
  Dcm_UtiBitOpSet(Dcm_NetTransportObjectFlagType, pTranspObj->Flags, DCM_NET_TOBJ_FLAG_RCRRP_SENT);/* mark RCR-RP at least once sent state */
  pTranspObj->State   = DCM_NET_TOBJ_STATE_READY; /* on RCR-RP -> go back to ready */
}

/**********************************************************************************************************************
 *  Dcm_DiagSetP2Timings()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagSetP2Timings(Dcm_StateIndexMemType    sesStateIdx,
                                                    Dcm_CfgNetProtRefMemType protocolIdx)
{
  /* #10 Enter critical section. */
  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */

  /* #20 Calculate the current P2 timings considering the protocol related adjust timings. */
  Dcm_InstanceContext.Diag.P2Timings.P2 = Dcm_DiagGetP2Time(sesStateIdx)
                                        - Dcm_NetGetP2AdjTime(protocolIdx);

  Dcm_InstanceContext.Diag.P2Timings.P2Star = Dcm_DiagGetP2StarTime(sesStateIdx)
                                            - Dcm_NetGetP2StarAdjTime(protocolIdx);

  /* #30 Leave critical section. */
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
}

#if (DCM_NET_PROCESSING_CANCELLATION_ENABLED == STD_ON)                                                                                              /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_DiagCancelProcessing()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagCancelProcessing(void)
{
  Dcm_TmrStopTimer(DCM_TMR_ID_P2);/* avoid any RCR-RP transmission on slow split task systems! */
  Dcm_TskKillAllTasks();
  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_KILL_JOBS); /* signal job cancellation (synchronous with all lo-priority tasks) */
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagRxIndication()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagRxIndication(Dcm_NetTransportObjectPtrType pTranspObj)                                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  DCM_IGNORE_UNREF_PARAM(pTranspObj);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */

#if (DCM_DIAG_RST2DEF_ON_FUNC_OBD_REQ_ENABLED == STD_ON)                                                                                             /* COV_DCM_UNSUPPORTED XF */
  /* #10 Handle OBD requests (SID 0x00-0x0F) when only one diagnostic client is used */
  if ( (pTranspObj->RxData[0] < 0x10u)
# if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
     &&(Dcm_PbCfgNetNumConnections == 1u)
# endif
     &&((DCM_STATE_VALUE_SESSION_INIT & Dcm_StateGetPendingSession()) == 0)
     &&(Dcm_PbCfgNetRxPduInfo[pTranspObj->RxPduId].IsFuncReq == TRUE)
     )
  {
    Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_INT_SET2DEF);
    Dcm_DiagSetP2Timings(0, 0);
  }
#endif

#if (DCM_DIAG_SYNCH_FLAGS_ENABLED == STD_ON)                                                                                                         /* COV_DCM_UNSUPPORTED XF */
  /* #20 Update diagnostic kernel queue flags: */
  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
    BEGIN CRITICAL SECTION
   *=================================*/
  Dcm_InstanceContext.Diag.QueuedSet.Flags |= DCM_DIAG_QUEUE_FLAG_IS_WAITING;
  /*=================================*
    END CRITICAL SECTION
   *=================================*/
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
#endif

  /* #30 Prepare for new diagnostic request processing by setting all relevant for the real-time task properties: */
  Dcm_DiagSetQueuedTranspObj(pTranspObj);                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
  Dcm_TmrStartTimer(DCM_TMR_ID_P2, Dcm_InstanceContext.Diag.P2Timings.P2);
#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
  Dcm_SingletonContext.Network.KeepAlive = TRUE;
#endif

  /* #40 Signal the Dcm_DiagTaskWorker that the request is now ready for processing */
  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_RX, DCM_TSK_EV_DIAG_RX_NEW_REQ);
}

/**********************************************************************************************************************
 *  Dcm_DiagDispatcher()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_DiagDispatcher(Dcm_OpStatusType opStatus
                                                           ,Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType lResult = DCM_E_PROCESSINGDONE;

  /* Compose message context */
  pMsgContext->reqData = &(Dcm_DiagGetTranspObj()->RxData[1]);
  pMsgContext->resData = &(Dcm_DiagGetTranspObj()->RxData[1]);
  pMsgContext->reqDataLen = (Dcm_MsgLenType)(Dcm_DiagGetTranspObj()->RxLength - 1u);
  pMsgContext->resDataLen = 0u;
  pMsgContext->resMaxDataLen = (Dcm_MsgLenType)(Dcm_NetGetBufferSizeOfTranspObj(Dcm_DiagGetTranspObj()) - 1u);
  pMsgContext->rxPduId = Dcm_DiagGetTranspObj()->RxPduId;
  pMsgContext->msgAddInfo.reqType  = (uint8)((Dcm_PbCfgNetRxPduInfo[Dcm_DiagGetTranspObj()->RxPduId].IsFuncReq == TRUE)?1u:0u);
  pMsgContext->msgAddInfo.suppressPosResponse = 0;

  /* Update diagnostic kernel context */
  Dcm_InstanceContext.Diag.ApplNotification     = DCM_DIAG_APPL_NOTIFICATION_NONE;
  Dcm_InstanceContext.Diag.DoSuppressResponse   = FALSE;
  Dcm_InstanceContext.Diag.ErrorRegister        = DCM_E_POSITIVERESPONSE;
  Dcm_InstanceContext.Diag.State                = DCM_DIAG_STATE_PROCESS;

  Dcm_PagedBufferInit();
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

#if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON) && \
    (DCM_SPLIT_TASKS_ENABLED    == STD_ON)
  if(opStatus != DCM_CANCEL)
#endif
  {
#if(DCM_DIAG_OEM_NOTIFICATION_ENABLED == STD_ON)
    /* Execute manufacturer specific environment checks */
    if(Dcm_DiagExecIndicationFunc(Dcm_DiagGetTranspObj()->RxData[0], DCM_DIAG_APPL_NOTIFICATION_OEM, Dcm_CfgDiagOemNotificationInfo) == TRUE)
#endif
    {
      Dcm_NegativeResponseCodeType lNrc;
      sint16_least sidIter = Dcm_DiagLookUpFilter(Dcm_UtiLookUpUint8(Dcm_CfgDiagSvcIdLookUpTable, Dcm_DiagGetTranspObj()->RxData[0])
                                                 ,Dcm_CfgDiagSvcIdExecPrecondTable
                                                 ,DCM_DIAG_CHK_LVL_SERVICE_ID
                                                 ,&lNrc);
      /* Service found? */
      if(sidIter >= 0)
      {
        Dcm_InstanceContext.Diag.SidIndex = (uint8)sidIter;
#if (DCM_DIAG_MULTI_SVC_TABLE_ENABLED == STD_ON)                                                                                                     /* COV_DCM_UNSUPPORTED XF */
        /* use protocol of the current working context! Otherwise a hi priority task (NetTaskRx) could interrupt this task and change the protocol! */
        if((Dcm_PbCfgDiagSvcId2ProtMap[Dcm_InstanceContext.Diag.SidIndex] & Dcm_UtiGetBitFromIndex(Dcm_CfgDiagSvc2ProtMapMemType, Dcm_NetGetProtIdOfTranspObj(Dcm_DiagGetTranspObj()))) == 0)
        {
          /* Unknown service requested */
          Dcm_SetNegResponse(DCM_E_SERVICENOTSUPPORTED);
        }
        else
#endif
        {
          if((Dcm_CfgDiagServiceInfo[Dcm_InstanceContext.Diag.SidIndex].Props & DCM_DIAG_SVC_CFG_PROP_CALL_POST_HDLR_ALWAYS)  != 0)
          {
            /* mark application notification once the SID is identified! */
            Dcm_InstanceContext.Diag.ApplNotification |= DCM_DIAG_APPL_NOTIFICATION_SID_FOUND;
          }

          /* Check SID pre-conditions */
          Dcm_InstanceContext.Diag.ErrorRegister = Dcm_StateCheck(Dcm_CfgDiagSvcIdExecPrecondTable[Dcm_InstanceContext.Diag.SidIndex], DCM_DIAG_CHK_LVL_SERVICE_ID);
          if(Dcm_InstanceContext.Diag.ErrorRegister == DCM_E_POSITIVERESPONSE)
          {
#if(DCM_DIAG_SYS_NOTIFICATION_ENABLED == STD_ON)
            /* Execute supplier specific environment checks */
            if(Dcm_DiagExecIndicationFunc(Dcm_DiagGetTranspObj()->RxData[0], DCM_DIAG_APPL_NOTIFICATION_SYS, Dcm_CfgDiagSysNotificationInfo) == TRUE)
#endif
            {
              /* Check for available minimum length */
              if(pMsgContext->reqDataLen >= Dcm_CfgDiagServiceInfo[Dcm_InstanceContext.Diag.SidIndex].MinLength)
              {
                lResult = Dcm_DiagStartServiceExecution(pMsgContext);
              }
              else
              {
                /* Minimum length is not reached  */
                Dcm_SetNegResponse(DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT);
              }
            }/* else - NRC already set - finalize processing */
          }/* else - NRC already set - finalize processing */
        }
      }
      else
      {
        /* Unsupported service requested */
        Dcm_SetNegResponse(lNrc);
      }
    }/* else - NRC already set - finalize processing */
  }
  return lResult;
}                                                                                                                                                    /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_DiagTxFinalization()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTxFinalization(Dcm_NetTransportObjectPtrType pTranspObj                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                     ,Dcm_NetTransmissionResultType txStatus)
{
  Dcm_InstanceContext.Diag.TxStatus = txStatus;/* store current TX state */
  Dcm_InstanceContext.Diag.State    = DCM_DIAG_STATE_POST_PROCESS;

#if (DCM_DIAG_SYNCH_FLAGS_ENABLED == STD_ON)                                                                                                         /* COV_DCM_UNSUPPORTED XF */
  Dcm_SplitTaskEnterCS(); /* protect against Dcm_NetRxTask (hi-priority task interrupts lo-priority task on suppressed response)! */                 /* PRQA S 3109 */ /* MD_MSR_14.3 */
  Dcm_UtiBitOpClr(Dcm_DiagProcessorFlagType, Dcm_InstanceContext.Diag.QueuedSet.Flags, DCM_DIAG_QUEUE_FLAG_IS_ACTIVE);                               /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
  Dcm_SplitTaskLeaveCS();                                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
#endif

#if (DCM_DIAG_FAST_POST_PROCESSING_ENABLED == STD_ON)                                                                                                /* COV_DCM_SUPPORT_ALWAYS TX */
  /* Execute first the assigned service post-processor */
  if(((DCM_DIAG_APPL_NOTIFICATION_SVC_HDLR | DCM_DIAG_APPL_NOTIFICATION_SID_FOUND) & Dcm_InstanceContext.Diag.ApplNotification) != 0)
  {
    Dcm_ConfirmationStatusType confStatus;

    confStatus = Dcm_DiagGetPostProcessResult();
    Dcm_CfgDiagSvcPostProcessors[Dcm_CfgDiagServiceInfo[Dcm_InstanceContext.Diag.SidIndex].FastConfFuncRef](confStatus);/* execute any internal fast service processor post-handlers */
  }
#endif
  /* release the connection */
#if (DCM_NET_PROCESSING_CANCELLATION_ENABLED == STD_ON)                                                                                              /* COV_DCM_UNSUPPORTED XF */
  if((DCM_NET_TOBJ_FLAG_CANCELED & pTranspObj->Flags) == 0) /* let the connection expire with the TX confirmation (after CancelTransmit)*/
#endif
  {
    Dcm_NetBufferRelease(Dcm_NetTranspObjGetBufferHandleValue(pTranspObj));   /* the buffer is free now */
    Dcm_NetUnRegisterActiveConnection(pTranspObj);/* Start the S3 timer if needed here to have maximum real-time accuracy (from communication bus point of view) */
  }

  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_TX_END_FINAL);/* Do finalize main response */
}

#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagOnFblResTxFinished()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagOnFblResTxFinished(Dcm_NetTransportObjectPtrType pTranspObj                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                         ,Dcm_NetTransmissionResultType txStatus)
{
  Dcm_InstanceContext.Diag.StartUpFbl.TxStatus = txStatus;/* store current TX state */
  Dcm_NetBufferRelease(Dcm_NetTranspObjGetBufferHandleValue(pTranspObj));   /* the buffer is free now */
  Dcm_NetUnRegisterActiveConnection(pTranspObj);/* Start the S3 timer if needed here to have maximum real-time accuracy (from communication bus point of view) */
  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_FBLRES, DCM_TSK_EV_DIAG_FBLRES_TXCONF);
}
#endif

#if (DCM_DIAG_JUMPFROMFBL_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutFblRes()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutFblRes(void)
{
  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_FBLRES, DCM_TSK_EV_DIAG_FBLRES_CANCEL);/* synchronize with the state machine in the task */
  return 0u;/* no reload */
}
#endif

/**********************************************************************************************************************
 *  Dcm_OnTimeoutP2()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutP2(void)                                                                              /* COV_DCM_RTM_NO_RCR_RP_TX */
{
  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_RX, DCM_TSK_EV_DIAG_RX_TMR_P2_TO);/* go over RX task to process eventual cancellation immediately */
  return 0u;/* no reload */
}

/**********************************************************************************************************************
 *  Dcm_OnTimeoutS3()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutS3(void)
{
  /* #10 If a non-default session is currently active: */
  if(!Dcm_StateIsDefaultSessionActive())
  {
    /* #20 Process transition to default session. */
    Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_INT_SET2DEF);

    /* #30 Update P2 timings at once. */
    Dcm_DiagSetP2Timings(0, Dcm_NetGetProtIdOfActiveProtocol());
  }
  return 0u; /* No reload. */
}

#if (DCM_NET_KEEP_ALIVE_TIME_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutKeepAlive()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutKeepAlive(void)
{
  if(Dcm_StateIsDefaultSessionActive())                                                                                                              /* COV_DCM_RTM_DESIGN_LOWER_LAYER XF */
  {
    Dcm_NetUnRegisterAllComMActivity();
  } /* else - ComM activity will be unregistered by S3 timeout. */

  Dcm_SingletonContext.Network.KeepAlive = FALSE;

  return 0u; /* No reload. */
}
#endif

#if(DCM_DIAG_ANY_NOTIFICATION_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DiagExecIndicationFunc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(boolean, DCM_CODE) Dcm_DiagExecIndicationFunc(Dcm_MsgItemType sid
                                                            ,Dcm_DiagApplNotificationType notificationType
                                                            ,Dcm_CfgDiagNotificationInfoPtrType notifList)                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  boolean lResult = TRUE; /* positive case */
  Std_ReturnType lStdResult;
  Dcm_NegativeResponseCodeType lNrc;

  /* This API shall not be called if the list is empty (i.e. contains only list termination NULL_PTR) */
  Dcm_DebugAssert((notifList->IndFunc != NULL_PTR), DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG)                                                          /* COV_DCM_RTM_DEV_DEBUG XF */

  Dcm_InstanceContext.Diag.ApplNotification |= notificationType; /* mark application has been notified */

  /* Prepare for post processing later */
  Dcm_InstanceContext.Diag.PostProcessorContext.Sid     = sid;
  Dcm_InstanceContext.Diag.PostProcessorContext.SrcAddr = Dcm_PbCfgNetConnectionInfo[Dcm_NetGetConnIdOfRxPduId(Dcm_InstanceContext.Diag.MsgContext.rxPduId)].ClientSrcAddr;
  Dcm_InstanceContext.Diag.PostProcessorContext.ReqType = (uint8)Dcm_InstanceContext.Diag.MsgContext.msgAddInfo.reqType;

  do/* use do-while as optimal loop since at least one entry is inside */
  {
    lNrc = DCM_E_POSITIVERESPONSE; /* Initialize out parameter */
    lStdResult = notifList->IndFunc(sid
                                  ,Dcm_InstanceContext.Diag.MsgContext.reqData
                                  ,(uint16)Dcm_InstanceContext.Diag.MsgContext.reqDataLen
                                  ,(uint8)Dcm_InstanceContext.Diag.MsgContext.msgAddInfo.reqType
                                  ,Dcm_InstanceContext.Diag.PostProcessorContext.SrcAddr
                                  ,&lNrc);

    if(lStdResult == DCM_E_OK)
    {
      /* Good case */
    }
    else
    {
      lResult = FALSE;/* mark error, but let other checks to be performed - check for higher priority NOT_ACCEPTED result */
      /* Error case */
      if( (lStdResult == DCM_E_NOT_OK)
        ||(lStdResult == DCM_E_REQUEST_NOT_ACCEPTED) )
      {
        if(lStdResult == DCM_E_REQUEST_NOT_ACCEPTED)
        {
          lNrc = DCM_E_CONDITIONSNOTCORRECT; /* in DCM_E_REQUEST_NOT_ACCEPTED case no positive response shall be sent! */
          Dcm_InstanceContext.Diag.DoSuppressResponse = TRUE;/* try to suppress, but if an RCR-RP has been already sent - send the registered NRC */
        }
        else if(lNrc == DCM_E_POSITIVERESPONSE) /* in NOT_OK case no positive response shall be sent! */
        {
          lNrc = DCM_E_CONDITIONSNOTCORRECT; /* in NOT_OK case no positive response shall be sent! */
          /* If DCM_E_NOT_OK returned, a concrete NRC must be set! */
          Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_PARAM);
        }
        else
        {
          /* else - for case DCM_E_NOT_OK the NRC is already set */
        }
        Dcm_SetNegResponse(lNrc); /* only the first error to be registered! Next loop will not overwrite it! */
      }
      else
      {
        /* Unexpected return value */
        Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
        Dcm_SetNegResponse(DCM_E_PANIC_NRC); /* Try to register panic error if no other has been set! */
      }
    }
    Dcm_UtiNextItemByPtr(notifList,1u);/* take next function */
  }
  while(notifList->IndFunc != NULL_PTR);
  return lResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

/**********************************************************************************************************************
 *  Dcm_ProcessingDone()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_ProcessingDone(void)
{
  /* If positive response to be sent: */
  if(Dcm_InstanceContext.Diag.ErrorRegister == DCM_E_POSITIVERESPONSE)
  {
    /* If SPRMIB == TRUE (suppression of positive response): */
    if(Dcm_InstanceContext.Diag.MsgContext.msgAddInfo.suppressPosResponse != 0u)
    {
      /* Mark no response to be sent. */
      Dcm_InstanceContext.Diag.DoSuppressResponse = TRUE;
    }/* Otherwise - proceed with positive response transmission. */
  }
  else /* Otherwise (negative response): */
  {
    /* If functionally requested diagnostic job: */
    if(Dcm_InstanceContext.Diag.MsgContext.msgAddInfo.reqType != 0)
    {
      switch(Dcm_InstanceContext.Diag.ErrorRegister)
      {
        case DCM_E_SERVICENOTSUPPORTED:
        case DCM_E_SUBFUNCTIONNOTSUPPORTED:
        case DCM_E_REQUESTOUTOFRANGE:
#if (DCM_DIAG_SUPPRESS_NRC_7F_7E_ENABLED == STD_ON)
        case DCM_E_SERVICENOTSUPPORTEDINACTIVESESSION:
        case DCM_E_SUBFUNCTIONNOTSUPPORTEDINACTIVESESSION:
#endif
          /* Suppress negative response for certain NRCs only. */
          Dcm_InstanceContext.Diag.DoSuppressResponse = TRUE;
          break;
        default:
          /* Otherwise - proceed with negative response transmission. */
          break;
      }
    }/* Otherwise - proceed with negative response transmission. */
  }
  /* Update diagnostic sub-component activity state. */
  Dcm_InstanceContext.Diag.State = DCM_DIAG_STATE_ON_TX;

  /* Notify the transmission task for linear data response transmission/suppression. */
  Dcm_TskSetEvent(DCM_TSK_ID_DIAG_TX, DCM_TSK_EV_DIAG_TX_SEND_LINEAR);
}

/**********************************************************************************************************************
 *  Dcm_SetNegResponse()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_SetNegResponse(Dcm_NegativeResponseCodeType nrc)
{
  if(Dcm_InstanceContext.Diag.ErrorRegister == DCM_E_POSITIVERESPONSE)
  {
    Dcm_InstanceContext.Diag.ErrorRegister = nrc;
  }
}
/**********************************************************************************************************************
 *  Dcm_DiagTaskRx()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskRx(Dcm_TskTaskEvOptType ev
                                             ,Dcm_TskTaskEvPtrType pPostEv)                                                                          /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  DCM_IGNORE_UNREF_PARAM(pPostEv);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* If new request received: */
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_RX_NEW_REQ))
  {
    /* Initialize related objects. */
    Dcm_DiagGetQueuedTranspObj()->State = DCM_NET_TOBJ_STATE_READY;
    Dcm_DiagRcrRpLimiterReset();
    /* Synchronize with diagnostic job processing task. */
    Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_NEW_REQ);
  }

  /* If P2 timeout detected: */
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_RX_TMR_P2_TO))
  {
    /* Pre-processing a P2 timeout in oder to cancel the working thread in time (on non-split task configuration). */
#if (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
    /* If RCR-RP limit reached: */
    if(Dcm_InstanceContext.Diag.NumRcrRpTimeouts == 0)
    {
      /* Reset any RCR-RP related states and notify worker task to initiate job cancellation. */
      Dcm_DiagRcrRpTxFinished(Dcm_DiagGetQueuedTranspObj(), DCM_E_NOT_OK);

      /*
       * Signal cancellation to the worker. If worker gets interrupted by this hi priority task,
       * while already called "processing done", the cancellation signal will be lost and
       * the final response will be sent at next worker task call.
       */
      Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_CANCEL_OP);

      /*
       * Do not send RCR-RP and restart the P2 timer again since the limit has been reached and the worker will
       * finalize the job, once the cancel signal is received.
       */
    }
    else
#endif
    {
#if (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
      /* Otherwise - update RCR-RP limiter. */
      --Dcm_InstanceContext.Diag.NumRcrRpTimeouts;
#endif
      /* Notify diagnostic transmission task to initiate RCR-RP transmission. */
      Dcm_DiagGetQueuedTranspObj()->Flags |= DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ;
      Dcm_TskSetEvent(DCM_TSK_ID_DIAG_TX, DCM_TSK_EV_DIAG_TX_SEND_RCRRP);
    }
  }
}

#if (DCM_TSK_NUM_DIAG_FBLRES > 0)
/**********************************************************************************************************************
 *  Dcm_DiagTaskFblRes()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskFblRes(Dcm_TskTaskEvOptType ev
                                                 ,Dcm_TskTaskEvPtrType pPostEv)
{
  /* #10 Check for eventual FBL final response request. */
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_FBLRES_SEND))
  {
    ev = Dcm_DiagFblResDoGetProgCond(ev, pPostEv);
  }

  /* #20 If final response required, wait for ComM before sending the response. */
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_FBLRES_WAITTXCOMM))
  {
    ev = Dcm_DiagFblResDoWaitTxComm(ev, pPostEv);
  }

  /* #30 Once final FBl response request processed, reset all flags to prevent from a new response at next power-on/reset. */
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_FBLRES_RSTFLAGS))
  {
    ev = Dcm_DiagFblResDoResetFlags(ev, pPostEv);
  }

  /* #40 If any FBL final response confirmation received, do the designated job (e.g. session transition). */
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_FBLRES_TXCONF))
  {
    (void)Dcm_DiagFblResDoProcessTxConfirmation(ev, pPostEv);
  }
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagTaskWorker()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskWorker(Dcm_TskTaskEvOptType ev
                                                 ,Dcm_TskTaskEvPtrType pPostEv)
{
#if (DCM_NET_PROCESSING_CANCELLATION_ENABLED == STD_ON)                                                                                              /* COV_DCM_UNSUPPORTED XF */
  /* Important: this event is a synchronization event between high- and low-priority tasks.
   * Never move this event processing into another task than the one that initiates the new request processing (DCM_TSK_EV_DIAG_WORK_NEW_REQ).
   * Otherwise the clean-up jobs from DCM_TSK_EV_DIAG_WORK_KILL_JOBS event may be performed AFTER the new request processing has been started.
   * This will lead to out of sync of services post- and main-processing!
  */
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_WORK_KILL_JOBS))
  {
    Dcm_TskClrLocalEvent(ev, DCM_TSK_EV_DIAG_WORK_KILL_JOBS); /* Already processed - avoid re-execution of this event if kill-job is nested */       /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
    ev = Dcm_DiagWorkerDoCancelProcessing(ev, pPostEv);
  }
#endif

  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_WORK_TX_END_FINAL))
  {
    Dcm_TskClrLocalEvent(ev, DCM_TSK_EV_DIAG_WORK_TX_END_FINAL); /* Already processed - avoid re-execution of this event if kill-job is nested */    /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
    Dcm_DiagWorkerDoPostProcessing();
  }

  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_WORK_EXT_SET2DEF))
  {
    Dcm_TskClrLocalEvent(ev, DCM_TSK_EV_DIAG_WORK_EXT_SET2DEF); /* Already processed - avoid re-execution of this event if kill-job is nested */     /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
    ev = Dcm_DiagWorkerSetDefSessionExtern(ev, pPostEv);
  }

  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_WORK_INT_SET2DEF))
  {
    Dcm_TskClrLocalEvent(ev, DCM_TSK_EV_DIAG_WORK_INT_SET2DEF); /* Already processed - avoid re-execution of this event if kill-job is nested */     /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
    Dcm_StateSetSession(0);
  }

  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_WORK_NEW_REQ))
  {
    ev = Dcm_DiagWorkerProcessNewRequest(ev, pPostEv);
  }

  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_WORK_TX_END_RCRRP))
  {
    ev = Dcm_DiagWorkerProcessRcrRpTxEnd(ev, pPostEv);
  }

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON) && \
    (DCM_DIAG_RCRRP_LIMIT_ENABLED == STD_ON)
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_WORK_CANCEL_OP))
  {
    Std_ReturnType lResult = Dcm_PagedBufferCancel();

    if(lResult == DCM_E_PROCESSINGDONE)
    {
      /* Stop polling and wait for confirmation. */
      Dcm_ProcessingDone();
    }
  }
#endif

  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_WORK_REPEAT))
  {
    (void)Dcm_DiagWorkerDoRepeat(ev, pPostEv);
  }
}                                                                                                                                                    /* PRQA S 6010, 6050 */ /* MD_MSR_STPTH, MD_MSR_STCAL */

/**********************************************************************************************************************
 *  Dcm_DiagTaskTx()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskTx(Dcm_TskTaskEvOptType ev
                                             ,Dcm_TskTaskEvPtrType pPostEv)
{
#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_TX_SEND_PAGED))
  {
    /* Wait for RCR-RP if SPRMIB was set */
    if ( (Dcm_InstanceContext.Diag.MsgContext.msgAddInfo.suppressPosResponse == TRUE) /* SPRMIB == TRUE */
       &&((Dcm_DiagGetTranspObj()->Flags & (DCM_NET_TOBJ_FLAG_RCRRP_SENT | DCM_NET_TOBJ_FLAG_RCRRP_ON_TX )) == 0) /* RcrRp was not sent yet */
       )
    {
      /* wait for P2 timeout and RCR-RP response transmission */
      Dcm_TskSetLocalEvent(*pPostEv, DCM_TSK_EV_DIAG_TX_SEND_PAGED); /* retry later */
      Dcm_TskClrLocalEvent(ev, DCM_TSK_EV_DIAG_TX_SEND_PAGED); /* avoid transmit attempt now */                                                      /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
    }
  }
#endif

  if(Dcm_TskIsLocalEventSet(ev, (DCM_TSK_EV_DIAG_TX_SEND_PAGED | DCM_TSK_EV_DIAG_TX_SEND_LINEAR)))
  {
    /* kill any pending RCR-RP orders */
    Dcm_TskClrLocalEvent(ev, DCM_TSK_EV_DIAG_TX_SEND_RCRRP);                                                                                         /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
    Dcm_TmrStopTimer(DCM_TMR_ID_P2);/* stop in any case since from now on only the service will be finalized (either with or without response) */

    if ( (Dcm_InstanceContext.Diag.DoSuppressResponse == TRUE)                 /* No response to send */
       &&(0 == (Dcm_DiagGetTranspObj()->Flags & (DCM_NET_TOBJ_FLAG_RCRRP_SENT | DCM_NET_TOBJ_FLAG_RCRRP_ON_TX /* Suppress only if RcrRp was not sent or not waiting for RCR-RP confirmation. If just attempted -> skip RCR-RP transmission */
                                            /* | DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ - since DCM_TSK_EV_DIAG_TX_SEND_RCRRP cleared -> RCR-RP will not be sent. Instead finish the service processing at P2 time */))) )
    {
      Dcm_DiagTxFinalization(Dcm_DiagGetTranspObj(), DCM_E_OK);/* always OK */
    }
    else
    {
      /* prepare final response transmission */
      if(Dcm_DiagGetTranspObj()->State == DCM_NET_TOBJ_STATE_READY)
      {
        /* clear flag */
        Dcm_UtiBitOpClr(Dcm_NetTransportObjectFlagType, Dcm_DiagGetTranspObj()->Flags, (DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ | DCM_NET_TOBJ_FLAG_RCRRP_ON_TX)); /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
        Dcm_DiagGetTranspObj()->State = DCM_NET_TOBJ_STATE_PREPTX;
        Dcm_DiagGetTranspObj()->BuffInfo.SduDataPtr = Dcm_NetGetBufferPtrOfTranspObj(Dcm_DiagGetTranspObj());/* reassign the worker buffer */

        if(Dcm_InstanceContext.Diag.ErrorRegister == DCM_E_POSITIVERESPONSE)
        {
          /* Positive response */
          Dcm_DiagGetTranspObj()->BuffInfo.SduDataPtr[0] += 0x40u;
          Dcm_DiagGetTranspObj()->BuffInfo.SduLength = (PduLengthType)(Dcm_InstanceContext.Diag.MsgContext.resDataLen + 1u); /* don't forget the SID byte */
        }
        else
        {
          /* Neg response */
          Dcm_DiagGetTranspObj()->BuffInfo.SduDataPtr[1] = Dcm_DiagGetTranspObj()->BuffInfo.SduDataPtr[0];
          Dcm_DiagGetTranspObj()->BuffInfo.SduDataPtr[0] = 0x7Fu;
          Dcm_DiagGetTranspObj()->BuffInfo.SduDataPtr[2] = (Dcm_MsgItemType)Dcm_InstanceContext.Diag.ErrorRegister;
          Dcm_DiagGetTranspObj()->BuffInfo.SduLength     = 3u;
        }

#if (DCM_PAGED_BUFFER_ENABLED == STD_ON)
        if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_TX_SEND_PAGED))
        {
          Dcm_DiagGetTranspObj()->ResType = DCM_NET_TOBJ_RESTYPE_PAGED;
        }
        else
#endif
        {
          Dcm_DiagGetTranspObj()->ResType = DCM_NET_TOBJ_RESTYPE_LINEAR;
        }

        Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND);
      }
      else
      {
        /* retry later */
        Dcm_TskSetLocalEvent(*pPostEv, (ev & (Dcm_TskTaskEvOptType)(DCM_TSK_EV_DIAG_TX_SEND_PAGED | DCM_TSK_EV_DIAG_TX_SEND_LINEAR)));
      }
    }
  }

  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_TX_SEND_RCRRP))
  {
    /* don't start the P2* timer within the RCR-RP confirmation but here because of prioritization and synchronization issues which could occur otherwise */
    Dcm_TmrStartTimer(DCM_TMR_ID_P2, Dcm_InstanceContext.Diag.P2Timings.P2Star);/* start now to cover also the application triggered RCR-RPs */

    Dcm_InstanceContext.Diag.MsgContext.msgAddInfo.suppressPosResponse = 0;/* reset the suppress bit and send final response */

#if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
    if((Dcm_DiagGetQueuedTranspObj()->Flags & DCM_NET_TOBJ_FLAG_INTERNAL) != 0)
    {
      /* suppress any RCR-RP responses on RoE - just do loop back ! */
      Dcm_DiagRcrRpTxFinished(Dcm_DiagGetQueuedTranspObj(), DCM_E_OK); /* always OK */
    }
    else
#endif
    {
      Dcm_UtiBitOpClr(Dcm_NetTransportObjectFlagType, Dcm_DiagGetQueuedTranspObj()->Flags, DCM_NET_TOBJ_FLAG_RCRRP_TX_REQ);                          /* PRQA S 0277 */ /* MD_Dcm_BitNegation_0277 */
      Dcm_UtiBitOpSet(Dcm_NetTransportObjectFlagType, Dcm_DiagGetQueuedTranspObj()->Flags, DCM_NET_TOBJ_FLAG_RCRRP_ON_TX); /* mark transmission flag */

      Dcm_NetComposeAddNegResponse(Dcm_DiagGetQueuedTranspObj()
                                  ,DCM_NET_TOBJ_RESTYPE_RCRRP
                                  ,DCM_E_REQUESTCORRECTLYRECEIVEDRESPONSEPENDING);

      Dcm_TskSetEvent(DCM_TSK_ID_NET_TX, DCM_TSK_EV_NET_TX_SEND); /* delegate job */
    }
  }
}

#if (DCM_TSK_NUM_DIAG_RECOVERY > 0)                                                                                                                  /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_DiagTaskRecovery()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_DiagTaskRecovery(Dcm_TskTaskEvOptType ev
                                                   ,Dcm_TskTaskEvPtrType pPostEv)
{
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_RECOVERY_GETSTATE))
  {
    Std_ReturnType lResult;

    /* Retrieve the recovery information from the application. */
    lResult = Dcm_GetRecoveryStates(&Dcm_InstanceContext.Repeater.Contexts.Context.RecoveryInfo);

    switch(lResult)
    {
    case DCM_E_OK:
      Dcm_DiagSafeProcessRecoveryInfo(&Dcm_InstanceContext.Repeater.Contexts.Context.RecoveryInfo);
      Dcm_TskSetLocalEvent(ev, DCM_TSK_EV_DIAG_RECOVERY_FINISH);
      break;
    case DCM_E_PENDING:
      /* Retry next time. */
      Dcm_TskSetLocalEvent(*pPostEv, DCM_TSK_EV_DIAG_RECOVERY_GETSTATE);
      break;
    default:
      Dcm_DebugAssert((lResult == DCM_E_NOT_OK), DCM_SID_GETRECOVERYSTATES, DCM_E_INTERFACE_RETURN_VALUE)                                            /* COV_DCM_RTM_DEV_DEBUG XF */
      /* Abort recovering. */
      Dcm_TskSetLocalEvent(ev, DCM_TSK_EV_DIAG_RECOVERY_FINISH);
      break;
    }
  }

  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_DIAG_RECOVERY_FINISH))
  {
    Dcm_SingletonContext.Network.RxAllowed = TRUE;
  }
}
#endif

/**********************************************************************************************************************
 *  Dcm_DiagLookUpFilter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_DiagLookUpFilter(sint16_least lookUpResult
                                                           ,Dcm_VarRefMemPtrType lookUpFilterTable
                                                           ,Dcm_DiagCheckLvlType chkLevel
                                                           ,Dcm_NegativeResponseCodePtrType errorCode)
{
  sint16_least lLookUpResult;

  /* #10 Check if out of boundary access may occur. */
  Dcm_DebugAssert((chkLevel < DCM_NUM_DIAG_CHK_LVLS), DCM_SID_INTERNAL, DCM_E_PARAM)                                                                 /* COV_DCM_RTM_DEV_DEBUG XF */

  /* #20 Check if diagnostic object exists in current variant. */
  lLookUpResult = Dcm_VarMgrLookUpFilter(lookUpResult, lookUpFilterTable);

  /* #30 If diagnostic object not supported in current variant at all: */
  if(lLookUpResult < 0)
  {
    /* #40 Set appropriate NRC depending on the diagnostic object type. */
    *errorCode = Dcm_DiagObjNotFoundNrcs[chkLevel];
  }
  /* #50 Otherwise if diagnostic object not supported in current session: */
  else if (!Dcm_StateIsSupportedInSession(Dcm_StateGetPreconditionStates(lookUpFilterTable[lLookUpResult])))
  {
    /* #60 Invalidate lookup result and set appropriate NRC depending on the diagnostic object type. */
    lLookUpResult = -1; /* override result */
    *errorCode = Dcm_StateSessionNrcs[chkLevel];
  }
  else
  {
    /* #70 Otherwise positive result will be returned. */
    *errorCode = DCM_E_POSITIVERESPONSE;
  }

  /* #80 Return final result. */
  return lLookUpResult;
}

#if (DCM_DIAG_SF_ONLY_SERVICE_ENABLED == STD_ON)                                                                                                     /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DiagSvcWithOnlySubFuncReqLengthGetter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_DiagSvcWithOnlySubFuncReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef)
{
  DCM_IGNORE_UNREF_PARAM(sfRef);                                                                                                                     /* PRQA S 3112 */ /* MD_Dcm_3112 */
  /* Returns always the constant length of one byte. */
  return 1u;
}
#endif

#if (DCM_DIAG_ANY_SERVICE_WITH_SF_ENABLED == STD_ON)                                                                                                 /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_DiagVerifyServiceWithSubFunction()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_DiagVerifyServiceWithSubFunction(
                                                                 Dcm_MsgContextPtrType                pMsgContext
                                                                ,Dcm_Uint8ConstDataPtrType            lookUpTable
                                                                ,Dcm_VarRefMemPtrType                 lookUpFilterTable
                                                                ,Dcm_DiagServiceLengthGetterFuncType  svcLengthGetter
                                                                ,Dcm_DiagSubServiceRefOptPtrType      pSubSvcRef)
{
  Dcm_NegativeResponseCodeType lErrorCode;
  sint16_least                 lLookUpResult;

  /* Set to a safe index */
  *pSubSvcRef = 0;

  /* Min Length already checked in DiagDispatcher and expected to be 1 !!! */
  Dcm_DebugAssert((pMsgContext->reqDataLen > 0), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                              /* COV_DCM_RTM_DEV_DEBUG XF */

  lLookUpResult = Dcm_DiagLookUpFilter(Dcm_UtiLookUpUint8(lookUpTable, pMsgContext->reqData[0])
                                      ,lookUpFilterTable
                                      ,DCM_DIAG_CHK_LVL_SUBFUNC
                                      ,&lErrorCode);

  if(lLookUpResult >= 0)
  {
    Dcm_DiagSubServiceLengthType expectedLength;
    /* Mark found position in any case if found */
    *pSubSvcRef = (Dcm_DiagSubServiceRefOptType)lLookUpResult;

    expectedLength = svcLengthGetter((Dcm_DiagSubServiceRefOptType)lLookUpResult);

    if( (expectedLength == 0) /* dynamic length */
      ||(expectedLength == pMsgContext->reqDataLen) ) /* SF + data */
    {
      lErrorCode = Dcm_StateCheck(lookUpFilterTable[lLookUpResult], DCM_DIAG_CHK_LVL_SUBFUNC);
    }
    else
    {
      lErrorCode = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
    }
    /* Extract SF in any case if supported */
    Dcm_DiagMoveOnReqWithLength(pMsgContext, 1u);                                                                                                    /* PRQA S 3109 */ /* MD_MSR_14.3 */
    Dcm_DiagMoveOnResWithLengthAll(pMsgContext, 1u);                                                                                                 /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }/* else - lNrc is already set */
  return lErrorCode;
}
#endif
#if (DCM_VARMGR_MULTI_SVC_INCLUSIVE_ENABLED == STD_ON)                                                                                               /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_VarMgrIsEnabledInActiveVariants()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(boolean, DCM_CODE) Dcm_VarMgrIsEnabledInActiveVariants(Dcm_CfgStateRefOptType cfgVariantRef)
{
  Dcm_CfgVarMgrDiagVariantIdOptType varRowIter = Dcm_VarMgrBitSetCalcSize(DCM_VARMGR_NUM_DIAG_VARIANTS));

  /* scan all variants (at least 8 way scan) for at least one match */
  do
  {
    --varRowIter;
    if((Dcm_PbCfgVarMgrDiagVariantFilter[cfgVariantRef][varRowIter] & Dcm_SingletonContext.VarMgr.ActiveCfgVariants[varRowIter]) != 0)
    {
      return TRUE;/* at least one matched variant */
    }/* else - continue searching */
  }
  while(varRowIter != 0);
  return FALSE;
}
#endif

#if(DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_VarMgrLookUpFilter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_VarMgrLookUpFilter(sint16_least lookUpResult
                                                             ,Dcm_VarRefMemPtrType lookUpFilterTable)
{
  if( (lookUpResult >= 0)
    &&(Dcm_VarMgrIsEnabledInActiveVariants(lookUpFilterTable[lookUpResult]) == FALSE) )
  {
    lookUpResult = -1; /* override result */
  }
  return lookUpResult;
}
#endif
#if (DCM_SVC_01_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc01GetAvailabilityMask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_Svc01GetAvailabilityMask(uint8 id, P2VAR(uint32, AUTOMATIC, AUTOMATIC) pMaskValue)
{
  /* #10 Return the lookup index and AID bit mask for given OBD PID on service 0x01. */
  return Dcm_ObdIdMgrGetAvailabilityMask(id, Dcm_CfgSvc01LookUpTable, Dcm_CfgSvc01ExecPrecondTable, Dcm_CfgSvc01SupportedIdMask, pMaskValue);
}
#endif /* (DCM_SVC_01_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_04_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc04_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc04_XX_RepeaterProxy(Dcm_OpStatusType      opStatus
                                                                   ,Dcm_MsgContextPtrType pMsgContext)                                               /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
{
  Std_ReturnType lStdResult;
  Dem_ReturnClearDTCType lResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lResult = Dcm_DemAPI(ClearDTC)(DEM_DTC_GROUP_ALL_DTCS
                                ,DEM_DTC_FORMAT_OBD
                                ,DEM_DTC_ORIGIN_PRIMARY_MEMORY);

  switch(lResult)
  {
  case DCM_DEM_RET_CLEAR_OK:
    lStdResult = DCM_E_PROCESSINGDONE;
    break;
  case DCM_DEM_RET_CLEAR_PENDING:
    lStdResult = DCM_E_PENDING; /* try again later */
    break;
  default:
    Dcm_DemApiSetNegResponse(lResult, Dcm_Svc04NrcMapClearDTC);
    lStdResult = DCM_E_PROCESSINGDONE;
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_04_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON)                                                 /* COV_DCM_UNSUPPORTED XF xf xf */
/**********************************************************************************************************************
 *  Dcm_Svc06GetAvailabilityMask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_Svc06GetAvailabilityMask(uint8 id, P2VAR(uint32, AUTOMATIC, AUTOMATIC) pMaskValue)
{
  /* #10 return the lookup index and AID bit mask for given OBD MID on service 0x06. */
  return Dcm_ObdIdMgrGetAvailabilityMask(id, Dcm_CfgSvc06LookUpTable, Dcm_CfgSvc06ExecPrecondTable, Dcm_CfgSvc06SupportedIdMask, pMaskValue);
}
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON) */
#if (DCM_SVC_08_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc08GetAvailabilityMask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_Svc08GetAvailabilityMask(uint8 id, P2VAR(uint32, AUTOMATIC, AUTOMATIC) pMaskValue)
{
  /* #10 Return the lookup index and AID bit mask for given OBD TID on service 0x08. */
  return Dcm_ObdIdMgrGetAvailabilityMask(id, Dcm_CfgSvc08LookUpTable, Dcm_CfgSvc08ExecPrecondTable, Dcm_CfgSvc08SupportedIdMask, pMaskValue);
}
#endif /* (DCM_SVC_08_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_09_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc09GetAvailabilityMask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_Svc09GetAvailabilityMask(uint8 id, P2VAR(uint32, AUTOMATIC, AUTOMATIC) pMaskValue)
{
  /* #10 Return the lookup index and AID bit mask for given OBD VID on service 0x09. */
  return Dcm_ObdIdMgrGetAvailabilityMask(id, Dcm_CfgSvc09LookUpTable, Dcm_CfgSvc09ExecPrecondTable, Dcm_CfgSvc09SupportedIdMask, pMaskValue);
}

/**********************************************************************************************************************
 *  Dcm_Svc09_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc09_XX_RepeaterProxy(Dcm_OpStatusType opStatus
                                                                   ,Dcm_MsgContextPtrType pMsgContext)                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  Dcm_ObdIdMgrListItemPtrType  lIdList = Dcm_InstanceContext.Repeater.Contexts.Context.Svc09.ParserDesc.ParseResult;
  uint8 lVidDataLength = Dcm_CfgSvc09ServiceInfoTable[lIdList->Result.Handle].Length;

  /* compose response record */
  pMsgContext->resData[0] = lIdList->Id;

  lStdResult = Dcm_CfgSvc09ServiceInfoTable[lIdList->Result.Handle].OpFunc(opStatus, &pMsgContext->resData[1]
# if (DCM_DCM_AR_VERSION >= DCM_DCM_AR_VERSION_422)
                                                                          ,&lVidDataLength
# endif
                                                                          );

  if (lStdResult == DCM_E_OK)
  {
# if (DCM_DCM_AR_VERSION >= DCM_DCM_AR_VERSION_422)
#  if (DCM_DEV_ERROR_DETECT == STD_ON)
    /* Update final response length only in positive/final case */
    if (lVidDataLength > (Dcm_CfgSvc09ServiceInfoTable[lIdList->Result.Handle].Length))
    {
      lStdResult = DCM_E_NOT_OK;
      Dcm_SetNegResponse(DCM_E_PANIC_NRC);
      Dcm_DebugReportError(DCM_SID_SVCPORT_DATASVCS_OP_READVID, DCM_E_INTERFACE_BUFFER_OVERFLOW);
    }
    else
#  endif
# endif
    {
      /* VID reading finished with OK -> check for next */
      Dcm_DiagMoveOnResWithLength(pMsgContext, 1+lVidDataLength); /* VID size + data size */                                                         /* PRQA S 3109 */ /* MD_MSR_14.3 */
    }

    lStdResult = DCM_E_PROCESSINGDONE;
  }
  else if(lStdResult == DCM_E_PENDING)
  {
    /* Retry later. */
  }
  else
  {
    Dcm_DebugApiCheckRte((lStdResult == DCM_E_NOT_OK), DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)

    Dcm_SetNegResponse(DCM_E_CONDITIONSNOTCORRECT);
    lStdResult = DCM_E_PROCESSINGDONE;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_09_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_10_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_SUPPORT_ALWAYS TX */
# if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc10_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc10_XX_RepeaterProxy(Dcm_OpStatusType opStatus
                                                                   ,Dcm_MsgContextPtrType pMsgContext)                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  switch(Dcm_InstanceContext.Repeater.Contexts.Progress)
  {
  case DCM_SVC10_PROGRESS_WAIT_RST_ACK:
    /* Check mode switch state */
    lStdResult = Dcm_ModeMgrArEnvSwitchAckEcuReset();
    switch(lStdResult)
    {
    case DCM_E_PENDING:
      return DCM_E_PENDING;/* Wait for acknowledge */
    case DCM_E_OK:
#  if (DCM_DIAG_RCRRP_ON_BOOT_ENABLED == STD_ON)
      if(Dcm_NetGetProtObjOfTranspObj(Dcm_DiagGetTranspObj())->HasRespPendOnBoot == TRUE)                                                            /* COV_DCM_RTM_DEPENDS_ON_UNSUPPORTED TX */
      {
        Dcm_InstanceContext.Repeater.Contexts.Progress = DCM_SVC10_PROGRESS_WAIT_RCRRP_ACK;
        return DCM_E_FORCE_RCRRP;
      }
      opStatus = DCM_FORCE_RCRRP_OK;/* Simulate RCR-RP loop back for the next case DCM_SVC10_PROGRESS_WAIT_RCRRP_ACK */
#  else
      Dcm_InstanceContext.Repeater.Contexts.Progress = DCM_SVC10_PROGRESS_SET_PRGCOND;
#   if (DCM_SVC_10_RST2BOOT_HIS_ENABLED == STD_ON)
      Dcm_SplitTaskEnterCS();/* avoid interrupt from the Dcm_DiagTaskTx */                                                                           /* PRQA S 3109 */ /* MD_MSR_14.3 */
      if(pMsgContext->msgAddInfo.suppressPosResponse != 0)
      {
        Dcm_InstanceContext.Repeater.Contexts.Context.Svc10.ProgConditions.ResponseRequired = FALSE;
        Dcm_TmrStopTimer(DCM_TMR_ID_P2);/* Stop to avoid inconsistency between P2 timer and the SetProgCond asynchronous API's "ResponseRequired" value.*/
      }
      else
      {
        Dcm_InstanceContext.Repeater.Contexts.Context.Svc10.ProgConditions.ResponseRequired = TRUE;
      }
      Dcm_SplitTaskLeaveCS();/* avoid interrupt from the Dcm_DiagTaskTx */                                                                           /* PRQA S 3109 */ /* MD_MSR_14.3 */
#   else
      Dcm_InstanceContext.Repeater.Contexts.Context.Svc10.ProgConditions.ResponseRequired = FALSE;/* no response required since DCM sends the final response */
#   endif
#  endif
      break;/* go on with next step - fall through */
    default:
      Dcm_SetNegResponse(DCM_E_CONDITIONSNOTCORRECT);
      return DCM_E_PROCESSINGDONE;
    }
#  if (DCM_DIAG_RCRRP_ON_BOOT_ENABLED == STD_ON)
  /* fall through for synchronous processing */
  case DCM_SVC10_PROGRESS_WAIT_RCRRP_ACK:
    if(opStatus != DCM_FORCE_RCRRP_OK)
    {
      Dcm_SetNegResponse(DCM_E_CONDITIONSNOTCORRECT);
      break;                                                                                                                                         /* PRQA S 3333 */ /* MD_Dcm_Optimize_3333 */
    }
#   if (DCM_SVC_10_RST2BOOT_HIS_ENABLED == STD_ON)
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc10.ProgConditions.ResponseRequired = TRUE;/* always since at least one RCR-RP is sent! */
#   else
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc10.ProgConditions.ResponseRequired = FALSE;/* no response required since DCM sends the final response */
#   endif
    Dcm_InstanceContext.Repeater.Contexts.Progress = DCM_SVC10_PROGRESS_SET_PRGCOND;
#  endif
    /* fall through for synchronous processing */
  case DCM_SVC10_PROGRESS_SET_PRGCOND:                                                                                                               /* PRQA S 2003 */ /* MD_Dcm_Optimize_2003 */
    /* Consider the SPRMIB now in order to take any sent RCR-RP response */
    lStdResult = Dcm_SetProgConditions(&Dcm_InstanceContext.Repeater.Contexts.Context.Svc10.ProgConditions);
    switch(lStdResult)
    {
    case DCM_E_OK:
#  if (DCM_SVC_10_RST2BOOT_HIS_ENABLED == STD_ON)
      lStdResult = Dcm_ModeMgrArEnvSwitchReqEcuReset(DCM_MODEMGR_ARENV_MODE_ECURESET_EXECUTE);
      if(lStdResult == DCM_E_OK)/* fire and forget */
      {
        return DCM_E_OK;/* just wait for reset */
      }
      /* This code shall not be reached, since the programming conditions are already set! */
      Dcm_SetNegResponse(DCM_E_PANIC_NRC); /* Use panic NRC since the first mode switch has succeeded, and this one shall too. */
#  endif
      break; /* send final response and if applicable - do reset */
    case DCM_E_PENDING:
      return DCM_E_PENDING;/* Wait for finished job first */
    case DCM_E_NOT_OK:
      Dcm_SetNegResponse(DCM_E_CONDITIONSNOTCORRECT);
      break;
    default:
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
      Dcm_SetNegResponse(DCM_E_PANIC_NRC);
      break;
    }
    break;
  default:
    Dcm_SetNegResponse(DCM_E_PANIC_NRC);
    Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */
    break;
  }
  return DCM_E_PROCESSINGDONE;
}                                                                                                                                                    /* PRQA S 2006, 6030, 6050 */ /* MD_Dcm_Optimize_2006, MD_MSR_STCYC, MD_MSR_STCAL */
# endif
#endif /* (DCM_SVC_10_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_11_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_SVC_11_ECU_RESET_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc11_EcuRst_WaitForAck()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11_EcuRst_WaitForAck(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext)                                              /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdResult = Dcm_ModeMgrArEnvSwitchAckEcuReset();
  switch(lStdResult)
  {
  case DCM_E_OK:
    /* switch accomplished */
    lStdResult = DCM_E_PROCESSINGDONE;
    break;
  case DCM_E_PENDING:
    /* Result already set
      lStdResult = DCM_E_PENDING; */
    break;
  default: /* any error situation */
    Dcm_SetNegResponse(DCM_E_CONDITIONSNOTCORRECT);
    lStdResult = DCM_E_PROCESSINGDONE;
    break;
  }
  return lStdResult;
}
# endif

# if (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc11_RapPwrDwn_WaitForAck()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11_RapPwrDwn_WaitForAck(Dcm_OpStatusType opStatus
                                                                       ,Dcm_MsgContextPtrType pMsgContext)                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdResult = Dcm_ModeMgrArEnvSwitchAckRapidPowerShutDown();
  switch(lStdResult)
  {
  case DCM_E_OK:
    /* switch accomplished */
    lStdResult = DCM_E_PROCESSINGDONE;
    break;
  case DCM_E_PENDING:
    /* Result already set
      lStdResult = DCM_E_PENDING; */
    break;
  default: /* any error situation */
    Dcm_SetNegResponse(DCM_E_CONDITIONSNOTCORRECT);
    lStdResult = DCM_E_PROCESSINGDONE;
    break;
  }
  return lStdResult;
}
# endif

# if (DCM_SVC_11_ECU_RESET_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc11_ProcessEcuReset()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11_ProcessEcuReset(Dcm_ModeMgrArEnvModeEcuResetType mode)
{
  Std_ReturnType lResult;

  /* Try performing mode switch on ECU reset. */
  if(Dcm_ModeMgrArEnvSwitchReqEcuReset(mode) == DCM_E_OK)
  {
    /* If succeeded, go on with waiting for acknowledge. */
    Dcm_RepeaterSetCallee(Dcm_Svc11_EcuRst_WaitForAck);
    lResult = DCM_E_LOOP;/* speed up processing */
  }
  else
  {
    /* If this attempt fails, send back NRC 0x22 to notify diagnostic client. */
    Dcm_SetNegResponse(DCM_E_CONDITIONSNOTCORRECT);
    lResult = DCM_E_PROCESSINGDONE;
  }
  return lResult;
}
# endif

# if (DCM_MODE_RPD_SHTDWN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc11_ProcessRapPwrDwn()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc11_ProcessRapPwrDwn(Dcm_ModeMgrArEnvModeRapidPowerShutDownType mode)
{
  Std_ReturnType lResult;

  /* Try performing mode switch on ECU reset. */
  if(Dcm_ModeMgrArEnvSwitchReqRapidPowerShutDown(mode) == DCM_E_OK)
  {
    /* If succeeded, go on with waiting for acknowledge. */
    Dcm_RepeaterSetCallee(Dcm_Svc11_RapPwrDwn_WaitForAck);
    lResult = DCM_E_LOOP;/* speed up processing */
  }
  else
  {
    /* If this attempt fails, send back NRC 0x22 to notify diagnostic client. */
    Dcm_SetNegResponse(DCM_E_CONDITIONSNOTCORRECT);
    lResult = DCM_E_PROCESSINGDONE;
  }

  return lResult;
}
# endif
#endif /* (DCM_SVC_11_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_14_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc14_XX_RepeaterProxy()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc14_XX_RepeaterProxy(Dcm_OpStatusType      opStatus
                                                                   ,Dcm_MsgContextPtrType pMsgContext)                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType         lStdResult;
  Dem_ReturnClearDTCType lResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lResult = Dcm_DemAPI(ClearDTC)(Dcm_InstanceContext.Repeater.Contexts.Context.Svc14.Dtc
                                ,DEM_DTC_FORMAT_UDS
                                ,DEM_DTC_ORIGIN_PRIMARY_MEMORY);

  switch(lResult)
  {
  case DCM_DEM_RET_CLEAR_OK:
    lStdResult = DCM_E_PROCESSINGDONE;
    break;
  case DCM_DEM_RET_CLEAR_PENDING:
    lStdResult = DCM_E_PENDING; /* try again later */
    break;
  default:
    Dcm_DemApiSetNegResponse(lResult, Dcm_Svc14NrcMapClearDTC);
    lStdResult = DCM_E_PROCESSINGDONE;
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19ReqLengthGetter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc19ReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef)
{
  /* Return sub-function specific length. */
  return Dcm_CfgSvc19SubFuncInfo[sfRef].ReqLength;
}
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
# if (DCM_SVC_19_03_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetNxtFltrdRecord()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetNxtFltrdRecord(Dcm_MsgType pData
                                                                            ,Dcm_CfgNetBufferSizePtrType pAvailLen)
{
  uint32                                lDtc;
  Dcm_CfgNetBufferSizeOptType           lAvailLen;
  uint8                                 recordNumber;
  Dcm_DemReturnGetNextFilteredItemType  demResult;
  Std_ReturnType                        lStdResult;
  DCM_UTIRTLMTR_CTR_DEF

  DCM_UTIRTLMTR_CTR_INIT
  lAvailLen = *pAvailLen;
  lStdResult = DCM_E_BUFFERTOOLOW;

  while (lAvailLen >= 4u)
  {
    demResult = Dcm_DemAPI(GetNextFilteredRecord)(&lDtc, &recordNumber);
    if(demResult == DCM_DEM_RET_FILTERED_OK)
    {
      pData[0] = Dcm_UtiGetHiLoByte(lDtc);
      pData[1] = Dcm_UtiGetLoHiByte(lDtc);
      pData[2] = Dcm_UtiGetLoLoByte(lDtc);
      pData[3] = recordNumber;
      /* commit data */
      Dcm_UtiNextItemByPtr(pData, 4u);
      lAvailLen -= 4u;
    }
    else
    {
      lStdResult = Dcm_DemApiConvDemRsltGetNextFilteredItem(demResult);
      break;
    }

    DCM_UTIRTLMTR_CTR_NEXT /* if link-time and limit = 0 -> leads to overflow and practically no limitation (at least 255 iterations to "pending")*/
    DCM_UTIRTLMTR_CTR_HANDLE_AND_BREAK(lStdResult, DCM_E_PENDING) /* signal retry */                                                                 /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
  }

  *pAvailLen = (Dcm_CfgNetBufferSizeOptType)lAvailLen; /* commit all copied data */
  return lStdResult; /*lint !e438 pData is always post incremented */
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_SVC_19_08_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetNxtFltrdSeverity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetNxtFltrdSeverity(Dcm_OpStatusType opStatus
                                                                           ,Dcm_MsgContextPtrType pMsgContext)                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_ON)
  {
    Dcm_MsgLenType dataLen = Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.NumDtc;
    dataLen = (Dcm_MsgLenType)(dataLen * 6);
    Dcm_PagedBufferStart(Dcm_Svc19UtiCpyDemGetNxtFltrdSeverity, NULL_PTR, dataLen);
  }
  return DCM_E_OK;
#  else
  Dcm_Svc19UtiStartLinearCopy(Dcm_Svc19UtiCpyDemGetNxtFltrdSeverity);
  return DCM_E_LOOP;
#  endif
}
# endif

# if (DCM_SVC_19_08_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetNxtFltrdSeverity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetNxtFltrdSeverity(Dcm_MsgType pData
                                                                              ,Dcm_CfgNetBufferSizePtrType pAvailLen)
{
  uint32                                lDtc;
  Dcm_CfgNetBufferSizeOptType           lAvailLen;
  uint8                                 dtcStatus;
  uint8                                 dtcFuncUnit;
  Dem_DTCSeverityType                   dtcSeverity;
  Dcm_DemReturnGetNextFilteredItemType  demResult;
  Std_ReturnType                        lStdResult;
  DCM_UTIRTLMTR_CTR_DEF

  DCM_UTIRTLMTR_CTR_INIT
  lAvailLen = *pAvailLen;
  lStdResult = DCM_E_BUFFERTOOLOW;

  while (lAvailLen >= 6u)
  {
    demResult = Dcm_DemAPI(GetNextFilteredDTCAndSeverity)(&lDtc, &dtcStatus, &dtcSeverity, &dtcFuncUnit);
    if(demResult == DEM_FILTERED_OK)
    {
      Dcm_ExtSvc19UtiPatchDtcStatusApplyByRequest(&dtcStatus);                                                                                       /* PRQA S 3109 */ /* MD_MSR_14.3 */

      pData[0] = (Dcm_MsgItemType)dtcSeverity;
      pData[1] = dtcFuncUnit;
      pData[2] = Dcm_UtiGetHiLoByte(lDtc);
      pData[3] = Dcm_UtiGetLoHiByte(lDtc);
      pData[4] = Dcm_UtiGetLoLoByte(lDtc);
      pData[5] = dtcStatus;
      /* commit data */
      Dcm_UtiNextItemByPtr(pData, 6u);
      lAvailLen -= 6u;
    }
    else
    {
      lStdResult = Dcm_DemApiConvDemRsltGetNextFilteredItem(demResult);
      break;
    }

    DCM_UTIRTLMTR_CTR_NEXT /* if link-time and limit = 0 -> leads to overflow and practically no limitation (at least 255 iterations to "pending")*/
    DCM_UTIRTLMTR_CTR_HANDLE_AND_BREAK(lStdResult, DCM_E_PENDING) /* signal retry */                                                                 /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
  }

  *pAvailLen = (Dcm_CfgNetBufferSizeOptType)lAvailLen; /* commit all copied data */
  return lStdResult; /*lint !e438 pData is always post incremented */
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_SVC_19_14_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetNxtFltrdFDC()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetNxtFltrdFDC(Dcm_OpStatusType opStatus
                                                                      ,Dcm_MsgContextPtrType pMsgContext)                                            /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_ON)
  Dcm_PagedBufferStart(Dcm_Svc19UtiCpyDemGetNxtFltrdFDC
                      ,NULL_PTR
                      ,(Dcm_MsgLenType)(Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.NumDtc * 4));
  return DCM_E_OK;
#  else
  Dcm_Svc19UtiStartLinearCopy(Dcm_Svc19UtiCpyDemGetNxtFltrdFDC);
  return DCM_E_LOOP;
#  endif
}
# endif

# if (DCM_SVC_19_14_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetNxtFltrdFDC()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetNxtFltrdFDC(Dcm_MsgType pData
                                                                         ,Dcm_CfgNetBufferSizePtrType pAvailLen)
{
  uint32                                lDtc;
  Dcm_CfgNetBufferSizeOptType           lAvailLen;
  sint8                                 dtcFDC;
  Dcm_DemReturnGetNextFilteredItemType  demResult;
  Std_ReturnType                        lStdResult;
  DCM_UTIRTLMTR_CTR_DEF

  DCM_UTIRTLMTR_CTR_INIT
  lAvailLen = *pAvailLen;
  lStdResult = DCM_E_BUFFERTOOLOW;

  while (lAvailLen >= 4u)
  {
    demResult = Dcm_DemAPI(GetNextFilteredDTCAndFDC)(&lDtc, &dtcFDC);
    if(demResult == DCM_DEM_RET_FILTERED_OK)
    {
      pData[0] = Dcm_UtiGetHiLoByte(lDtc);
      pData[1] = Dcm_UtiGetLoHiByte(lDtc);
      pData[2] = Dcm_UtiGetLoLoByte(lDtc);
      pData[3] = (uint8)dtcFDC;
      /* commit data */
      Dcm_UtiNextItemByPtr(pData, 4u);
      lAvailLen -= 4u;
    }
    else
    {
      lStdResult = Dcm_DemApiConvDemRsltGetNextFilteredItem(demResult);
      break;
    }

    DCM_UTIRTLMTR_CTR_NEXT /* if link-time and limit = 0 -> leads to overflow and practically no limitation (at least 255 iterations to "pending")*/
    DCM_UTIRTLMTR_CTR_HANDLE_AND_BREAK(lStdResult, DCM_E_PENDING) /* signal retry */                                                                 /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
  }

  *pAvailLen = (Dcm_CfgNetBufferSizeOptType)lAvailLen; /* commit all copied data */
  return lStdResult; /*lint !e438 pData is always post incremented */
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_SVC_19_42_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiWwhObdDemGetNxtFltrdSeverity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiWwhObdDemGetNxtFltrdSeverity(Dcm_OpStatusType opStatus
                                                                                 ,Dcm_MsgContextPtrType pMsgContext)                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_ON)
  {
    Dcm_MsgLenType dataLen = Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.NumDtc;
    dataLen = (Dcm_MsgLenType)(dataLen * 5);
    Dcm_PagedBufferStart(Dcm_Svc19UtiWwhObdCpyDemGetNxtFltrdSeverity, NULL_PTR, dataLen);
  }
  return DCM_E_OK;
#  else
  Dcm_Svc19UtiStartLinearCopy(Dcm_Svc19UtiWwhObdCpyDemGetNxtFltrdSeverity);
  return DCM_E_LOOP;
#  endif
}
# endif

# if (DCM_SVC_19_42_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiWwhObdCpyDemGetNxtFltrdSeverity()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiWwhObdCpyDemGetNxtFltrdSeverity(Dcm_MsgType pData
                                                                                    ,Dcm_CfgNetBufferSizePtrType pAvailLen)
{
  uint32                                lDtc;
  Dcm_CfgNetBufferSizeOptType           lAvailLen;
  uint8                                 dtcStatus;
  uint8                                 dtcFuncUnit;
  Dem_DTCSeverityType                   dtcSeverity;
  Dcm_DemReturnGetNextFilteredItemType  demResult;
  Std_ReturnType                        lStdResult;
  DCM_UTIRTLMTR_CTR_DEF

  DCM_UTIRTLMTR_CTR_INIT
  lAvailLen = *pAvailLen;
  lStdResult = DCM_E_BUFFERTOOLOW;

  while (lAvailLen >= 5u)
  {
    demResult = Dcm_DemAPI(GetNextFilteredDTCAndSeverity)(&lDtc, &dtcStatus, &dtcSeverity, &dtcFuncUnit);
    if(demResult == DEM_FILTERED_OK)
    {
      Dcm_ExtSvc19UtiPatchDtcStatusApplyByRequest(&dtcStatus);                                                                                       /* PRQA S 3109 */ /* MD_MSR_14.3 */

      pData[0] = (Dcm_MsgItemType)dtcSeverity;
      pData[1] = Dcm_UtiGetHiLoByte(lDtc);
      pData[2] = Dcm_UtiGetLoHiByte(lDtc);
      pData[3] = Dcm_UtiGetLoLoByte(lDtc);
      pData[4] = dtcStatus;
      /* commit data */
      Dcm_UtiNextItemByPtr(pData, 5u);
      lAvailLen -= 5u;
    }
    else
    {
      lStdResult = Dcm_DemApiConvDemRsltGetNextFilteredItem(demResult);
      break;
    }

    DCM_UTIRTLMTR_CTR_NEXT /* if link-time and limit = 0 -> leads to overflow and practically no limitation (at least 255 iterations to "pending")*/
    DCM_UTIRTLMTR_CTR_HANDLE_AND_BREAK(lStdResult, DCM_E_PENDING) /* signal retry */                                                                 /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
  }

  *pAvailLen = (Dcm_CfgNetBufferSizeOptType)lAvailLen; /* commit all copied data */
  return lStdResult; /*lint !e438 pData is always post incremented */
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetNxtFltrdDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetNxtFltrdDtc(Dcm_OpStatusType opStatus
                                                                      ,Dcm_MsgContextPtrType pMsgContext)                                            /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_ON)
  Dcm_PagedBufferStart(Dcm_Svc19UtiCpyDemGetNxtFltrdDtc
                      ,NULL_PTR
                      ,(Dcm_MsgLenType)(Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.NumDtc * 4));
  return DCM_E_OK;
#  else
  Dcm_Svc19UtiStartLinearCopy(Dcm_Svc19UtiCpyDemGetNxtFltrdDtc);
  return DCM_E_LOOP;
#  endif
}
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetNxtFltrdDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetNxtFltrdDtc(Dcm_MsgType pData
                                                                         ,Dcm_CfgNetBufferSizePtrType pAvailLen)
{
  uint32                                lDtc;
  Dcm_CfgNetBufferSizeOptType           lAvailLen;
  uint8                                 dtcStatus;
  Dcm_DemReturnGetNextFilteredItemType  demResult;
  Std_ReturnType                        lStdResult;
  DCM_UTIRTLMTR_CTR_DEF

  DCM_UTIRTLMTR_CTR_INIT
  lAvailLen = *pAvailLen;
  lStdResult = DCM_E_BUFFERTOOLOW;

  while (lAvailLen >= 4u)
  {
    demResult =  Dcm_DemAPI(GetNextFilteredDTC)(&lDtc, &dtcStatus);
    if(demResult == DCM_DEM_RET_FILTERED_OK)
    {
      Dcm_ExtSvc19UtiPatchDtcStatusApplyByRequest(&dtcStatus);                                                                                       /* PRQA S 3109 */ /* MD_MSR_14.3 */

      pData[0] = Dcm_UtiGetHiLoByte(lDtc);
      pData[1] = Dcm_UtiGetLoHiByte(lDtc);
      pData[2] = Dcm_UtiGetLoLoByte(lDtc);
      pData[3] = dtcStatus;
      /* commit data */
      Dcm_UtiNextItemByPtr(pData, 4u);
      lAvailLen -= 4u;
    }
    else
    {
      lStdResult = Dcm_DemApiConvDemRsltGetNextFilteredItem(demResult);
      break;
    }

    DCM_UTIRTLMTR_CTR_NEXT /* if link-time and limit = 0 -> leads to overflow and practically no limitation (at least 255 iterations to "pending")*/
    DCM_UTIRTLMTR_CTR_HANDLE_AND_BREAK(lStdResult, DCM_E_PENDING) /* signal retry */                                                                 /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
  }

  *pAvailLen = (Dcm_CfgNetBufferSizeOptType)lAvailLen; /* commit all copied data */
  return lStdResult; /*lint !e438 pData is always post incremented */
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_DEMAPI_SVC_19_GETEXTRECORD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetExtRecord()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetExtRecord(Dcm_MsgType pData
                                                                       ,Dcm_CfgNetBufferSizePtrType pAvailLen)
{
  Dcm_CfgNetBufferSizeOptType              lAvailLen;
  Dem_ReturnGetExtendedDataRecordByDTCType demResult;
  Std_ReturnType                           lStdResult;
  uint16                                   dcmBufferSize;

  lAvailLen = *pAvailLen;
  lStdResult = DCM_E_BUFFERTOOLOW;

  while (lAvailLen != 0u)
  {
    dcmBufferSize = (uint16)(lAvailLen - 1u);

    demResult =  Dcm_DemAPI(GetExtendedDataRecordByDTC)(Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.Dtc
                                                        ,Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.Origin
                                                        ,Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNum
                                                        ,&pData[1]
                                                        ,&dcmBufferSize);
    if(demResult == DEM_RECORD_OK)
    {
      if(dcmBufferSize != 0)/* consider only stored records */
      {
        ++dcmBufferSize;/* potentially can be an issue if the DCM buffer will ever be larger than 65536 bytes */
        pData[0] = Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNum;
        /* commit data */
        Dcm_UtiNextItemByPtr(pData, dcmBufferSize);
        lAvailLen -= (Dcm_CfgNetBufferSizeOptType)dcmBufferSize;
      }
      if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNumList != NULL_PTR)
      {
        Dcm_UtiNextItemByPtr(Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNumList, 1u);/* get next one */
        Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNum = Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNumList[0];
        if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNum == DCM_SVC_19_RECLIST_END)/* end of list reached */
        {
          lStdResult = DCM_E_OK;
          break; /* all records were copied */
        }/* else - try next record */
      }
      else
      {
        lStdResult = DCM_E_OK;
        break; /* all records were copied */                                                                                                         /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
      }
    }
    else if(demResult == DEM_RECORD_WRONG_NUMBER)
    {
      if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNumList == NULL_PTR)/* single record query */
      {
        Dcm_DemApiSetNegResponse(demResult, Dcm_Svc19NrcMapGetExtendedDataRecordByDTC);/* if a concrete record number is requested -> set NRC */
        lStdResult = DCM_E_OK;/* finish processing */
        break;                                                                                                                                       /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
      }
      else
      {
        Dcm_UtiNextItemByPtr(Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNumList, 1u);/* get next one */
        Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNum = Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNumList[0];
        if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNum == DCM_SVC_19_RECLIST_END)/* end of list reached */
        {
          lStdResult = DCM_E_OK;
          break;                                                                                                                                     /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */ /* all records were copied */
        }/* else - try next record */
      }
    }
    else
    {
      switch (demResult)
      {
      case DEM_RECORD_WRONG_BUFFERSIZE:
        lStdResult = DCM_E_BUFFERTOOLOW;
        break;
      case DEM_RECORD_PENDING:
        lStdResult = DCM_E_PENDING;/* signal retry */
        break;
      default:
        Dcm_DemApiSetNegResponse(demResult, Dcm_Svc19NrcMapGetExtendedDataRecordByDTC);
        lStdResult = DCM_E_OK;/* finish processing */
        break;
      }
      /* Finished for this cycle or error occured. */
      break;                                                                                                                                         /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
    }
  }

  if(lStdResult == DCM_E_OK)
  {
    /* all data copied - enable immediately DTC record update */
    (void)Dcm_DemAPI(EnableDTCRecordUpdate)();
  }

  *pAvailLen = (Dcm_CfgNetBufferSizeOptType)lAvailLen; /* commit all copied data */
  return lStdResult; /*lint !e438 pData is always post incremented */
}                                                                                                                                                    /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */
# endif

# if (DCM_DEMAPI_SVC_19_GETFFRECORD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyDemGetFFRecord()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyDemGetFFRecord(Dcm_MsgType pData
                                                                      ,Dcm_CfgNetBufferSizePtrType pAvailLen)
{
  Dcm_CfgNetBufferSizeOptType           lAvailLen;
  Dem_ReturnGetFreezeFrameDataByDTCType demResult;
  Std_ReturnType                        lStdResult;
  uint16                                dcmBufferSize;

  lAvailLen = *pAvailLen;
  lStdResult = DCM_E_BUFFERTOOLOW;

  while (lAvailLen != 0)
  {
    dcmBufferSize = (uint16)lAvailLen;

    demResult =  Dcm_DemAPI(GetFreezeFrameDataByDTC)(Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.Dtc
                                                     ,Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.Origin
                                                     ,Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNum
                                                     ,&pData[0]
                                                     ,&dcmBufferSize);
    if(demResult == DEM_GET_FFDATABYDTC_OK)
    {
      if(dcmBufferSize != 0u)/* consider only stored records */
      {
        /* commit data */
        Dcm_UtiNextItemByPtr(pData, dcmBufferSize);
        lAvailLen -= (Dcm_CfgNetBufferSizeOptType)dcmBufferSize;
      }
      if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNumList != NULL_PTR)
      {
        Dcm_UtiNextItemByPtr(Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNumList, 1u);/* get next one */
        Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNum = Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNumList[0];
        if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNum == DCM_SVC_19_RECLIST_END)/* end of list reached */
        {
          lStdResult = DCM_E_OK;
          break; /* all records were copied */
        }/* else - try next record */
      }
      else
      {
        lStdResult = DCM_E_OK;
        break; /* all records were copied */                                                                                                         /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
      }
    }
    else if(demResult == DEM_GET_FFDATABYDTC_WRONG_RECORDNUMBER)
    {
      if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNumList == NULL_PTR)/* single record query */
      {
        Dcm_DemApiSetNegResponse(demResult, Dcm_Svc19NrcMapGetFreezeFrameDataByDTC);/* if a concrete record number is requested -> set NRC */
        lStdResult = DCM_E_OK;/* finish processing */
        break;                                                                                                                                       /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
      }
      else
      {
        Dcm_UtiNextItemByPtr(Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNumList, 1u);/* get next one */
        Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNum = Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNumList[0];
        if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNum == DCM_SVC_19_RECLIST_END)/* end of list reached */
        {
          lStdResult = DCM_E_OK;
          break;                                                                                                                                     /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */ /* all records were copied */
        }/* else - try next record */
      }
    }
    else
    {
      switch (demResult)
      {
      case DEM_GET_FFDATABYDTC_WRONG_BUFFERSIZE:
        lStdResult = DCM_E_BUFFERTOOLOW;
        break;
      case DEM_GET_FFDATABYDTC_PENDING:
        lStdResult = DCM_E_PENDING;/* signal retry */
        break;
      default:
        Dcm_DemApiSetNegResponse(demResult, Dcm_Svc19NrcMapGetFreezeFrameDataByDTC);
        lStdResult = DCM_E_OK;/* finish processing */
        break;
      }
      /* Finished for this cycle or error occured. */
      break;                                                                                                                                         /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
    }
  }

  if(lStdResult == DCM_E_OK)
  {
    /* all data copied - enable immediately DTC record update */
    (void)Dcm_DemAPI(EnableDTCRecordUpdate)();
  }

  *pAvailLen = (Dcm_CfgNetBufferSizeOptType)lAvailLen; /* commit all copied data */
  return lStdResult; /*lint !e438 pData is always post incremented */
}                                                                                                                                                    /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */
# endif
# if (DCM_SVC_19_CHAINING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiChainStart()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiChainStart(
                                                    P2CONST(Dcm_RepeaterProxyFuncType, AUTOMATIC, DCM_CONST) funcChain)
{
  Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.FuncChain = funcChain;
  Dcm_RepeaterSetCallee(*Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.FuncChain); /* delegate job */
  return DCM_E_LOOP;/* execute it immediately */
}
# endif

# if (DCM_SVC_19_CHAIN_END_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiChainEnd()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiChainEnd(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext)                                                     /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return DCM_E_PROCESSINGDONE;
}
# endif

# if (DCM_SVC_19_CHAINING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiChainNext()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiChainNext(void)
{
  Dcm_UtiNextItemByPtr(Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.FuncChain, 1u);
  Dcm_RepeaterSetCallee(*Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.FuncChain);
  return DCM_E_LOOP;/* take next item from list */
}
# endif

# if (DCM_SVC_19_COPY_LINEAR_DATA_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiStartLinearCopy()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc19UtiStartLinearCopy(Dcm_PagedBufferUpdateFuncType copyFunc)
{
  Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.CopyFunc = copyFunc;
  Dcm_RepeaterSetCallee(Dcm_Svc19UtiCpyLinearData); /* delegate job */
}
# endif

# if (DCM_SVC_19_COPY_LINEAR_DATA_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiCpyLinearData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiCpyLinearData(Dcm_OpStatusType opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType              lStdResult;
  Dcm_CfgNetBufferSizeOptType remainingData = (Dcm_CfgNetBufferSizeOptType)pMsgContext->resMaxDataLen;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdResult = Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.CopyFunc(pMsgContext->resData, &remainingData);

  /* commit copied data */
  remainingData = (Dcm_CfgNetBufferSizeOptType)(pMsgContext->resMaxDataLen - remainingData);
  Dcm_DiagMoveOnResWithLengthAll(pMsgContext, remainingData);                                                                                        /* PRQA S 3109 */ /* MD_MSR_14.3 */

  if(lStdResult != DCM_E_PENDING)
  {
    if(lStdResult == DCM_E_BUFFERTOOLOW)/* buffer too low OR all data reported - finish processing */
    {
      Dcm_SetNegResponse(DCM_E_RESPONSETOOLONG);
    }
    lStdResult = DCM_E_PROCESSINGDONE;
  }
  return lStdResult;
}
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_CNT_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiPutNumFilteredDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiPutNumFilteredDtc(Dcm_OpStatusType opStatus
                                                                      ,Dcm_MsgContextPtrType pMsgContext)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  pMsgContext->resData[0] = Dcm_UtiGetHiByte(Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.NumDtc);
  pMsgContext->resData[1] = Dcm_UtiGetLoByte(Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.NumDtc);

  return DCM_E_PROCESSINGDONE;
}
# endif

# if (DCM_DEMAPI_SVC_19_GETNUMFILTEREDDTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetNumFltrdDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetNumFltrdDtc(Dcm_OpStatusType opStatus
                                                                      ,Dcm_MsgContextPtrType pMsgContext)                                            /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  Dem_ReturnGetNumberOfFilteredDTCType demResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  demResult = Dcm_DemAPI(GetNumberOfFilteredDTC)(&Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.NumDtc);
  switch(demResult)
  {
  case DEM_NUMBER_OK:
    lStdResult = Dcm_Svc19UtiChainNext();/* next item */
    break;
  case DEM_NUMBER_PENDING:
    lStdResult = DCM_E_PENDING;
    break;
  default:/* DEM_NUMBER_FAILED or unknown */
    Dcm_DemApiSetNegResponse(demResult, Dcm_DemApiNrcMapGetNumberOfFilteredDTC);
    lStdResult = DCM_E_PROCESSINGDONE;
    break;
  }
  return lStdResult;
}
# endif

# if (DCM_DEMAPI_SVC_19_GETSEVERITYOFDTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetSeverityOfDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetSeverityOfDtc(Dcm_OpStatusType opStatus
                                                                        ,Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType lStdResult;
  Dem_ReturnGetSeverityOfDTCType demResultSeverity;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  demResultSeverity = Dcm_DemAPI(GetSeverityOfDTC)(Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.Dtc
                                                   ,pMsgContext->resData);

  switch(demResultSeverity)
  {
  case DEM_GET_SEVERITYOFDTC_NOSEVERITY:
    pMsgContext->resData[0] = 0; /* set to NO SEVERITY as specified in ISO14229-1 and go on with the remained part */
    /* fall through */
  case DEM_GET_SEVERITYOFDTC_OK:                                                                                                                     /* PRQA S 2003 */ /* MD_Dcm_Optimize_2003 */
    {
      Dem_ReturnGetFunctionalUnitOfDTCType demResultFuncUnit;

      demResultFuncUnit = Dcm_DemAPI(GetFunctionalUnitOfDTC)(Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.Dtc
                                                             ,&pMsgContext->resData[1]);
      if(demResultFuncUnit == DEM_GET_FUNCTIONALUNITOFDTC_OK)
      {
        Dcm_DiagMoveOnResWithLengthAll(pMsgContext, 2u);                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
        lStdResult = Dcm_Svc19UtiChainNext();/* next step */
      }
      else
      {
        Dcm_DemApiSetNegResponse(demResultFuncUnit, Dcm_Svc19NrcMapGetFunctionalUnitOfDTC);
        lStdResult = DCM_E_PROCESSINGDONE;
      }
    }
    break;
  case DEM_GET_SEVERITYOFDTC_PENDING:
    lStdResult =  DCM_E_PENDING;
    break;
  default:
    Dcm_DemApiSetNegResponse(demResultSeverity, Dcm_Svc19NrcMapGetSeverityOfDTC);
    lStdResult = DCM_E_PROCESSINGDONE;
    break;
  }
  return lStdResult;
}
# endif

# if (DCM_DEMAPI_SVC_19_GETSTATUSOFDTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetStatusOfDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetStatusOfDtc(Dcm_OpStatusType opStatus
                                                                      ,Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType lStdResult;
  Dem_ReturnGetStatusOfDTCType demResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  demResult = Dcm_DemAPI(GetStatusOfDTC)(Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.Dtc
                                        ,Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.Origin
                                        ,&pMsgContext->resData[3]);
  switch(demResult)
  {
  case DEM_STATUS_OK:
    pMsgContext->resData[0] = Dcm_UtiGetHiLoByte(Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.Dtc);
    pMsgContext->resData[1] = Dcm_UtiGetLoHiByte(Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.Dtc);
    pMsgContext->resData[2] = Dcm_UtiGetLoLoByte(Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.Dtc);
    Dcm_ExtSvc19UtiPatchDtcStatusApplyByResult(&pMsgContext->resData[3]);                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */

    Dcm_DiagMoveOnResWithLengthAll(pMsgContext, 4u);/* commit written byte */                                                                        /* PRQA S 3109 */ /* MD_MSR_14.3 */
    lStdResult = Dcm_Svc19UtiChainNext();/* next item */
    break;
  case DEM_STATUS_PENDING:
    lStdResult = DCM_E_PENDING;
    break;
  default:
    Dcm_DemApiSetNegResponse(demResult, Dcm_Svc19NrcMapGetStatusOfDTC);
    lStdResult = DCM_E_PROCESSINGDONE;
    break;
  }
  return lStdResult;
}
# endif

# if (DCM_DEMAPI_SVC_19_GETSIZEOFEXTRECORD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetSizeOfExtRecord()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetSizeOfExtRecord(Dcm_OpStatusType opStatus
                                                                          ,Dcm_MsgContextPtrType pMsgContext)                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdReturn;
  Dcm_DemReturnGetSizeOfEDRByDTCType demResult;
  uint16 dataLen;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  demResult = Dcm_DemAPI(GetSizeOfExtendedDataRecordByDTC)(Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.Dtc
                                                          ,Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.Origin
                                                          ,Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNum
                                                          ,&dataLen);
  switch(demResult)
  {
  case DCM_DEM_RET_SIZEOFEDR_OK:
    if(dataLen != 0u) /* consider only stored records */
    {
      if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNumList != NULL_PTR)
      {
        Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNum = Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNumList[0];/* take first one */
        Dcm_DebugAssert((DCM_SVC_19_RECNUM_ALL != Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNum), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE) /* COV_DCM_RTM_DEV_DEBUG XF */
      }
#  if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_ON)
#   if (DCM_DEM_API_403_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
      else
      {
        ++dataLen; /* DEM considers the RecordNumberByte in case of ALL RECs, in single RecordNum -> add manually */
      }
#   endif
      Dcm_PagedBufferStart(Dcm_Svc19UtiCpyDemGetExtRecord, NULL_PTR, dataLen);/* Starting extended data copy */
      lStdReturn = DCM_E_OK; /* Let the page-buffer do the job */
#  else
      Dcm_Svc19UtiStartLinearCopy(Dcm_Svc19UtiCpyDemGetExtRecord);/* the response length will be calculated on the fly */
      lStdReturn = DCM_E_LOOP; /* Let the page-buffer do the job */
#  endif
    }
    else
    {/* else - nothing stored - send positive response */
      lStdReturn = DCM_E_PROCESSINGDONE;
    }
    break;
  case DCM_DEM_RET_SIZEOFEDR_PENDING:
    lStdReturn = DCM_E_PENDING;
    break;
  default:
    Dcm_DemApiSetNegResponse(demResult, Dcm_Svc19NrcMapGetSizeOfExtendedDataRecordByDTC);
    lStdReturn = DCM_E_PROCESSINGDONE;
    break;
  }
  return lStdReturn;
}
# endif

# if (DCM_DEMAPI_SVC_19_GETSIZEOFFFRECORD_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemGetSizeOfFFRecord()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemGetSizeOfFFRecord(Dcm_OpStatusType opStatus
                                                                         ,Dcm_MsgContextPtrType pMsgContext)                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  Dcm_DemReturnGetSizeOfFFRByDTCType demResult;
  uint16 dataLen;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  demResult = Dcm_DemAPI(GetSizeOfFreezeFrameByDTC)(Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.Dtc
                                                    ,Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.Origin
                                                    ,Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNum
                                                    ,&dataLen);
  switch(demResult)
  {
  case DCM_DEM_RET_SIZEOFFFR_OK:
    if(dataLen != 0u) /* consider only stored records */
    {
      if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNumList != NULL_PTR)
      {
        Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNum = Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNumList[0];/* take first one */
        Dcm_DebugAssert((DCM_SVC_19_RECNUM_ALL != Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNum), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE) /* COV_DCM_RTM_DEV_DEBUG XF */
      }
#  if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_ON)
      Dcm_PagedBufferStart(Dcm_Svc19UtiCpyDemGetFFRecord, NULL_PTR, dataLen);/* Starting extended data copy */
      lStdResult = DCM_E_OK; /* Let the page-buffer do the job */
#  else
      Dcm_Svc19UtiStartLinearCopy(Dcm_Svc19UtiCpyDemGetFFRecord);/* the response length will be calculated on the fly */
      lStdResult = DCM_E_LOOP;
#  endif
    }
    else/* else - nothing stored - send positive response */
    {
      lStdResult = DCM_E_PROCESSINGDONE;
    }
    break;
  case DCM_DEM_RET_SIZEOFFFR_PENDING:
    lStdResult = DCM_E_PENDING;
    break;
  default:
    Dcm_DemApiSetNegResponse(demResult, Dcm_Svc19NrcMapGetSizeOfFreezeFrameByDTC);
    lStdResult = DCM_E_PROCESSINGDONE;
    break;
  }
  return lStdResult;
}
# endif

# if (DCM_DEMAPI_SVC_19_ANYABLERECORDUPDATE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiDemDisableRecordUpdate()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiDemDisableRecordUpdate(Dcm_OpStatusType opStatus
                                                                           ,Dcm_MsgContextPtrType pMsgContext)                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  Dem_ReturnDisableDTCRecordUpdateType demResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  demResult = Dcm_DemAPI(DisableDTCRecordUpdate)(Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.Dtc
                                                ,Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.Origin);
  switch(demResult)
  {
  case DEM_DISABLE_DTCRECUP_OK:
    lStdResult = Dcm_Svc19UtiChainNext();/* next item */
    break;
  case DEM_DISABLE_DTCRECUP_PENDING:
    lStdResult = DCM_E_PENDING;
    break;
  default:
    Dcm_DemApiSetNegResponse(demResult, Dcm_Svc19NrcMapAnyAbleRecordUpdate);
    lStdResult = DCM_E_PROCESSINGDONE;
    break;
  }
  return lStdResult;
}
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportDtcByStatusMaskData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportDtcByStatusMaskData(Dcm_Svc19DemSetFilterClassType dsfClass
                                                                          ,Dcm_Svc19DemSetFilterMaskUsageType maskUsage
                                                                          ,Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType                    stdResult;
  uint8                             dtcStatusMask;

  dtcStatusMask = pMsgContext->reqData[0];/* save the requested mask */

  stdResult = Dcm_DemAPI(GetDTCStatusAvailabilityMask)(pMsgContext->resData);  /* Copy the status availability mask (in any case) */

  Dcm_DiagUpdateResLengthAll(pMsgContext, 1u);                                                                                                       /* PRQA S 3109 */ /* MD_MSR_14.3 */

  if(stdResult == E_OK)
  {
    Dem_ReturnSetFilterType  demResultSetFilter;

    if(maskUsage == DCM_SVC_19_USE_MASK_REQ)
    {
      Dcm_ExtSvc19UtiPatchDtcStatusSetForFilter(&dtcStatusMask);                                                                                     /* PRQA S 3109 */ /* MD_MSR_14.3 */
      dtcStatusMask &= pMsgContext->resData[0];      /* Form the relevant status bits */

      if(dtcStatusMask == 0u)
      {
        return DCM_E_PROCESSINGDONE;/* no DTCs to report */
      }/* else - filter the DTCs */
    }
    else
    {
      dtcStatusMask = 0u; /* all DTCs to be filtered */
    }

    demResultSetFilter = Dcm_DemAPI(SetDTCFilter)(dtcStatusMask
                                                  ,Dcm_Svc19DemDtcFilterInfo[dsfClass].Kind
                                                  ,DEM_DTC_FORMAT_UDS
                                                  ,Dcm_Svc19DemDtcFilterInfo[dsfClass].Origin
                                                  ,DEM_FILTER_WITH_SEVERITY_NO
                                                  ,0 /* parameter not used */
                                                  ,DEM_FILTER_FOR_FDC_NO);
    if(demResultSetFilter == DEM_FILTER_ACCEPTED)
    {
      Dcm_UtiNextItemByPtr(pMsgContext->resData, 1u); /* skip SAM */
      return Dcm_Svc19UtiChainStart(Dcm_Svc19DemChainReadDtcByStatus);
    }/* else - error case - send NRC */
    Dcm_DemApiSetNegResponse(demResultSetFilter, Dcm_DemApiNrcMapSetDTCFilter);
  }
  else
  {
    Dcm_DemApiSetNegResponse(stdResult, Dcm_Svc19NrcMapStdReturnType);
  }
  return DCM_E_PROCESSINGDONE;
}                                                                                                                                                    /* PRQA S 2006 */ /* MD_Dcm_Optimize_2006 */
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_CNT_BY_STATUS_MASK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportNumDtcByStatusMaskData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportNumDtcByStatusMaskData(
                                                                                Dcm_Svc19DemSetFilterClassType dsfClass
                                                                               ,uint8 dtcStatusMask
                                                                               ,Dem_DTCSeverityType dtcSeverity
                                                                               ,Dcm_MsgContextPtrType pMsgContext)
{
  Dem_ReturnSetFilterType           demResultSetFilter;
  Std_ReturnType                    stdResult;

  stdResult = Dcm_DemAPI(GetDTCStatusAvailabilityMask)(pMsgContext->resData);  /* Copy the status availability mask (in any case) */

  if(stdResult == E_OK)
  {
    Dcm_ExtSvc19UtiPatchDtcStatusSetForFilter(&dtcStatusMask);                                                                                       /* PRQA S 3109 */ /* MD_MSR_14.3 */
    dtcStatusMask &= pMsgContext->resData[0];    /* Form the relevant status bits */
    pMsgContext->resData[1] = Dcm_DemAPI(GetTranslationType)();    /* evaluate the DTCFormatIdentifier */
    Dcm_UtiNextItemByPtr(pMsgContext->resData, 2u);/* move toward numDtc response parameter */

    Dcm_DiagUpdateResLengthAll(pMsgContext, 4u);  /* prepare for positive case */                                                                    /* PRQA S 3109 */ /* MD_MSR_14.3 */

    if(dtcStatusMask != 0)
    {
      demResultSetFilter = Dcm_DemAPI(SetDTCFilter)(dtcStatusMask
                                                    ,Dcm_Svc19DemDtcFilterInfo[dsfClass].Kind
                                                    ,DEM_DTC_FORMAT_UDS
                                                    ,Dcm_Svc19DemDtcFilterInfo[dsfClass].Origin
                                                    ,Dcm_Svc19DemDtcFilterInfo[dsfClass].ConsiderSeverity
                                                    ,dtcSeverity
                                                    ,DEM_FILTER_FOR_FDC_NO);
      if(demResultSetFilter == DEM_FILTER_ACCEPTED)
      {
        return Dcm_Svc19UtiChainStart(Dcm_Svc19DemChainDtcCount);
      }/* else - error case - send NRC */
      Dcm_DemApiSetNegResponse(demResultSetFilter, Dcm_DemApiNrcMapSetDTCFilter);
    }
    else
    {
      pMsgContext->resData[0] = 0u;
      pMsgContext->resData[1] = 0u;
    }
  }
  else
  {
    Dcm_DemApiSetNegResponse(stdResult, Dcm_Svc19NrcMapStdReturnType);
  }

  return DCM_E_PROCESSINGDONE;
}                                                                                                                                                    /* PRQA S 2006 */ /* MD_Dcm_Optimize_2006 */
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_EXT_DATA_BY_DTC_NUM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportExtDataRecordByDtcNum()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportExtDataRecordByDtcNum(Dem_DTCOriginType dtcOrigin
                                                                                ,Dcm_MsgContextPtrType pMsgContext)                                  /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.Origin     = dtcOrigin;
  Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.Dtc        = Dcm_UtiMake32Bit(0x00u
                                                                                   ,pMsgContext->reqData[0]
                                                                                   ,pMsgContext->reqData[1]
                                                                                   ,pMsgContext->reqData[2]);
  Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNum  = pMsgContext->reqData[3];

  if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNum == DCM_SVC_19_RECNUM_ALL)
  {
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNumList = Dcm_Svc19ExtDataRecords;
  }
  else if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNum == DCM_SVC_19_RECNUM_OBD_ALL)
  {
#  if (DCM_SVC_19_OBD_EXT_RECORD_ENABLED == STD_ON)                                                                                                  /* COV_DCM_UNSUPPORTED XF */
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNumList = Dcm_Svc19ExtDataRecordsObd;
#  else
    Dcm_SetNegResponse(DCM_E_REQUESTOUTOFRANGE); /* the ECU does not support any OBD extended data records - reject request */
    return DCM_E_PROCESSINGDONE;
#  endif
  }
  else
  {
    /* Single record */
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNumList = NULL_PTR;
  }
  return Dcm_Svc19UtiChainStart(Dcm_Svc19DemChainReadExtRecords);
}                                                                                                                                                    /* PRQA S 2006 */ /* MD_Dcm_Optimize_2006 */
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_BY_OCCUR_TIME_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportNumDtcByOccurenceTime()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportNumDtcByOccurenceTime(Dem_DTCRequestType dtcReqType
                                                                                ,Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType                    stdResult;

  stdResult = Dcm_DemAPI(GetDTCStatusAvailabilityMask)(pMsgContext->resData);  /* Copy the status availability mask (in any case) */
  Dcm_DiagMoveOnResWithLength(pMsgContext, 1u); /* commit written data */                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */

  if(stdResult == E_OK)
  {
    Dem_ReturnGetDTCByOccurrenceTimeType  demResult;

    demResult = Dcm_DemAPI(GetDTCByOccurrenceTime)(dtcReqType
                                                   ,&Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.Dtc);
    if(demResult == DEM_OCCURR_OK)
    {
      Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.Origin = DEM_DTC_ORIGIN_PRIMARY_MEMORY;
      return Dcm_Svc19UtiChainStart(Dcm_Svc19DemChainGetDtcStatusEnd); /* first freeze the DTC record state */
    }/* else - no DTC has occurrence information - return empty positive response */
    Dcm_DemApiSetNegResponse(demResult, Dcm_Svc19NrcMapGetDTCByOccurrenceTime);
  }
  else
  {
    Dcm_DemApiSetNegResponse(stdResult, Dcm_Svc19NrcMapStdReturnType);
  }
  return DCM_E_PROCESSINGDONE;
}                                                                                                                                                    /* PRQA S 2006 */ /* MD_Dcm_Optimize_2006 */
# endif

# if (DCM_DEMAPI_SVC_19_READ_DTC_FFR_BY_DTC_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc19UtiReportDtcFFRByDtc()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc19UtiReportDtcFFRByDtc(Dem_DTCOriginType dtcOrigin
                                                                      ,Dcm_MsgContextPtrType pMsgContext)                                            /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.Origin     = dtcOrigin;
  Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.Dtc        = Dcm_UtiMake32Bit(0x00u
                                                                                   ,pMsgContext->reqData[0]
                                                                                   ,pMsgContext->reqData[1]
                                                                                   ,pMsgContext->reqData[2]);
  Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNum  = pMsgContext->reqData[3];

  if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNum == DCM_SVC_19_RECNUM_ALL)
  {
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNumList = Dcm_Svc19FFDataRecords;
  }
  else
  {
    /* Single record */
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNumList = NULL_PTR;
  }
  return Dcm_Svc19UtiChainStart(Dcm_Svc19DemChainReadFFRByDtc);
}
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_22_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_DIDMGR_OPTYPE_READ_CHECKCOND_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc22CheckCondition()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22CheckCondition(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext)                                                  /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_DIDMGR_OPTYPE_READ_CHECKCOND_ALL_ENABLED == STD_OFF)
  if(Dcm_DidMgrIsOpTypeSupported(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidInfoContextPtr->Descriptor.DidOpInfoPtr, DCM_DIDMGR_OPTYPE_READCHKCOND))
#  endif
  {
    Std_ReturnType               lStdResult;
    Dcm_NegativeResponseCodeType lNrc;

    Dcm_DidMgrGetOpClassInfo(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidInfoContextPtr, DCM_DIDMGR_OPTYPE_READCHKCOND);

    /* check condition */
    lStdResult = Dcm_DidMgrReadCheckCond(opStatus
                                        ,Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidInfoContextPtr
                                        ,&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidOpTypeContext)
                                        ,&lNrc);
    if(lStdResult == DCM_E_OK)
    {
      /* DCM_E_OK - go on with next DID */
    }
    else
#  if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
    if(lStdResult == DCM_E_PENDING)
    {
      return DCM_E_PENDING;
    }
    else
#  endif
    {
      /* DCM_E_NOT_OK */
      Dcm_SetNegResponse(lNrc);
      return DCM_E_PROCESSINGDONE; /* finish service processing immediately */
    }
  }/* else - not supported operation - go on with getLength */
  Dcm_RepeaterSetCallee(Dcm_Svc22GetLength); /* next job */
  return DCM_E_LOOP;
}                                                                                                                                                    /* PRQA S 2006 */ /* MD_Dcm_Optimize_2006 */
# endif

/**********************************************************************************************************************
 *  Dcm_Svc22GetLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22GetLength(Dcm_OpStatusType opStatus
                                                           ,Dcm_MsgContextPtrType pMsgContext)                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdReturn;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_DIDMGR_OPTYPE_READ_LENGTH_ENABLED == STD_ON)
  /* read length */
  {
    Dcm_NegativeResponseCodeType lNrc;

    lStdReturn = Dcm_DidMgrReadLength(opStatus
                                     ,Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidInfoContextPtr
                                     ,&lNrc);

    if(lStdReturn == DCM_E_NOT_OK)
    {
      Dcm_SetNegResponse(lNrc);/* default value if nothing set in the application */
      lStdReturn = DCM_E_PROCESSINGDONE; /* finish service processing immediately */
    }/* else - DCM_E_PENDING, DCM_E_OK */
  }/* else - static length */

  if(lStdReturn == DCM_E_OK)
# endif
  {
    /* DCM_E_OK - go on with next DID */
    /* On DID ranges, the maximum configured theoretical length will be used as a final length! This is because the concrete length is first acquired with the ReadDidData service call. */
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.TotalLength += Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidInfoContextPtr->DidLength;
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.TotalLength += 2; /* cumulate DID length + DID itself */

    /* check for buffer overrun */
# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
    /* Note: '<' because MaxLength includes the SID. */
    if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.TotalLength < Dcm_NetGetProtObjOfTranspObj(Dcm_DiagGetTranspObj())->MaxLength)
# else
    /* Note: '<=' because resMaxDataLen excludes the SID. */
    if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.TotalLength <= pMsgContext->resMaxDataLen)
# endif
    {
      --Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidIter;
      if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidIter == 0)
      {
        /* All DIDs processed without any errors. Prepare for reading */
        /* Now Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.NumDids will be used as counter -> didIter not needed any more!
         *Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidIter = Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.NumDids;
         */
        Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidInfoContextPtr = &(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidInfoContextList[0]);

# if (DCM_DIDMGR_22_ACCESS_LOCK_ENABLED == STD_ON)
        Dcm_RepeaterSetCallee(Dcm_Svc22CheckAccess); /* delegate job */
# else
        Dcm_RepeaterSetCallee(Dcm_Svc22ReadData); /* delegate job */
# endif
      }
      else
      {
        Dcm_UtiNextItemByPtr(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidInfoContextPtr, 1u);/* next DID */
# if (DCM_DIDMGR_OPTYPE_READ_CHECKCOND_ENABLED == STD_ON)
        Dcm_RepeaterSetCallee(Dcm_Svc22CheckCondition); /* start again with next DID  */
# else
        /* already added */
# endif
      }
      lStdReturn = DCM_E_LOOP;/* speed up processing */
    }
    else
    {
      Dcm_SetNegResponse(DCM_E_RESPONSETOOLONG);/* the configured buffer will not be able to hold all of the data -> notify the client */
      lStdReturn = DCM_E_PROCESSINGDONE; /* finish service processing immediately */
    }
  }/* else - DCM_E_PENDING, DCM_E_PROCESSINGDONE */

  return lStdReturn;
}

# if (DCM_DIDMGR_22_ACCESS_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc22CheckAccess()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22CheckAccess(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext)                                                     /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lResult = DCM_E_LOOP;
  boolean lIsAccessible;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lIsAccessible =  Dcm_Svc22IsDidAccessible(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidInfoContextPtr);

 /* #10 If the DID isn't currently in use by another service: */
  if(lIsAccessible == TRUE)
  {
    /* #20 Reserve the DID for service 0x22 and read it out. */
    Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadOnce = Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidInfoContextPtr->Did;

    Dcm_RepeaterSetCallee(Dcm_Svc22ReadData);
  }
  else
  {
    /* #30 Otherwise try it later. */
    lResult = DCM_E_PENDING;
  }

  return lResult;/* speed up processing */
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc22ReadData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22ReadData(Dcm_OpStatusType opStatus
                                                          ,Dcm_MsgContextPtrType pMsgContext)                                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_DebugAssert((pMsgContext->resDataLen == 0), DCM_SID_INTERNAL, DCM_E_PARAM)                                                                     /* COV_DCM_RTM_DEV_DEBUG XF */

  Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.OpStatus     = DCM_INITIAL;
  Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.ReadProgress = 0u;

  /* #20 Start the paged buffer to copy the DID data. */
  Dcm_PagedBufferStart(Dcm_Svc22CopyPagedData
                      ,Dcm_Svc22CopyCancellation
                      ,Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.TotalLength);
  return DCM_E_OK;
# else
  /* #30 Otherwise copy the DID data using the linear buffer. */
  return Dcm_Svc22CopyLinearData(opStatus, pMsgContext);
# endif
}

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc22CopyPagedData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22CopyPagedData(Dcm_MsgType pData
                                                               ,Dcm_CfgNetBufferSizePtrType pAvailLen)
{
  Std_ReturnType                lResult;
  Dcm_CfgNetBufferSizeOptType   lAvailLen;
  DCM_UTIRTLMTR_CTR_DEF
  DCM_UTIRTLMTR_CTR_INIT

  /*
   *  Action/Return value | DCM_E_PENDING | DCM_E_BUFFERTOOLOW | DCM_E_OK
   * ---------------------+---------------+--------------------+----------
   *  call again          |      yes      |        yes         |   no
   *  data commited       |      no       |        yes         |   yes
   *  ready               |      no       |        no          |   yes
   */

  /* #10 For each requested DID. */
  do
  {
    /* #20 Calculate the remaining available length. */
    lAvailLen = (Dcm_CfgNetBufferSizeOptType)(*pAvailLen - Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.ReadProgress);

    lResult = DCM_E_OK;

    if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.OpStatus == DCM_INITIAL)
    {
      /* #30 Prepare for reading. */
      lResult = Dcm_Svc22CopyPagedDataInit(pData, pAvailLen, &lAvailLen);
    }

    if(lResult == DCM_E_OK)
    {
      lResult = Dcm_Svc22ReadDidPaged(pData, pAvailLen, &lAvailLen);

      /* #40 If all DIDs were read without any errors: */
      if(lResult == DCM_E_OK)
      {
        --Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.NumDids;
        if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.NumDids == 0)
        {

          /* Commit data */
          *pAvailLen -= Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.ReadProgress;

          /* #50 Finalize reading. */
          break; /* return DCM_E_OK */
        }

        /* #60 Otherwise take next DID. */
        Dcm_UtiNextItemByPtr(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidInfoContextPtr, 1u);

        DCM_UTIRTLMTR_CTR_NEXT
        DCM_UTIRTLMTR_CTR_HANDLE_NO_BREAK(lResult, DCM_E_PENDING)
      }
    }
  }
  while(lResult == DCM_E_OK);

  return lResult;
}
# endif /* (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON) */

# if (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc22CopyCancellation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc22CopyCancellation(void)
{
  /* #10 If any read operation has to be cancelled: */
  if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.OpStatus != DCM_INITIAL)
  {
    Dcm_MsgItemType               lData = 0u;
    Dcm_CfgNetBufferSizeOptType   lAvailLen = 0u; /* no data expected */
    Dcm_NegativeResponseCodeType  lNrc;

    /* #20 Notify the application about the cancellation. */
    (void)Dcm_DidMgrRead(DCM_CANCEL
                        ,&lData
                        ,&lAvailLen
                        ,Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidInfoContextPtr
                        ,&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidOpTypeContext)
                        ,&lNrc);
  }

#  if (DCM_DIDMGR_CANCEL_OP_ENABLED == STD_ON)
  /* #30 Cancel the ongoing DID operation. */
  Dcm_DidMgrCancelOperation();
#  endif
}
# endif /* (DCM_DIDMGR_OPCLS_READ_PAGED_ENABLED == STD_ON) */

/**********************************************************************************************************************
 *  Dcm_Svc22DidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc22DidLookUp(Dcm_OpStatusType opStatus, Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType lStdReturn;
  boolean doProcessDid = TRUE;

  if(opStatus == DCM_INITIAL)
  {
    /* If still at least one DID to be processed: */
    if(pMsgContext->reqDataLen != 0u)
    {
      Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidInfoContextPtr->Did = Dcm_UtiMake16Bit(pMsgContext->reqData[0], pMsgContext->reqData[1]);
      /* Prepare for next DID */
      Dcm_DiagMoveOnReqWithLength(pMsgContext, 2u);                                                                                                  /* PRQA S 3109 */ /* MD_MSR_14.3 */
    }
    else
    {
      doProcessDid = FALSE;
    }
  }

  if(doProcessDid == TRUE)
  {
    lStdReturn = Dcm_DidMgrGetDidInfo(opStatus
                                     ,Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidInfoContextPtr
                                     ,&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidOpTypeContext)
                                     ,DCM_DIDMGR_OP_READ);
    if(lStdReturn == DCM_E_OK)
    {
      Dcm_NegativeResponseCodeType  lNrc;
      ++Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.NumDids; /* register a supported DID */

      lNrc = Dcm_DidMgrDynDidStateCheck(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidInfoContextPtr);
      if(lNrc == DCM_E_POSITIVERESPONSE)
      {
        Dcm_UtiNextItemByPtr(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidInfoContextPtr, 1u);/* next info storage */
        lStdReturn = DCM_E_LOOP; /* proceed with next DID */
      }
      else
      {
        Dcm_SetNegResponse(lNrc); /* lNrc already assigned */
        lStdReturn = DCM_E_PROCESSINGDONE;
      }
    }
    else if(lStdReturn == DCM_E_PENDING)
    {
      /* already set */
    }
    else
    {
      /* Just skip this DID - DCM_E_NOT_OK - request a new look-up loop */
      lStdReturn = DCM_E_LOOP;
    }
  }
  else
  {
    /* empty run loop ended without any DID to be processed (for this activation of the repeater proxy)*/
    /* all DIDs processed */
    if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.NumDids != 0u)/* any DID to process? */
    {
      Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidIter = Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.NumDids;
      Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidInfoContextPtr = &(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidInfoContextList[0]);/* start over the list */

# if (DCM_DIDMGR_OPTYPE_READ_CHECKCOND_ENABLED == STD_ON)
      Dcm_RepeaterSetCallee(Dcm_Svc22CheckCondition); /* delegate job */
# else
      Dcm_RepeaterSetCallee(Dcm_Svc22GetLength); /* delegate job */
# endif
      lStdReturn = DCM_E_LOOP;/* speed up processing */
    }
    else
    {
      Dcm_SetNegResponse(DCM_E_REQUESTOUTOFRANGE);
      lStdReturn = DCM_E_PROCESSINGDONE;
    }
  }

  return lStdReturn;
}
#endif /* (DCM_SVC_22_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_23_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc23CheckAccess()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc23CheckAccess(Dcm_OpStatusType opStatus
                                                          ,Dcm_MsgContextPtrType pMsgContext)                                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if(Dcm_InstanceContext.MemMgr.LockedByClient != DCM_MEMMGR_ACCESS_NONE)
  {
    lStdResult = DCM_E_PENDING;
  }
  else
  {
    Dcm_InstanceContext.MemMgr.LockedByClient = DCM_MEMMGR_ACCESS_REQ_EXT;
    Dcm_RepeaterSetCallee(Dcm_Svc23ReadMemory); /* delegate job */
    lStdResult = DCM_E_LOOP;/* speed up processing */
  }
  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc23ReadMemory()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc23ReadMemory(Dcm_OpStatusType opStatus
                                                            ,Dcm_MsgContextPtrType pMsgContext)                                                      /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  Dcm_NegativeResponseCodeType lNrc;

  lNrc = DCM_E_GENERALREJECT;

  lStdResult = Dcm_MemMgrReadMemory(opStatus
                                   ,&Dcm_InstanceContext.Repeater.Contexts.Context.Svc23.MemBlock
                                   ,pMsgContext->resData
                                   ,&lNrc);

  switch(lStdResult)
  {
  case DCM_E_NOT_OK:
    Dcm_SetNegResponse(lNrc); /* RFC 57196 */
    /* fall through */
  case DCM_E_OK:                                                                                                                                     /* PRQA S 2003 */ /* MD_Dcm_Optimize_2003 */
    lStdResult = DCM_E_PROCESSINGDONE;
    break;
  default:
    /*  any other result to be delegated to the core
     *  No DET monitoring needed since the Dcm_MemMgrReadMemory has already one!
     */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_23_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_24_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc24ExecuteOp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc24ExecuteOp(Dcm_OpStatusType opStatus, Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType               lStdResult;
  Dcm_NegativeResponseCodeType lNrc;

  lStdResult = Dcm_DidMgrGetScalingInfo(opStatus
                                      ,pMsgContext
                                      ,&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc24.DidInfoContext)
                                      ,&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc24.DidOpTypeContext)
                                      ,&lNrc);

# if (DCM_DIDMGR_ASYNC_SCALINGDID_SUPPORT_ENABLED == STD_ON)
  if(lStdResult == DCM_E_PENDING)
  {
    /* return DCM_E_PENDING */
  }
  else
# endif
  {
    if(lStdResult != DCM_E_OK)
    {
      Dcm_SetNegResponse(lNrc);/* default value if nothing set in the application */
    }
    lStdResult = DCM_E_PROCESSINGDONE;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc24DidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc24DidLookUp(Dcm_OpStatusType opStatus, Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType lStdReturn;

  lStdReturn = Dcm_DidMgrGetDidInfo(opStatus
                                   ,&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc24.DidInfoContext)
                                   ,&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc24.DidOpTypeContext)
                                   ,DCM_DIDMGR_OP_SCALINGINFO);
  if(lStdReturn == DCM_E_OK)
  {
    /* Currently no state checks are possible on scaling DIDs in AR 4.x */
    /*
    lNrc = Dcm_DidMgrStaticDidStateCheck(Dcm_InstanceContext.Repeater.Contexts.Context.Svc24.DidInfoContext.Descriptor.DidOpInfoPtr->ExecCondRef);
    if(lNrc == DCM_E_POSITIVERESPONSE)
    */
    {
      Dcm_UtiNextItemByPtr(pMsgContext->resData, 2u);     /* skip the DID in the response */
      pMsgContext->resDataLen = 2u;/* commit the DID only. The scaling record size will be calculated on the fly. */

      Dcm_DidMgrGetOpClassInfo(&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc24.DidInfoContext), DCM_DIDMGR_OPTYPE_GETSCALING);
      Dcm_RepeaterSetCallee(Dcm_Svc24ExecuteOp); /* delegate job */
      lStdReturn = DCM_E_LOOP;/* speed up processing */
    }/* else - lNrc already assigned */
  }
  else if(lStdReturn == DCM_E_PENDING)
  {
    /* DID verification takes longer -> retry later */
  }
  else
  {
    lStdReturn = DCM_E_PROCESSINGDONE;
    /* DID is not supported -> send NRC 0x31. */
    Dcm_SetNegResponse(DCM_E_REQUESTOUTOFRANGE);
  }

  return lStdReturn; /* finish service processing immediately */
}
#endif /* (DCM_SVC_24_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_TSK_NUM_SVC27 > 0)
/**********************************************************************************************************************
 *  Dcm_Svc27Task()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc27Task(Dcm_TskTaskEvOptType ev
                                            ,Dcm_TskTaskEvPtrType pPostEv)                                                                           /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  /* #10 If the attempt counters should be restored: */
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_SVC_27_ATTEMPT_CNTR_READ))
  {
    /* #20 Process attempt counter reading */
    (void)Dcm_Svc27ReadAttemptCounter(ev, pPostEv);
  }

  /* #30 If the attempt counters should be stored: */
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_SVC_27_ATTEMPT_CNTR_WRITE))
  {
    /* #40 Process attempt counter writing */
    (void)Dcm_Svc27WriteAttemptCounter(ev, pPostEv);
  }
}
# endif

# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutSecurityAccess_0()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutSecurityAccess_0(void)
{
  Dcm_TmrTimerCntrMemType lReloadTick = 0u;

  /* #10 If multiple delay timers are activated: */
#  if(DCM_SVC_27_SOFT_TIMER_ENABLED == STD_ON)
  DCM_SVC27_TMR_ITER_DEF

  /* #20 For each software timer: */
  DCM_SVC27_TMR_LOOP_FOR_UP
  {
#   if (DCM_STATE_SEC_DELAY_TIME_ON_FAILED_GET_ATT_CNTR_ENABLED == STD_ON)
    /* #30 If delay time is set to infinity: */
    if(Dcm_Svc27ReloadReadFailedGet(DCM_SVC27_TMR_ITER_VALUE) == TRUE)
    {
      /* #40 Reload forever. */
      Dcm_Svc27TimerStart(DCM_SVC27_TMR_ITER_VALUE);                                                                                                 /* PRQA S 3109 */ /* MD_MSR_14.3 */
      lReloadTick = 1u;
    }
    else
#   endif
    {
      /* #50 Otherwise, if the software timer is not expired: */
      if(!Dcm_Svc27TimerExpired(DCM_SVC27_TMR_ITER_VALUE))
      {
        /* #60 Decrement the timer value. */
        Dcm_Svc27TimerDec(DCM_SVC27_TMR_ITER_VALUE);

        /* #70 If the software timer is still not expired. */
        if(!Dcm_Svc27TimerExpired(DCM_SVC27_TMR_ITER_VALUE))
        {
          /* #80 Reload the hardware timer. */
          lReloadTick = 1u;
        }
#   if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
        else
        {
          /* #90 Otherwise reset the appropriate attempt counter. */

          /*
           * Use timer iterator for counters too since the dimension is always the same.
           * If only single counter used, it will be overwritten multiple times.
           */
          Dcm_Svc27CounterReset(DCM_SVC27_TMR_ITER_VALUE);
          Dcm_InstanceContext.Diag.Services.Svc27.SetAttCntrEventMask |= Dcm_UtiGetBitFromIndex(uint32, DCM_SVC27_TMR_ITER_VALUE);
        }
#   endif
      }
    }
  }
#   if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
  /* #100 If at least one attempt counter was reset. */
  if(Dcm_InstanceContext.Diag.Services.Svc27.SetAttCntrEventMask != 0)
  {
    /* #110 Notify the application about changed attempt counter values. */
    Dcm_TskSetEvent(DCM_TSK_ID_SVC27, DCM_TSK_EV_SVC_27_ATTEMPT_CNTR_WRITE);
  }
#   endif
#  else
  /* #120 Otherwise, if one delay time is set to infinity for at least one security level: */
#   if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
#    if (DCM_STATE_SEC_DELAY_TIME_ON_FAILED_GET_ATT_CNTR_ENABLED == STD_ON)
  if(Dcm_InstanceContext.Diag.Services.Svc27.ReloadMask != 0u)
  {
    /* #130 Reload forever. */
    lReloadTick = 1u;
  }
  else
#    endif
  {
    /* #140 Otherwise reset all counters. */
    DCM_SVC27_CNTR_ITER_DEF

    DCM_SVC27_CNTR_LOOP_FOR_UP
    {
      Dcm_Svc27CounterReset(DCM_SVC27_CNTR_ITER_VALUE);
    }

    /* #150 Notify the application about changed attempt counter values. */
    Dcm_InstanceContext.Diag.Services.Svc27.SetAttCntrEventMask = DCM_SVC_27_LEVEL_MASK;
    Dcm_TskSetEvent(DCM_TSK_ID_SVC27, DCM_TSK_EV_SVC_27_ATTEMPT_CNTR_WRITE);
  }
#   endif
#  endif

  return lReloadTick;
}
# endif

# if (DCM_SVC_27_SEED_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27SeedRepeater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27SeedRepeater(Dcm_OpStatusType opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext)                                                /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType                lResult;
  Dcm_NegativeResponseCodeType  lNrc;

  /* Read the seed of the appropriate security level. */
  if(pMsgContext->reqDataLen != 0u)
  {
    lResult = ((Dcm_Svc27OpFuncSeedWAdr)Dcm_CfgSvc27SecLevelInfo[Dcm_Svc27GetCurReqLev()].GetSeedFunc)(pMsgContext->reqData                          /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                                      ,opStatus
                                                                                                      ,pMsgContext->resData
                                                                                                      ,&lNrc);
  }
  else
  {
    lResult = ((Dcm_Svc27OpFuncSeedWoAdr)Dcm_CfgSvc27SecLevelInfo[Dcm_Svc27GetCurReqLev()].GetSeedFunc)(opStatus                                     /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                                                       ,pMsgContext->resData
                                                                                                       ,&lNrc);
  }

  if(lResult == DCM_E_OK)
  {
    lResult = DCM_E_PROCESSINGDONE;
  }
  else if(lResult == DCM_E_PENDING)
  {
    /* Retry later. */
  }
  else
  {
    if(lResult != DCM_E_NOT_OK)
    {
      lNrc = DCM_E_PANIC_NRC;
      Dcm_DebugApiCheckRteAlways(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)
    }

    Dcm_DiagHandleApplNrc(lResult, &lNrc, DCM_E_CONDITIONSNOTCORRECT);                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */

    Dcm_SetNegResponse(lNrc); /* Default value if nothing set in the application. */
    lResult = DCM_E_PROCESSINGDONE;
  }

  /* Finish service processing immediately. */
  return lResult;
}
# endif

# if (DCM_SVC_27_KEY_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27KeyRepeater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27KeyRepeater(Dcm_OpStatusType opStatus
                                                                 ,Dcm_MsgContextPtrType pMsgContext)                                                 /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType               lResult;
  uint8_least                  lSecLvlIter = Dcm_Svc27GetCurReqLev();
#  if (DCM_DCM_AR_VERSION != DCM_DCM_AR_VERSION_403)
  Dcm_NegativeResponseCodeType lNrc;
#  endif

  /* Let the application compare the given key data. */
  lResult = Dcm_CfgSvc27SecLevelInfo[lSecLvlIter].CompareKeyFunc(pMsgContext->reqData                                                                /* PRQA S 0313 */ /* MD_Dcm_0313 */
                                                                ,opStatus
#  if (DCM_DCM_AR_VERSION != DCM_DCM_AR_VERSION_403)
                                                                ,&lNrc
#  endif
                                                                );

  switch(lResult)
  {
    /*---------------------------*/
    case DCM_E_OK:
    /*---------------------------*/
  /* Reset the attempt counter of this security level. */
      Dcm_Svc27CounterReset(Dcm_Svc27GetCurReqLevAttemptIdx());

#  if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
      /* Notify application about new attempt counter. */
      Dcm_RepeaterSetCallee(Dcm_Service27SetAttemptCntrRepeater);
      lResult = DCM_E_LOOP;
#  else
      lResult = DCM_E_PROCESSINGDONE;
#  endif
      break;
    /*---------------------------*/
    case DCM_E_PENDING:
    /*---------------------------*/
      /* Try later. */
      break;
    /*---------------------------*/
    case DCM_E_COMPARE_KEY_FAILED:
    case DCM_E_NOT_OK:
    /*---------------------------*/
  /* If an error occured set the NRC given by the application. */
#  if (DCM_DCM_AR_VERSION != DCM_DCM_AR_VERSION_403)
      Dcm_DiagHandleApplNrc(lResult, &lNrc, DCM_E_CONDITIONSNOTCORRECT);                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */

      if(lResult == DCM_E_NOT_OK)
      {
        Dcm_SetNegResponse(lNrc);
      }
#  endif

#  if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
      /* Increment the attempt counter. */
      Dcm_Svc27CounterInc(Dcm_Svc27GetCurReqLevAttemptIdx());                                                                                        /* PRQA S 3109 */ /* MD_MSR_14.3 */

      /* Notify application about new attempt counter. */
      Dcm_RepeaterSetCallee(Dcm_Service27CheckAttemptsExceededRepeater);
      lResult = DCM_E_LOOP;
#  else
      /* This NRC will be ignored if compare key function returned DCM_E_NOT_OK and therefore a NRC was already set. */
      Dcm_SetNegResponse(DCM_E_INVALIDKEY);
      lResult = DCM_E_PROCESSINGDONE;
#  endif
      break;
    /*---------------------------*/
    default:
    /*---------------------------*/
      Dcm_DebugApiCheckRteAlways(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)

      Dcm_SetNegResponse(DCM_E_PANIC_NRC);
      lResult = DCM_E_PROCESSINGDONE;
      break;
  }

  return lResult;
}
# endif

# if (DCM_SVC_27_KEY_SUPPORT_ENABLED == STD_ON) && \
     (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27CheckAttemptsExceededRepeater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27CheckAttemptsExceededRepeater(Dcm_OpStatusType opStatus
                                                                                   ,Dcm_MsgContextPtrType pMsgContext)                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType  lResult;
  uint8_least     lSecLvlIter = Dcm_Svc27GetCurReqLev();
#  if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
  uint32          lMask = Dcm_UtiGetBitFromIndex(uint32, lSecLvlIter);
#  endif

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
  /* #10 Notify the application about the new attempt counter value. */
  Dcm_Svc27UtiSetAttemptCntr(opStatus, &lMask);

  /* #20 If the setting of the attempt counter was not successful: */
  if(lMask != 0)
  {
    /* #30 Try it later. */
    lResult = DCM_E_PENDING;
  }
  else /* #40 Otherwise: */
#  endif
  {
    /* #50 If the number of allowed attempt were exceeded: */
    if( (Dcm_CfgStateSecurityInfo[lSecLvlIter].NumAttempts != 0) /* Consider only levels with attempt monitoring. */
      &&(Dcm_Svc27CounterGet(Dcm_Svc27GetCurReqLevAttemptIdx()) >= Dcm_CfgStateSecurityInfo[lSecLvlIter].NumAttempts) )
    {
      /* #60 Set NRC 0x36 and start the timer. */
      /* This NRC will be ignored if compare key function returned DCM_E_NOT_OK and therefore a NRC was already set. */
      Dcm_SetNegResponse(DCM_E_EXCEEDNUMBEROFATTEMPTS);

      Dcm_Svc27TimerSet(Dcm_Svc27GetCurReqLevAttemptIdx(), Dcm_CfgStateSecurityInfo[lSecLvlIter].DelayTimeInvKey);                                   /* PRQA S 3109 */ /* MD_MSR_14.3 */
      Dcm_Svc27TimerStart(Dcm_Svc27GetCurReqLevAttemptIdx());                                                                                        /* PRQA S 3109 */ /* MD_MSR_14.3 */
    }
    else
    {
      /* #70 Otherwise set NRC 0x35. */
      /* This NRC will be ignored if compare key function returned DCM_E_NOT_OK and therefore a NRC was already set. */
      Dcm_SetNegResponse(DCM_E_INVALIDKEY);
    }

    /* Nrc already set. */
    lResult = DCM_E_PROCESSINGDONE;
  }

  return lResult;
}
# endif

# if (DCM_SVC_27_KEY_SUPPORT_ENABLED == STD_ON) && \
     (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON) && \
     (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27SetAttemptCntrRepeater()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Service27SetAttemptCntrRepeater(Dcm_OpStatusType opStatus
                                                                            ,Dcm_MsgContextPtrType pMsgContext)                                      /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType  lResult;
  uint32          lMask = Dcm_UtiGetBitFromIndex(uint32, Dcm_Svc27GetCurReqLev());

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Notify the application about the new attempt counter value. */
  Dcm_Svc27UtiSetAttemptCntr(opStatus, &lMask);

  /* If the setting of the attempt counter was successful: */
  if(lMask == 0)
  {
    /* Finish the job. */
    lResult = DCM_E_PROCESSINGDONE;
  }
  else
  {
    /* Otherwise try it later. */
    lResult = DCM_E_PENDING;
  }

  return lResult;
}
# endif

# if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc27UtiSetAttemptCntr()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc27UtiSetAttemptCntr(Dcm_OpStatusType opStatus
                                                         ,P2VAR(uint32, AUTOMATIC, DCM_VAR_NOINIT) levelMask)
{
  Std_ReturnType  lResult;
  uint8_least     lSecLvlIter = 0u;
  uint32          lMask = *levelMask;

  /* For each security level: */
  DCM_UTI_BIT_SCAN_LOOP(lMask)
  {
    /* If the attempt counter for that specific security level is not already written: */
    if(Dcm_UtiBitOpTest(uint32, lMask, 0x01u))
    {
      /* Notify the application about the new attempt counter value. */
      lResult = Dcm_CfgSvc27SecLevelInfo[lSecLvlIter].SetAttemptCntrFunc(opStatus, Dcm_Svc27CounterGet(lSecLvlIter));

      if (lResult == DCM_E_PENDING)
      {
        /* Otherwise try it later. */
      }
      else
      {
        Dcm_DebugApiCheckRte(((lResult == DCM_E_OK) || (lResult == DCM_E_NOT_OK)), DCM_SID_SETSECURITYATTEMPTCOUNTER, DCM_E_INTERFACE_RETURN_VALUE)
        /*
         * If the attempt counter was written successfully or an error occured, don't try to write the attempt
         * counter again.
         */
        Dcm_SplitTaskEnterCS(); /* Avoid interrupt from Dcm_OnTimeoutSecurityAccess. */                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
        Dcm_UtiBitOpClr(uint32
                       ,*levelMask
                       ,Dcm_UtiGetBitFromIndex(uint32, lSecLvlIter));
        Dcm_SplitTaskLeaveCS();                                                                                                                      /* PRQA S 3109 */ /* MD_MSR_14.3 */
      }
    }
    ++lSecLvlIter;
  }
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc27ReqLengthGetter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc27ReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef)
{
  /* Return sub-function specific length. */
  return Dcm_CfgSvc27SubFuncInfo[sfRef].ReqLength;
}
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc28EnableCommunication()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc28EnableCommunication(void)
{
  uint8_least channelIter = Dcm_PbCfgNetNumAllComMChannels;

  while(channelIter != 0) /* Use top-down counting to be consistent with the Dcm_Svc28ApplyCommControl all-channel calls. */
  {
    --channelIter;
    if(Dcm_ModeGetCommControlState(channelIter) != DCM_ENABLE_RX_TX_NORM_NM)
    {
      Dcm_ModeSwitchCommControl(channelIter, DCM_ENABLE_RX_TX_NORM_NM);
    }
  }
}

/**********************************************************************************************************************
 *  Dcm_Svc28ReqLengthGetter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc28ReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef)
{
  /* Return sub-function specific length. */
  return Dcm_CfgSvc28SubFuncInfo[sfRef].ReqLength;
}
#endif /* (DCM_SVC_28_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_TMR_NUM_SVC2A_SCHEDULER > 0)
/**********************************************************************************************************************
 *  Dcm_OnTimeoutSvc2AScheduler()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_TmrTimerCntrMemType, DCM_CODE) Dcm_OnTimeoutSvc2AScheduler(void)
{
  Dcm_TmrTimerCntrMemType lReturn = 0;

  if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries != 0u)
  {
    boolean doActivateProcessorTask;

    doActivateProcessorTask = Dcm_Svc2ASchdUpdateTimers();

    if(doActivateProcessorTask == TRUE)
    {
      Dcm_TskSetEvent(DCM_TSK_ID_SVC2A_SCHEDULER, DCM_TSK_EV_SVC2A_SCHEDULER_PROCESS);/* at least one job to do */
    }
    lReturn = 1u;/* immediate timeout in next slot */
  }/* else - a NOP activate - will be the last one */
  return lReturn;/* no reload */
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdTaskProcess()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdTaskProcess(Dcm_TskTaskEvOptType ev
                                                       ,Dcm_TskTaskEvPtrType pPostEv)                                                                /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  DCM_IGNORE_UNREF_PARAM(ev);                                                                                                                        /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
  /* scheduler timer update is done in a dedicated task to achieve maximum timing accuracy */
# else
  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_SVC2A_SCHEDULER_TMR_UPD))
  {
    boolean doActivateProcessorTask;

    if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries != 0u)
    {
      doActivateProcessorTask = Dcm_Svc2ASchdUpdateTimers();
      if(doActivateProcessorTask == TRUE)
      {
        Dcm_TskSetLocalEvent(ev,  DCM_TSK_EV_SVC2A_SCHEDULER_PROCESS);/* let's check which did is in a timeout */
      }
      Dcm_TskSetLocalEvent(*pPostEv, DCM_TSK_EV_SVC2A_SCHEDULER_TMR_UPD);/* still something to do - keep timer updater alive */
    }
  }

  if(Dcm_TskIsLocalEventSet(ev, DCM_TSK_EV_SVC2A_SCHEDULER_PROCESS))
# endif
  {
    Dcm_Svc2ASchdItemHandleOptType schdIter;

    Dcm_NetPeriodicMsgResetMsgCounter();/* start new periodic message limitation monitoring */

    for(schdIter = 0; schdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++schdIter) /* loop over all scheduled items (maximum once per task activation)*/
    {
      Dcm_Svc2ASchdEntryPtrType pSchedTableEntry = &Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NextEntryIdx];

      if( (pSchedTableEntry->Timer == 0u)
        &&( (pSchedTableEntry->Rate & DCM_SVC2A_RATE_TYPE_STOPPED) == 0) )
      {
        Std_ReturnType lStdReturn;

        lStdReturn = Dcm_Svc2ASchdProcessEntry(pSchedTableEntry);
        if(lStdReturn == DCM_E_PENDING)
        {
          Dcm_TskSetLocalEvent(*pPostEv, DCM_TSK_EV_SVC2A_SCHEDULER_PROCESS);
          break; /* leave the loop and the task */
        }
      }
      /* next entry to be processed */
      Dcm_Svc2ASchdNextEntryIdxInc();
    }
  }
}
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdStopAll()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdStopAll(void)
{
  if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries != 0u)
  {
    Dcm_Svc2ASchdItemHandleOptType schdIter;

    for(schdIter = 0; schdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++schdIter)
    {
      Dcm_Svc2ASchdStopItemByHandle(schdIter);
    }
  }
}

# if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdCancelReadByHandle()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdCancelReadByHandle(Dcm_Svc2ASchdItemHandleOptType schdHandle)
{
  if( (Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.DidContextPtr != NULL_PTR)
    &&(schdHandle == Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NextEntryIdx) )
  {
    Dcm_NegativeResponseCodeType lNrc;/* not evaluated after the API call */
    Dcm_CfgNetBufferSizeOptType  lAvailLen = (Dcm_CfgNetBufferSizeOptType)(DCM_NET_PERIODIC_BUFFER_SIZE - 1u);

    /* cancel ongoing operation immediately  */
    (void)Dcm_DidMgrRead(DCM_CANCEL
                        ,&Dcm_NetPeriodicMsgGetTxBuffer(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle)[1]
                        ,&lAvailLen
                        ,Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.DidContextPtr
                        ,&(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.DidOpTypeContext)
                        ,&lNrc);

    /* Finish scheduled job */
    Dcm_Svc2ASchdFinishEntryProcessing(FALSE);
  }/* else - nothing to do */
}
# endif

# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON) && \
     (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdCancelReadByDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdCancelReadByDid(uint16 did)
{
  sint16_least schdHandle = Dcm_Svc2ASchdGetItemByDid(did);

  if(schdHandle >= 0)
  {
    Dcm_Svc2ASchdCancelReadByHandle((Dcm_Svc2ASchdItemHandleOptType)schdHandle);
  }
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdStopItemByHandle()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdStopItemByHandle(Dcm_Svc2ASchdItemHandleOptType schdHandle)
{
  if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdHandle].Rate < DCM_SVC2A_RATE_TYPE_STOPPED)
  {
    Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdHandle].Rate = DCM_SVC2A_RATE_TYPE_STOPPED;
    /* must have at least one element (this one) */
    Dcm_DebugAssert((Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries > 0), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                 /* COV_DCM_RTM_DEV_DEBUG XF */
    --Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries; /* update statistic */

# if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
    Dcm_Svc2ASchdCancelReadByHandle(schdHandle);
# endif

    if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.NumActiveEntries == 0u)/* scheduler is empty */
    {
      Dcm_NetPeriodicMsgResetConnection();/* allow other tester to use service 0x2A */
      Dcm_NetPeriodicMsgResetMsgHdl();/* reset periodic transmitter message counter */
# if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
      Dcm_TmrStopTimer(DCM_TMR_ID_SVC2A_SCHEDULER);/* stop timer updater */
# else
      /* no need to deactivate the task - if the event was set, the task will deactivate itself after a single short execution time activation */
# endif
    }
  }/* else - this item is not scheduled at all */
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdStopItemByDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdStopItemByDid(uint16 did)
{
  sint16_least schdHandle = Dcm_Svc2ASchdGetItemByDid(did);

  if(schdHandle >= 0)
  {
    Dcm_Svc2ASchdStopItemByHandle((Dcm_Svc2ASchdItemHandleOptType)schdHandle);
  }
}
/**********************************************************************************************************************
 *  Dcm_Svc2ASchdGetItemByDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(sint16_least, DCM_CODE) Dcm_Svc2ASchdGetItemByDid(uint16 did)
{
  sint16_least lResult = -1;
  Dcm_Svc2ASchdItemHandleOptType schdIter;

  for(schdIter = 0; schdIter < DCM_SVC_2A_SCHEDULER_SIZE; ++schdIter)
  {
    if(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.Table[schdIter].DidContext.Did == did)
    {
      lResult = (sint16_least)schdIter;
      break;
    }
  }
  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc2ASchdFinishEntryProcessing()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2ASchdFinishEntryProcessing(boolean doSendResponse)
{
  if(doSendResponse == TRUE)
  {
    Dcm_NetPeriodicMsgTransmit(Dcm_NetPTxObjWrpFirst(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle)
                              (PduLengthType)(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.DidContextPtr->DidLength + 1));
  }
  else
  {
    Dcm_NetPeriodicMsgRelease(Dcm_NetPTxObjWrpOnly(Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle));/* release resource if not used */
  }

  Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.DidContextPtr = NULL_PTR;
  Dcm_InstanceContext.Diag.Services.Svc2A.Scheduler.MsgTxHandle   = DCM_NET_INVALID_PTXOBJ_HANDLE; /* free for next DID */
# if (DCM_DIDMGR_2A_ACCESS_LOCK_ENABLED == STD_ON)
  Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadPeriodic = 0u;
# endif
}
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc2ADidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADidLookUp(Dcm_OpStatusType opStatus, Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType lStdReturn;
  boolean doProcessDid = TRUE;

  if(opStatus == DCM_INITIAL)
  {
    if(pMsgContext->reqDataLen != 0u)
    {
      Dcm_InstanceContext.Repeater.Contexts.Context.Svc2A.DidInfoContext.Did = Dcm_Svc2AMakePeriodicDid(pMsgContext->reqData[0]);
      /* Prepare for next DID */
      Dcm_DiagMoveOnReqWithLength(pMsgContext, 1u);                                                                                                  /* PRQA S 3109 */ /* MD_MSR_14.3 */
    }
    else
    {
      doProcessDid = FALSE;
    }
  }

  if(doProcessDid == TRUE)
  {
    lStdReturn = Dcm_DidMgrGetDidInfo(opStatus
                                     ,&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2A.DidInfoContext)
                                     ,&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2A.DidOpTypeContext)
                                     ,DCM_DIDMGR_OP_READ);
    if(lStdReturn == DCM_E_OK)
    {
      Dcm_InstanceContext.Repeater.Contexts.Context.Svc2A.HasAnySupportedDids = TRUE; /* register a supported DID */
      /* go on with the DID condition check - DCM_E_OK */
    }
    else if(lStdReturn == DCM_E_PENDING)
    {
      /* already set */
    }
    else
    {
      /* Just skip this DID - DCM_E_NOT_OK - request a new client loop */
      lStdReturn = DCM_E_LOOP;
    }
  }
  else
  {
    /* empty run loop ended without any DID to be processed (for this activation of the repeater proxy)*/
    /* all DIDs processed */
    if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2A.HasAnySupportedDids == FALSE)
    {
      Dcm_SetNegResponse(DCM_E_REQUESTOUTOFRANGE);
    }
    lStdReturn = DCM_E_PROCESSINGDONE;
  }

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc2AStoppedDidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AStoppedDidLookUp(Dcm_OpStatusType      opStatus
                                                                  ,Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType lStdReturn;

  lStdReturn = Dcm_Svc2ADidLookUp(opStatus, pMsgContext);

  if(lStdReturn == DCM_E_OK)
  {
    Dcm_Svc2ASchdStopItemByDid(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2A.DidInfoContext.Did);
    lStdReturn = DCM_E_LOOP;/* go on with the next DID  */
  }
  else
  {
    /* DCM_E_PENDING, DCM_E_PROCESSINGDONE (lNrc already set), DCM_E_LOOP */
  }

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Svc2AScheduledDidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2AScheduledDidLookUp(Dcm_OpStatusType      opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType lStdReturn;

  lStdReturn = Dcm_Svc2ADidLookUp(opStatus, pMsgContext);

  if(lStdReturn == DCM_E_OK)
  {
    Dcm_NegativeResponseCodeType  lNrc;
    lNrc = Dcm_DidMgrDynDidStateCheck(&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2A.DidInfoContext));
    if(lNrc == DCM_E_POSITIVERESPONSE)
    {
      /* Proceed with next validation step. */
# if (DCM_DIDMGR_PERIODICDID_CHK_COND_ENABLED == STD_ON)
      Dcm_RepeaterSetCallee(Dcm_Svc2ADidCheckCondition); /* next job */
# else
      Dcm_RepeaterSetCallee(Dcm_Svc2ADidGetLength); /* next job */
# endif
      lStdReturn = DCM_E_LOOP;/* speed up processing */
    }
    else
    {
      Dcm_SetNegResponse(lNrc); /* lNrc already assigned */
      lStdReturn = DCM_E_PROCESSINGDONE;
    }
  }
  else
  {
    /* DCM_E_PENDING, DCM_E_PROCESSINGDONE (lNrc already set), DCM_E_LOOP */
  }

  return lStdReturn;
}

# if (DCM_DIDMGR_PERIODICDID_CHK_COND_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2ADidCheckCondition()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADidCheckCondition(Dcm_OpStatusType opStatus
                                                                   ,Dcm_MsgContextPtrType pMsgContext)                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
#  if (DCM_DIDMGR_PERIODICDID_CHK_COND_ALL_ENABLED == STD_OFF)
  if(Dcm_DidMgrIsOpTypeSupported(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2A.DidInfoContext.Descriptor.DidOpInfoPtr, DCM_DIDMGR_OPTYPE_READCHKCOND))
#  endif
  {
    Std_ReturnType               lStdResult;
    Dcm_NegativeResponseCodeType lNrc;

    DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                             /* PRQA S 3112 */ /* MD_Dcm_3112 */

    /* check condition on this DID */
    Dcm_DidMgrGetOpClassInfo(&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2A.DidInfoContext), DCM_DIDMGR_OPTYPE_READCHKCOND);
    lStdResult = Dcm_DidMgrReadCheckCond(opStatus
                                        ,&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2A.DidInfoContext)
                                        ,&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2A.DidOpTypeContext)
                                        ,&lNrc);

    if(lStdResult == DCM_E_OK)
    {
      /* DCM_E_OK - go on with next DID */
    }
    else
#  if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
    if(lStdResult == DCM_E_PENDING)
    {
      return DCM_E_PENDING;
    }
    else
#  endif
    {
      /* DCM_E_NOT_OK */
      Dcm_SetNegResponse(lNrc);
      return DCM_E_PROCESSINGDONE; /* finish service processing immediately */
    }
  }/* else - not supported operation - go on with getLength */

  Dcm_RepeaterSetCallee(Dcm_Svc2ADidGetLength);
  return DCM_E_LOOP;/* speed up processing */
}                                                                                                                                                    /* PRQA S 2006 */ /* MD_Dcm_Optimize_2006 */
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2ADidGetLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ADidGetLength(Dcm_OpStatusType opStatus
                                                              ,Dcm_MsgContextPtrType pMsgContext)                                                    /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdReturn;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* calculate DID data length */
# if (DCM_DIDMGR_OPTYPE_READ_LENGTH_ENABLED == STD_ON)
  /* read length */
  {
    Dcm_NegativeResponseCodeType lNrc;

    lStdReturn = Dcm_DidMgrReadLength(opStatus
                                     ,&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2A.DidInfoContext)
                                     ,&lNrc);

    if(lStdReturn == DCM_E_NOT_OK)
    {
      Dcm_SetNegResponse(lNrc);/* default value if nothing set in the application */
      lStdReturn = DCM_E_PROCESSINGDONE; /* finish service processing immediately */
    }/* else - DCM_E_PENDING, DCM_E_OK */
  }/* else - static length */

  if(lStdReturn == DCM_E_OK)
# endif
  {
    /* check for buffer overrun */
    if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2A.DidInfoContext.DidLength > DCM_SVC2A_MAX_RESPONSE_LEN) /* the buffer shall accept the periodic DID + data */
    {
      Dcm_SetNegResponse(DCM_E_RESPONSETOOLONG);/* the configured buffer will not be able to hold all of the data -> notify the client */
      lStdReturn = DCM_E_PROCESSINGDONE; /* finish service processing immediately */
    }
    else
    {
      /* Add scheduler job */
      Dcm_DidMgrGetOpClassInfo(&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2A.DidInfoContext), DCM_DIDMGR_OPTYPE_READ);/* set the operation now since not changed later */

      Dcm_Svc2ASchdAddItemByDid(&Dcm_InstanceContext.Repeater.Contexts.Context.Svc2A.DidInfoContext);

      Dcm_RepeaterSetCallee(Dcm_Svc2AScheduledDidLookUp);
      lStdReturn = DCM_E_LOOP;/* speed up processing */
    }
  }/* else - DCM_E_PENDING, DCM_E_PROCESSINGDONE */

  return lStdReturn;
}
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_SVC_2C_CLEAR_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrClear()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc2CDefMgrClear(Dcm_CfgDidMgrDynDidHandleMemType dynDidHandle)
{
#  if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON)
  {
    uint16 lDid = Dcm_DidMgrGetDynDidIdFromHandle(dynDidHandle);
    /* Try stopping any active periodic DID (can be still read at that time)! */
    Dcm_Svc2ASchdStopItemByDid(lDid);
  }
#  endif
  Dcm_InstanceContext.Diag.Services.Svc2C.Items[dynDidHandle].Length = 0u;
  Dcm_InstanceContext.Diag.Services.Svc2C.Items[dynDidHandle].Count  = 0u;
}
# endif
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc2CCheckNumOfItems()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_NegativeResponseCodeType, DCM_CODE) Dcm_Svc2CCheckNumOfItems(Dcm_MsgContextPtrType pMsgContext)                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Dcm_NegativeResponseCodeType lNrcResult;
  if( (uint8)((Dcm_DidMgrGetDynDidSize(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidHandle) - Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidItemCount)) >= pMsgContext->reqDataLen)
  {
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.ReqNumOfItems = (uint8)pMsgContext->reqDataLen;
    lNrcResult = DCM_E_POSITIVERESPONSE;
  }
  else
  {
    lNrcResult = DCM_E_REQUESTOUTOFRANGE;
  }

  return lNrcResult;
}

/**********************************************************************************************************************
 *  Dcm_Svc2CParseAndCheckDynDid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CParseAndCheckDynDid(Dcm_OpStatusType      opStatus
                                                                     ,Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType lStdReturn;

  if(opStatus == DCM_INITIAL)
  {
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidInfoContext.Did = Dcm_UtiMake16Bit(pMsgContext->reqData[0], pMsgContext->reqData[1]);

    Dcm_DiagMoveOnReqWithLength(pMsgContext,2u);  /* skip to the source items and extract the DynDID */                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    Dcm_DiagUpdateResLength(pMsgContext, 2u); /* positive response contains the DynDID (2Byte) */
  }

  lStdReturn = Dcm_DidMgrGetDidInfo(opStatus
                                   ,&Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidInfoContext
                                   ,&Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidOpTypeContext
                                   ,DCM_DIDMGR_OP_DEFINE);

  if(lStdReturn == DCM_E_OK)
  {
    Dcm_NegativeResponseCodeType lNrc;

    lNrc = Dcm_StateCheck(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidInfoContext.Descriptor.DidOpInfoPtr->ExecCondRef, DCM_DIAG_CHK_LVL_PARAMETER);
    if(lNrc == DCM_E_POSITIVERESPONSE)
    {
      /* initialize common DynDID request context */
# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON)
      if(Dcm_Svc2AIsPeriodicDid(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidInfoContext.Did))
      {
        Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.MaxAllowedLength = DCM_SVC2A_MAX_RESPONSE_LEN;
      }
      else
# endif
      {
        /* Perform length check based on the current protocol only. Sid 0x22 will do additional checks at read time in case a client from another protocol is trying to access the DynDID! */
        Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.MaxAllowedLength = Dcm_Svc2CGetMaxDynDidProtocolLen();
      }

      Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidHandle = (Dcm_CfgDidMgrDynDidHandleMemType)Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidInfoContext.Descriptor.DidInfoPtr->OpRef;
      Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidLength = Dcm_InstanceContext.Diag.Services.Svc2C.Items[Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidHandle].Length; /* set current length for updates during service processing */
      Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.SrcItemIndex = Dcm_Svc2CGetSrcItemIndex(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidHandle
                                                                                                 ,Dcm_InstanceContext.Diag.Services.Svc2C.Items[Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidHandle].Count);
# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
      Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.SrcItemPtr = &(Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.SrcItemIndex]);
# endif
      Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidItemCount  = Dcm_InstanceContext.Diag.Services.Svc2C.Items[Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidHandle].Count;

      /*lStdReturn = DCM_E_OK - already set */
    }
    else
    {
      Dcm_SetNegResponse(lNrc);
      lStdReturn = DCM_E_PROCESSINGDONE;
    }
  }
  else if(lStdReturn == DCM_E_PENDING)
  {
    /* lStdReturn already set */
  }
  else
  {
    Dcm_SetNegResponse(DCM_E_REQUESTOUTOFRANGE);
    lStdReturn = DCM_E_PROCESSINGDONE;
  }
  return lStdReturn;
}

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C_01SrcDidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C_01SrcDidLookUp(Dcm_OpStatusType opStatus
                                                                 ,Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType lStdReturn;

  if(opStatus == DCM_INITIAL)
  {
     /* Extract source DID */
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.SrcItemPtr->DidDescriptor.DidContext.Did = Dcm_UtiMake16Bit(pMsgContext->reqData[0],pMsgContext->reqData[1]);
    Dcm_UtiNextItemByPtr(pMsgContext->reqData, 2u); /* skip the source DID */
  }

  lStdReturn = Dcm_DidMgrGetDidInfo(opStatus
                                   ,&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.SrcItemPtr->DidDescriptor.DidContext)
                                   ,&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidOpTypeContext) /* Use OpTypeContext of DynDID since no more needed at this time! */
                                   ,DCM_DIDMGR_OP_READ);

  if(lStdReturn == DCM_E_OK)
  {
    if(!Dcm_DidMgrIsOpSupported(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.SrcItemPtr->DidDescriptor.DidContext.Descriptor.DidInfoPtr, DCM_DIDMGR_OP_DEFINE))
    {
      Dcm_NegativeResponseCodeType lNrc;

      lNrc = Dcm_StateCheck(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.SrcItemPtr->DidDescriptor.DidContext.Descriptor.DidOpInfoPtr->ExecCondRef, DCM_DIAG_CHK_LVL_PARAMETER);
      if(lNrc == DCM_E_POSITIVERESPONSE)
      {
#  if (DCM_DIDMGR_OPTYPE_READ_CHECKCOND_ENABLED == STD_ON)
        Dcm_RepeaterSetCallee(Dcm_Svc2C_01SrcDidCheckCondition); /* next job */
#  else
        Dcm_RepeaterSetCallee(Dcm_Svc2C_01SrcDidGetLength); /* next job */
#  endif
        lStdReturn = DCM_E_LOOP;
      }
      else
      {
        /* else - at least one source DID fails under current ECU conditions - lNrc already set */
        Dcm_SetNegResponse(lNrc);
        lStdReturn = DCM_E_PROCESSINGDONE;
      }
    }
    else
    {
      /* else - no DynDID may be referenced! */
      Dcm_SetNegResponse(DCM_E_REQUESTOUTOFRANGE);
      lStdReturn = DCM_E_PROCESSINGDONE;
    }
  }
  else if(lStdReturn == DCM_E_PENDING)
  {
    /* lStdReturn is already set */
  }
  else
  {
    /* else - source DID is not supported */
    Dcm_SetNegResponse(DCM_E_REQUESTOUTOFRANGE);
    lStdReturn = DCM_E_PROCESSINGDONE;
  }

  return lStdReturn;
}
# endif

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON) && \
     (DCM_DIDMGR_OPTYPE_READ_CHECKCOND_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C_01SrcDidCheckCondition()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C_01SrcDidCheckCondition(Dcm_OpStatusType opStatus
                                                                         ,Dcm_MsgContextPtrType pMsgContext)                                         /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
#  if (DCM_DIDMGR_OPTYPE_READ_CHECKCOND_ALL_ENABLED == STD_OFF)
  if(Dcm_DidMgrIsOpTypeSupported(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.SrcItemPtr->DidDescriptor.DidContext.Descriptor.DidOpInfoPtr, DCM_DIDMGR_OPTYPE_READCHKCOND))
#  endif
  {
    Std_ReturnType               lStdResult;
    Dcm_NegativeResponseCodeType lNrc;

    DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                             /* PRQA S 3112 */ /* MD_Dcm_3112 */

    /* check condition on this DID */
    Dcm_DidMgrGetOpClassInfo(&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.SrcItemPtr->DidDescriptor.DidContext), DCM_DIDMGR_OPTYPE_READCHKCOND);
    lStdResult = Dcm_DidMgrReadCheckCond(opStatus
                                        ,&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.SrcItemPtr->DidDescriptor.DidContext)
                                        ,&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidOpTypeContext)  /* Use OpTypeContext of DynDID since no more needed at this time! */
                                        ,&lNrc);

    if(lStdResult == DCM_E_OK)
    {
      /* DCM_E_OK - go on with next operation */
    }
    else
#  if (DCM_DIDMGR_STATIC_DID_ASYNC_SUPPORT_ENABLED == STD_ON)
    if(lStdResult == DCM_E_PENDING)
    {
      return DCM_E_PENDING;
    }
    else
#  endif
    {
      /* DCM_E_NOT_OK */
      Dcm_SetNegResponse(lNrc);
      return DCM_E_PROCESSINGDONE; /* finish service processing immediately */
    }
  }/* else - not supported operation - go on with getLength */

  Dcm_RepeaterSetCallee(Dcm_Svc2C_01SrcDidGetLength); /* next job */
  return DCM_E_LOOP;/* speed up processing */
}                                                                                                                                                    /* PRQA S 2006 */ /* MD_Dcm_Optimize_2006 */
# endif

# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C_01SrcDidGetLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C_01SrcDidGetLength(Dcm_OpStatusType opStatus
                                                                    ,Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType lStdReturn;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* calculate DID data length */
#  if (DCM_DIDMGR_STATIC_DID_OPTYPE_READ_LENGTH_ENABLED == STD_ON)
  /* read length */
  {
    Dcm_NegativeResponseCodeType lNrc;

    lStdReturn = Dcm_DidMgrReadLength(opStatus
                                     ,&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.SrcItemPtr->DidDescriptor.DidContext)
                                     ,&lNrc);

    if(lStdReturn == DCM_E_NOT_OK)
    {
      Dcm_SetNegResponse(lNrc);/* default value if nothing set in the application */
      lStdReturn = DCM_E_PROCESSINGDONE; /* finish service processing immediately */
    }/* else - DCM_E_PENDING, DCM_E_OK */
  }/* else - static length */

  if(lStdReturn == DCM_E_OK)
#  endif
  {
    /* else - check for definition length overflow */
#  if (DCM_SVC_2C_READ_BUFFER_SIZE < 255u)
    if (pMsgContext->reqData[1] > DCM_SVC_2C_READ_BUFFER_SIZE)
    {
      Dcm_SetNegResponse(DCM_E_REQUESTOUTOFRANGE);/* too much data referenced for temporary read buffer */
      lStdReturn = DCM_E_PROCESSINGDONE; /* finish service processing immediately */
    }
    else
#  endif
    if( (pMsgContext->reqData[0] == 0u)
      ||((pMsgContext->reqData[0] + pMsgContext->reqData[1] - 1u) > Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.SrcItemPtr->DidDescriptor.DidContext.DidLength) )
    {
      Dcm_SetNegResponse(DCM_E_REQUESTOUTOFRANGE);/* source DID referenced data out of boundary  */
      lStdReturn = DCM_E_PROCESSINGDONE; /* finish service processing immediately */
    }/* check for possible read buffer or response overflow */
    else if( (!Dcm_UtiIsAdditionSafe(uint16, Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidLength, pMsgContext->reqData[1]))
           ||(Dcm_UtiPromotedSum(uint16, Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidLength, pMsgContext->reqData[1]) > Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.MaxAllowedLength) )
    {
      Dcm_SetNegResponse(DCM_E_REQUESTOUTOFRANGE);/* too much data referenced  */
      lStdReturn = DCM_E_PROCESSINGDONE; /* finish service processing immediately */
    }
    else/* Add this DID to the definition */
    {
      /* update total length of the DynDID for commitment */
      Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidLength += pMsgContext->reqData[1];

      /* store referenced data */
      Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.SrcItemPtr->DidDescriptor.Offset = (uint8)(pMsgContext->reqData[0] - 1u);
      Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.SrcItemPtr->DidDescriptor.Size   = pMsgContext->reqData[1];
      Dcm_Svc2CSetDidSrcItem(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.SrcItemIndex); /* set the type of the source item to DID */

      Dcm_UtiNextItemByPtr(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.SrcItemPtr, 1u); /* next item ref */
      ++Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.SrcItemIndex; /* next item to be configured */
      ++Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidItemCount; /* update number of items for commitment */

      --Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.ReqNumOfItems;/* commit processed item */
      if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.ReqNumOfItems != 0u) /* any left items? */
      {
        Dcm_UtiNextItemByPtr(pMsgContext->reqData, 2u); /* skip the source offset and size parameters */
        Dcm_RepeaterSetCallee(Dcm_Svc2C_01SrcDidLookUp); /* next job */
        lStdReturn = DCM_E_LOOP;/* speed up processing */
      }
      else
      {
        lStdReturn = DCM_E_PROCESSINGDONE; /* all source items finished service processing immediately */
      }
    }
  }
  return lStdReturn;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2CReqLengthGetter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc2CReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef)
{
  DCM_IGNORE_UNREF_PARAM(sfRef);                                                                                                                     /* PRQA S 3112 */ /* MD_Dcm_3112 */
  /* Return sub-function specific length (always zero -> dynamic since it depends on the complete request content). */
  return 0u;
}

# if (DCM_SVC_2C_03_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2C_03DidLookUp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2C_03DidLookUp(Dcm_OpStatusType      opStatus
                                                              ,Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType lStdReturn;

  if(opStatus == DCM_INITIAL)
  {
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidInfoContext.Did = Dcm_UtiMake16Bit(pMsgContext->reqData[0], pMsgContext->reqData[1]);

    Dcm_DiagMoveOnReqWithLength(pMsgContext,2u);  /* skip to the source items and extract the DynDID */                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    Dcm_DiagUpdateResLength(pMsgContext, 2u); /* positive response contains the DynDID (2Byte) */
  }

  lStdReturn = Dcm_DidMgrGetDidInfo(opStatus
                                   ,&Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidInfoContext
                                   ,&Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidOpTypeContext
                                   ,DCM_DIDMGR_OP_DEFINE);

  if(lStdReturn == DCM_E_OK)
  {
    /* clear concrete DynDID */
    Dcm_Svc2CDefMgrClear((Dcm_CfgDidMgrDynDidHandleMemType)Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidInfoContext.Descriptor.DidInfoPtr->OpRef);
    lStdReturn = DCM_E_PROCESSINGDONE;
  }
  else if(lStdReturn == DCM_E_PENDING)
  {
    /* lStdReturn is already set */
  }
  else
  { /* DCM_E_NOT_OK */
    Dcm_SetNegResponse(DCM_E_REQUESTOUTOFRANGE);
    lStdReturn = DCM_E_PROCESSINGDONE;
  }

  return lStdReturn;
}
# endif
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_DIDMGR_2E_ACCESS_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2ECheckAccess()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2ECheckAccess(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext)                                                     /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_DIDMGR_2C_ACCESS_LOCK_ENABLED == STD_ON)
  if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2E.DidInfoContext.Did == Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadDynamic)    /* no periodic DID is a writable DID -> no need to check for race conditions! */
  {
    lStdResult = DCM_E_PENDING;
  }
  else
#  endif
  {
    Dcm_InstanceContext.DidMgr.DidRsrcContext.Write = Dcm_InstanceContext.Repeater.Contexts.Context.Svc2E.DidInfoContext.Did;
    Dcm_RepeaterSetCallee(Dcm_Svc2EExecuteOp); /* delegate job */
    lStdResult = DCM_E_LOOP;/* speed up processing */
  }

  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2EExecuteOp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2EExecuteOp(Dcm_OpStatusType opStatus, Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType               lStdResult;
  Dcm_NegativeResponseCodeType lNrc;

  lStdResult = Dcm_DidMgrWrite(opStatus
                             ,pMsgContext
                             ,&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2E.DidInfoContext)
                             ,&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2E.DidOpTypeContext)
                             ,&lNrc);
# if (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
  if(lStdResult == DCM_E_PENDING)
  {
    /* return DCM_E_PENDING */
  }
  else
# endif
  {
    if(lStdResult != DCM_E_OK)
    {
      Dcm_SetNegResponse(lNrc);
    }
    lStdResult = DCM_E_PROCESSINGDONE;
# if (DCM_DIDMGR_2E_ACCESS_LOCK_ENABLED == STD_ON)
    Dcm_InstanceContext.DidMgr.DidRsrcContext.Write = 0u;
# endif
  }

  return lStdResult;
}
#endif /* (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_DIDMGR_2F_ACCESS_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FCheckAccess()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FCheckAccess(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext)                                                     /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_DIDMGR_2A_ACCESS_LOCK_ENABLED == STD_ON)
  if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidInfoContext.Did == Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadPeriodic)
  {
    lStdResult = DCM_E_PENDING;
  }
  else
#  endif
#  if (DCM_DIDMGR_2C_ACCESS_LOCK_ENABLED == STD_ON)
  if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidInfoContext.Did == Dcm_InstanceContext.DidMgr.DidRsrcContext.ReadDynamic )
  {
    lStdResult = DCM_E_PENDING;
  }
  else
#  endif
  {
    Dcm_InstanceContext.DidMgr.DidRsrcContext.Io = Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidInfoContext.Did;
    Dcm_RepeaterSetCallee(Dcm_Svc2FExecuteOp); /* delegate job */
    lStdResult = DCM_E_LOOP;
  }
  return lStdResult;/* speed up processing */
}
# endif

# if (DCM_SVC_2F_READ_RES_DATA_LEN_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FGetLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FGetLength(Dcm_OpStatusType opStatus
                                                           ,Dcm_MsgContextPtrType pMsgContext)                                                       /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdReturn;
  Dcm_NegativeResponseCodeType lNrc;

  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdReturn = Dcm_DidMgrReadLength(opStatus
                                   ,&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidInfoContext)
                                   ,&lNrc);
  if(lStdReturn == DCM_E_OK)
  {
    /* Delegate the job to the data reader. */
    Dcm_RepeaterSetCallee(Dcm_Svc2FReadData);
    lStdReturn = DCM_E_LOOP;
  }
  else if(lStdReturn == DCM_E_NOT_OK)
  {
    Dcm_SetNegResponse(lNrc);/* default value if nothing set in the application */
    lStdReturn = DCM_E_PROCESSINGDONE; /* finish service processing immediately */
  }
  else
  {
    /* DCM_E_PENDING */
  }

  return lStdReturn;
}
# endif

# if(DCM_DIDMGR_IODID_READ_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2FReadData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FReadData(Dcm_OpStatusType opStatus
                                                          ,Dcm_MsgContextPtrType pMsgContext)                                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType               lStdResult;
  Dcm_NegativeResponseCodeType lNrc;
  Dcm_CfgNetBufferSizeOptType  lAvailLen = (Dcm_CfgNetBufferSizeOptType)pMsgContext->resMaxDataLen;

  /* Read DID  */
  Dcm_DidMgrGetOpClassInfo(&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidInfoContext), DCM_DIDMGR_OPTYPE_READ);
  lStdResult = Dcm_DidMgrRead(opStatus
                            ,pMsgContext->resData
                            ,&lAvailLen
                            ,&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidInfoContext)
                            ,&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidOpTypeContext)
                            ,&lNrc);

  if(lStdResult == DCM_E_OK)
  {
    /* Update response length and go on with response */
    Dcm_DiagUpdateResLength(pMsgContext, Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidInfoContext.DidLength);                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    lStdResult = DCM_E_PROCESSINGDONE;
  }
  else
#  if (DCM_DIDMGR_ASYNC_IODID_SUPPORT_ENABLED == STD_ON)
  if(lStdResult == DCM_E_PENDING)
  {
    /* return DCM_E_PENDING; */
  }
  else
#  endif
  {
    /* DCM_E_NOT_OK | PENDING (if unexpected) */
    Dcm_DebugApiCheckRteAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)
    Dcm_SetNegResponse(lNrc);/* something went wrong */
    lStdResult = DCM_E_PROCESSINGDONE;
  }

  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2FExecuteOp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2FExecuteOp(Dcm_OpStatusType opStatus
                                                           ,Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType               lStdResult;
  Dcm_NegativeResponseCodeType lNrc;

# if (DCM_DIDMGR_OPCLS_IO_ANY_WITH_INT_CEMR_ENABLED == STD_ON)
  /* #10 If an IO DID with an internal CEMR handling is to be processed: */
  if( (Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidOpTypeContext.OpType.Io.EnableMaskPtr != NULL_PTR)/* A request with CEMR is recieved and ... */
#  if (DCM_DIDMGR_OPCLS_IO_ANY_WITH_EXT_CEMR_ENABLED == STD_ON)
    &&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidInfoContext.Descriptor.DidSignalOpClassInfoPtr->FuncClass < DCM_DIDMGR_OPCLS_IO_FIRST_OPCLS_WITH_EXT_CEMR) /* ... the CEMR is not handled in the application call. */
#  endif
    )
  {
    /* #20 Delegate the IO DID control operation processing to the DID manager utility that considers the requested CEMR. */
    lStdResult = Dcm_DidMgrIoControlWithMask(opStatus
                                            ,pMsgContext
                                            ,&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidInfoContext)
                                            ,&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidOpTypeContext)
                                            ,&lNrc);
  }
  else
# endif
  {
    /* #30 Otherwise delegate the IO DID control operation processing to the DID manager utility that executes all callbacks regardless of an available CEMR. */
    lStdResult = Dcm_DidMgrIoControl(opStatus
                                    ,pMsgContext
                                    ,&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidInfoContext)
                                    ,&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidOpTypeContext)
                                    ,&lNrc);
  }

  /* #40 On successful IO DID control operation accomplishment: */
  if(lStdResult == DCM_E_OK)
  {
# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
    /* #50 Decide whether to register the IO DID for automatic recovery on transition to the default session. */
    if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.OpType != DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU)
    {
      /* On successfully executed control operation that is not "ReturnControlToEcu", register the complete IO DID for automatic reset on a transition to the default session
       * only if the IO DID supports "ReturnControlToEcu".
       */
      if(Dcm_DidMgrIsOpTypeSupported(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidInfoContext.Descriptor.DidOpInfoPtr, DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU))
      {
        /* Must have a valid index! */
        Dcm_DebugAssert((Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidInfoContext.Descriptor.DidInfoPtr->OpRef < DCM_NUM_IODIDS), DCM_SID_INTERNAL, DCM_E_INVALID_CONFIG) /* COV_DCM_RTM_DEV_DEBUG XF */

        /* Register IODID for state change monitoring. */
        Dcm_Svc2FSetDidActive(Dcm_DidMgrOpInfoRedirector(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidInfoContext.Descriptor.DidInfoPtr->OpRef, OpRefIoControl));
        /* #60 Activate the scanning algorithm for the next session state change. */
        Dcm_InstanceContext.Diag.Services.Svc2F.HasAnyActiveIoDid = TRUE;/* at least one activated IO DID */
      }/* Otherwise - nothing to register. */
    }
    else
    {
      /* #70 Decide whether to unregister the IO DID from automatic recovery (reduces run-time usage on next session transition). */
#  if (DCM_DIDMGR_IO_MASKRECORD_ENABLED == STD_ON)
      /* Let all once activated DIDs to be reset later on session/security state change. Otherwise if only some of the signals have been reset by "ReturnControlToEcu", the whole DID will be removed from the queue! */
#  else
      /* For return control to ECU - remove from post clearing. */
      Dcm_Svc2FClrDidActive(Dcm_DidMgrOpInfoRedirector(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidInfoContext.Descriptor.DidInfoPtr->OpRef, OpRefIoControl));
#  endif
    }
# endif
# if(DCM_DIDMGR_IODID_READ_SUPPORT_ENABLED == STD_ON)
    /* #80 Decide whether any response data have to be sent back to the client in addition to the control operation. */
    if(  (Dcm_DidMgrIsOpSupported(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidInfoContext.Descriptor.DidInfoPtr, DCM_DIDMGR_OP_READ))
#  if (DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_RES_NCEMR_ERROR_ENABLED == STD_ON)
       &&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidInfoContext.Descriptor.DidSignalOpClassInfoPtr->FuncClass != DCM_DIDMGR_OPCLS_IO_REQ_LEN_SYNC_RES_NCEMR_ERROR)
#  endif
      )
    {
      /* #90 Set new IO DID operation to be reading. */
      Dcm_DidMgrGetDidOpInfo(&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidInfoContext), DCM_DIDMGR_OP_READ);

#  if (DCM_SVC_2F_READ_RES_DATA_LEN_ENABLED == STD_ON)
      /* #100 On IO DIDs with dynamic length, start first reading the concrete data length. */
      Dcm_RepeaterSetCallee(Dcm_Svc2FGetLength); /* next job */
#  else
      /* #110 On IO DIDs with static length, start directly reading the response data. */
      Dcm_RepeaterSetCallee(Dcm_Svc2FReadData); /* next job */
#  endif
      /* #120 Start with next step immediately. */
      lStdResult = DCM_E_LOOP;
    }
    else
# endif
    {
      /* #130 If the IO DID does not support reading operation, continue with an empty positive response. */
      lStdResult = DCM_E_PROCESSINGDONE;
    }
  }
# if (DCM_DIDMGR_ASYNC_IODID_SUPPORT_ENABLED == STD_ON)
  else if(lStdResult == DCM_E_PENDING)
  {
  /* #140 If IO DID control operation is not yet finished, try again later. */
  }
# endif
  else /* DCM_E_NOT_OK */
  {
  /* #150 If IO DID control operation has failed return negative response. */
    Dcm_SetNegResponse(lNrc);
    lStdResult = DCM_E_PROCESSINGDONE;
  }

  /* #160 Delegate final result to the caller. */
  return lStdResult;
}
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_31_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc31ExecuteOp()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc31ExecuteOp(Dcm_OpStatusType opStatus
                                                           ,Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType               lStdResult;
  Dcm_NegativeResponseCodeType lNrc;

  lStdResult = Dcm_RidMgrExecuteRoutine(opStatus, pMsgContext, &lNrc);

  if(lStdResult == DCM_E_OK)
  {
     lStdResult = DCM_E_PROCESSINGDONE;
  }
  else if(lStdResult == DCM_E_NOT_OK)
  {
    Dcm_SetNegResponse(lNrc);/* default value if nothing set in the application */
    lStdResult = DCM_E_PROCESSINGDONE;
  }
  else
  {
    /* DCM_E_PENDING | DCM_E_FORCE_RCRRP */
  }

  return lStdResult;
}
#endif /* (DCM_SVC_31_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc3DCheckAccess()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc3DCheckAccess(Dcm_OpStatusType opStatus
                                                          ,Dcm_MsgContextPtrType pMsgContext)                                                        /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if(Dcm_InstanceContext.MemMgr.LockedByClient != DCM_MEMMGR_ACCESS_NONE)
  {
    lStdResult = DCM_E_PENDING;
  }
  else
  {
    Dcm_InstanceContext.MemMgr.LockedByClient = DCM_MEMMGR_ACCESS_REQ_EXT;
    Dcm_RepeaterSetCallee(Dcm_Svc3DWriteMemory); /* delegate job */
    lStdResult = DCM_E_LOOP;/* speed up processing */
  }
  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc3DWriteMemory()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc3DWriteMemory(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext)                                                     /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;
  Dcm_NegativeResponseCodeType lNrc;
  lNrc = DCM_E_GENERALPROGRAMMINGFAILURE;

  lStdResult = Dcm_MemMgrWriteMemory(opStatus
                                   ,&Dcm_InstanceContext.Repeater.Contexts.Context.Svc3D.MemBlock
                                   ,pMsgContext->reqData
                                   ,&lNrc
                                   );

  switch(lStdResult)
  {
  case DCM_E_NOT_OK:
    Dcm_SetNegResponse(lNrc);
    /* fall through */
  case DCM_E_OK:                                                                                                                                     /* PRQA S 2003 */ /* MD_Dcm_Optimize_2003 */
    lStdResult = DCM_E_PROCESSINGDONE;
    break;
  default:
    /*  any other result to be delegated to the core
     *  No DET monitoring needed since the Dcm_MemMgrWriteMemory has already one!
     */
    break;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc85EnableDtcSetting()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc85EnableDtcSetting(void)
{
  Dem_ReturnControlDTCSettingType lDemResult;

  if(Dcm_ModeGetControlDtcSettingMode() != RTE_MODE_DcmControlDtcSetting_ENABLEDTCSETTING)
  {
    /* Enable the DTC setting for all DTCs. */
    lDemResult = Dcm_DemAPI(EnableDTCSetting)(DEM_DTC_GROUP_ALL_DTCS, DEM_DTC_KIND_ALL_DTCS);

    /* If the enabling was successful: */
    if(lDemResult == DEM_CONTROL_DTC_SETTING_OK)
    {
      Dcm_ModeSwitchDtcSetting(RTE_MODE_DcmControlDtcSetting_ENABLEDTCSETTING, DEM_DTC_GROUP_ALL_DTCS);
    }
  }
}

# if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)                                                                                                     /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc85DisableDtcSetting()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(void, DCM_CODE) Dcm_Svc85DisableDtcSetting(Dem_DTCGroupType DTCGroup)
{
  Dem_ReturnControlDTCSettingType lDemResult;
  /* Disable the DTC setting for all DTCs. */
  lDemResult = Dcm_DemAPI(DisableDTCSetting)(DTCGroup, DEM_DTC_KIND_ALL_DTCS);

  /* If the disabling was successful: */
  if(lDemResult == DEM_CONTROL_DTC_SETTING_OK)
  {
    Dcm_ModeSwitchDtcSetting(RTE_MODE_DcmControlDtcSetting_DISABLEDTCSETTING, DTCGroup);
  }
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc85ReqLengthGetter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc85ReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef)
{
  DCM_IGNORE_UNREF_PARAM(sfRef);                                                                                                                     /* PRQA S 3112 */ /* MD_Dcm_3112 */
  /* Return sub-function specific length (always the same constant). */
  return DCM_SVC_85_REQ_LENGTH;
}
#endif /* (DCM_SVC_85_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc86ReqLengthGetter()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
DCM_LOCAL FUNC(Dcm_DiagSubServiceLengthType, DCM_CODE) Dcm_Svc86ReqLengthGetter(Dcm_DiagSubServiceRefOptType sfRef)
{
  /* Return sub-function specific length. */
  return Dcm_CfgSvc86SubFuncInfo[sfRef].ReqLength;
}
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
/*lint -save -esym(961, 19.1)*/
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore*/
/* ----------------------------------------------
 ~&&&   Module API function implementations
---------------------------------------------- */
#define DCM_START_SEC_CODE
/*lint -save -esym(961, 19.1)*/
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore*/
#if (DCM_VERSION_INFO_API == STD_ON)
/**********************************************************************************************************************
 *  Dcm_GetVersionInfo()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_GetVersionInfo(P2VAR(Std_VersionInfoType, AUTOMATIC, DCM_APPL_DATA) versioninfo)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(versioninfo == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
# endif
  {
    versioninfo->vendorID = (uint16)DCM_VENDOR_ID;                                                                                                   /* SBSW_DCM_EXT_API_PARAM_PTR_WRITE_VERSIONINFO */
    versioninfo->moduleID = (uint16)DCM_MODULE_ID;                                                                                                   /* SBSW_DCM_EXT_API_PARAM_PTR_WRITE_VERSIONINFO */
    Dcm_VersionArEnvSetModuleInstance(versioninfo);                                                                                                  /* SBSW_DCM_EXT_API_PARAM_PTR_WRITE_VERSIONINFO */
    versioninfo->sw_major_version = (uint8)DCM_SW_MAJOR_VERSION;                                                                                     /* SBSW_DCM_EXT_API_PARAM_PTR_WRITE_VERSIONINFO */
    versioninfo->sw_minor_version = (uint8)DCM_SW_MINOR_VERSION;                                                                                     /* SBSW_DCM_EXT_API_PARAM_PTR_WRITE_VERSIONINFO */
    versioninfo->sw_patch_version = (uint8)DCM_SW_PATCH_VERSION;                                                                                     /* SBSW_DCM_EXT_API_PARAM_PTR_WRITE_VERSIONINFO */
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_GETVERSIONINFO, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}
#endif
#if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                          /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_TriggerTransmit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_TriggerTransmit(PduIdType txPduId
                                                  ,P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info)                                                /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
{
  Std_ReturnType lResult;
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)
  lResult = E_NOT_OK;

  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(txPduId >= Dcm_PbCfgNetNumTxPduIds)
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(info == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else if(info->SduDataPtr == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
#  if (DCM_NET_MULTI_CONNECT_ENABLED == STD_ON)
  if(Dcm_NetPeriodicMsgGetConnection() != Dcm_NetGetConnIdOfTxPduId(txPduId))
  {
    lErrorId = DCM_E_ILLEGAL_STATE;
  }
  else
#  endif
# endif
  {
# if(DCM_NET_MULTI_PERIODIC_TX_OBJ_ENABLED == STD_ON)
    DCM_NET_PTXOBJ_LOCVAR_DEF

    DCM_NET_PTXOBJ_LOCVAR_NAME = (DCM_NET_PTXOBJ_LOCVAR_TYPE)Dcm_NetPeriodicMsgGetHandleFromTxPduId(txPduId);
#  if (DCM_DEV_ERROR_DETECT == STD_ON)
    if(Dcm_NetPeriodicMsgNumMsgsCurrConnection() <= DCM_NET_PTXOBJ_LOCVAR_VALUE)
    {
      lErrorId = DCM_E_ILLEGAL_STATE;
    }
    else
#  endif
# endif
    {
      P2VAR(PduInfoType, AUTOMATIC, DCM_VAR_NOINIT) txPduInfoPtr = &(Dcm_PbRamNetPeriodicTxObject[DCM_NET_PTXOBJ_LOCVAR_VALUE].TxPduInfo);

      DCM_IGNORE_UNREF_PARAM(txPduId);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

      Dcm_UtiMemCopy(txPduInfoPtr->SduDataPtr, info->SduDataPtr, txPduInfoPtr->SduLength);                                                           /* PRQA S 3109 */ /* MD_MSR_14.3 */
      info->SduLength = txPduInfoPtr->SduLength;
      lResult = E_OK;
    }
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_TRIGGERTRANSMIT, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
  return lResult;
}                                                                                                                                                    /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */
#endif /*(DCM_NET_PERIODIC_TX_ENABLED == STD_ON)*/

/**********************************************************************************************************************
 *  Dcm_GetActiveProtocol()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_GetActiveProtocol(P2VAR(Dcm_ProtocolType, AUTOMATIC, DCM_APPL_DATA) ActiveProtocol)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

#if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                 /* COV_DCM_REQUIRED_BY_SAFEBSW TX */

  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(ActiveProtocol == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
#endif
  {
#if(DCM_NET_MULTI_PROTOCOL_ENABLED == STD_ON)                                                                                                        /* COV_DCM_UNSUPPORTED XF */
    if(Dcm_NetGetProtIdOfActiveProtocol() >= DCM_NET_INVALID_PROTID)
    {
      *ActiveProtocol = DCM_NO_ACTIVE_PROTOCOL;                                                                                                      /* SBSW_DCM_EXT_API_PARAM_PTR_WRITE_ACTIVEPROTOCOL */
    }
    else
#endif
    {
      *ActiveProtocol = Dcm_PbCfgNetProtocolInfo[Dcm_NetProtIdWrpValue(Dcm_NetGetProtIdOfActiveProtocol())].Id;                                      /* SBSW_DCM_EXT_API_PARAM_PTR_WRITE_ACTIVEPROTOCOL */
    }
  }

#if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_GETACTIVEPROTOCOL, lErrorId);
  }
#else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
#endif

  return DCM_E_OK;
}

/**********************************************************************************************************************
 *  Dcm_GetTesterSourceAddress()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_GetTesterSourceAddress(PduIdType DcmRxPduId
                                                         ,P2VAR(uint16, AUTOMATIC, DCM_APPL_DATA) TesterSourceAddress)
{
  Std_ReturnType lResult = DCM_E_NOT_OK;
  uint8          lErrorId = DCM_E_NO_ERROR;

#if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                 /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(TesterSourceAddress == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
#endif
  {
    if( (DcmRxPduId < Dcm_PbCfgNetNumRxPduIds)
#if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
      &&(Dcm_NetGetConnIdOfRxPduId(DcmRxPduId) < Dcm_PbCfgNetNumConnections) /* keep evaluation order to guard the connRef indirection */
#endif
      )
    {
      lResult = DCM_E_OK;
      *TesterSourceAddress = Dcm_PbCfgNetConnectionInfo[Dcm_NetGetConnIdOfRxPduId(DcmRxPduId)].ClientSrcAddr;                                        /* SBSW_DCM_EXT_API_PARAM_PTR_WRITE */
    }/*else - no data can be retrieved for wrong/inactive RxPduID */
  }

#if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_GETTESTERSOURCEADDRESS, lErrorId);
  }
#else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
#endif

  return lResult;
}

#if (DCM_DIAG_VIRTUAL_REQUEST_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ProcessVirtualRequest()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_ProcessVirtualRequest(PduIdType     RxPduId
                                                        ,Dcm_MsgType   Data
                                                        ,PduLengthType Length)
{
  Std_ReturnType lResult;
  uint8          lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  lResult = DCM_E_NOT_OK;

  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(Data == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else if (RxPduId >= Dcm_PbCfgNetNumRxPduIds)
  {
    lErrorId = DCM_E_PARAM;
  }
  else /*if (length > <BufferSize>)
  {
    This check is done through the Dcm_NetRxIndInternal API!
  }
  else */
# endif
  {
    lResult = Dcm_NetRxIndInternal(RxPduId, Data, Length);                                                                                           /* SBSW_DCM_EXT_API_PARAM_PTR_PASSED_THROUGH */
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_PROCESSVIRTUALREQUEST, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lResult;
}
#endif

/**********************************************************************************************************************
 *  Dcm_SetActiveDiagnostic()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_SetActiveDiagnostic(boolean active)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

#if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                 /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if ( (active != DCM_NET_COMM_ACTIVE)
          &&(active != DCM_NET_COMM_NOT_ACTIVE) )
  {
    lErrorId = DCM_E_PARAM;
  }
  else
#endif
  {
    /* #30 Enter critical section (Reason: API is reentrant). */
    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /* #40 Apply new ComM management state. */
    Dcm_SingletonContext.Network.ActiveDiagnostic = active;
    /* #50 Leave critical section. */
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }

#if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_SETACTIVEDIAGNOSTIC, lErrorId);
  }
#else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
#endif

  return DCM_E_OK;
}

/**********************************************************************************************************************
 *  Dcm_GetRequestKind()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_GetRequestKind(uint16 TesterSourceAddress
                                                 ,P2VAR(Dcm_RequestKindType, AUTOMATIC, DCM_APPL_DATA) RequestKind)
{
  Std_ReturnType lResult = DCM_E_NOT_OK;
  uint8 lErrorId = DCM_E_NO_ERROR;

#if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                 /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if (!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if (RequestKind == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
#endif
  {
    Dcm_NetConnRefMemType connId;

    connId = Dcm_NetGetConnIdByTesterAddress(TesterSourceAddress);

    /* #30 Check if the tester source address is a valid one. */
    if (connId < DCM_NET_INVALID_CONNID)
    {
      Dcm_CfgNetTObjHandleMemType tObjHdl;

      /* Asure that no interrupt will change the state of the conn2tobj map and the tobj state/flags */
      Dcm_UtiArEnvEnterCriticalSection();                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
      /*=================================*
      BEGIN CRITICAL SECTION
      *=================================*/
      tObjHdl = Dcm_NetGetTranspObjIdOfConnection(connId);

#if(DCM_NET_TRANSP_OBJ_DYN_ALLOC_ENABLED == STD_ON)
      /* On dynamic transport object allocation consider no assignment first! */
      if (tObjHdl >= DCM_NET_INVALID_TOBJID)
      {
        *RequestKind = DCM_REQ_KIND_NONE;
      }
      else
#endif
      {
        Dcm_NetTransportObjectPtrType pTranspObj = Dcm_NetGetTranspObjByHandle(tObjHdl);

        /* #50 If for this tester any request is ongoing: */
        if (pTranspObj->State != DCM_NET_TOBJ_STATE_FREE)
        {
#if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
          /* #60 Determine the kind of the request. */
          if ((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_INTERNAL) != 0)
          {
            *RequestKind = DCM_REQ_KIND_ROE;
          }
          else
#endif
          {
            *RequestKind = DCM_REQ_KIND_EXTERNAL;
          }
        }
        else
        {
          /* #70 Otherwise consider this tester idling. */
          *RequestKind = DCM_REQ_KIND_NONE;
        }
      }
      /*=================================*
      END CRITICAL SECTION
      *=================================*/
      Dcm_UtiArEnvLeaveCriticalSection();                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */

      lResult = DCM_E_OK;
    }/* else - result already set to NOT_OK */
  }

#if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_GETREQUESTKIND, lErrorId);
  }
#else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
#endif

  /* #200 Return the final result. */
  return lResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)                                                                                                  /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_ComM_NoComModeEntered()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_ComM_NoComModeEntered(void)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
# endif
  {
    Dcm_UtiArEnvEnterCriticalSection(); /* Avoid concurrent access on registerNetworks from an interrupt  */                                         /* PRQA S 3109 */ /* MD_MSR_14.3 */
    Dcm_PbRamNetComMContext[0].ComState = DCM_NET_COMM_STATE_RX_DIS_TX_DIS;
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_COMMENTERNOCOMMODE, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}

/**********************************************************************************************************************
 *  Dcm_ComM_SilentComModeEntered()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_ComM_SilentComModeEntered(void)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
# endif
  {
    Dcm_UtiArEnvEnterCriticalSection(); /* Avoid concurrent access on registerNetworks from an interrupt  */                                         /* PRQA S 3109 */ /* MD_MSR_14.3 */
    Dcm_PbRamNetComMContext[0].ComState = DCM_NET_COMM_STATE_RX_EN_TX_DIS;
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_COMMENTERSILENTCOMMODE, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}

/**********************************************************************************************************************
 *  Dcm_ComM_FullComModeEntered()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_ComM_FullComModeEntered(void)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
# endif
  {
    Dcm_UtiArEnvEnterCriticalSection(); /* Avoid concurrent access on registerNetworks from an interrupt  */                                         /* PRQA S 3109 */ /* MD_MSR_14.3 */
    Dcm_PbRamNetComMContext[0].ComState = DCM_NET_COMM_STATE_RX_EN_TX_EN;
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_COMMENTERFULLCOMMODE, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}

/**********************************************************************************************************************
 *  Dcm_ProvideRxBuffer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(BufReq_ReturnType, DCM_CODE) Dcm_ProvideRxBuffer(PduIdType DcmRxPduId
                                                     ,PduLengthType TpSduLength
                                                     ,P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) *PduInfoPtr)
{
  BufReq_ReturnType lResult;
  uint8             lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)
  lResult = BUFREQ_E_NOT_OK;

  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(PduInfoPtr == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
#  if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
  /* checked within the Dcm_NetProvideRxBuffer */
#  else
  if(DcmRxPduId >= Dcm_PbCfgNetNumRxPduIds)
  {
    lErrorId = DCM_E_PARAM;
  }
  else
#  endif
# endif
  {
    lResult = Dcm_NetProvideRxBuffer(DcmRxPduId, TpSduLength, PduInfoPtr, DCM_NET_TOBJ_FLAG_NONE);
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_PROVIDERXBUFFER, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lResult;
}

/**********************************************************************************************************************
 *  Dcm_RxIndication()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_RxIndication(PduIdType DcmRxPduId
                                     ,Dcm_NetArEnvNotifResultType Result)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
#  if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
  /* This API may be called also even StartOfReception has returned NOT_OK! */
#  else
  if(DcmRxPduId >= Dcm_PbCfgNetNumRxPduIds)
  {
    lErrorId = DCM_E_PARAM;
  }
  else
#  endif
# endif
  {
# if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
    /* This API may be called also even StartOfReception has returned NOT_OK! */
    if( (DcmRxPduId < Dcm_PbCfgNetNumRxPduIds)
      &&(Dcm_NetGetConnIdOfRxPduId(DcmRxPduId) < Dcm_PbCfgNetNumConnections) ) /* keep evaluation order to guard the connRef indirection */
# endif
    {
      Dcm_CfgNetTObjHandleMemType tObjHdl = Dcm_NetGetTranspObjIdOfRxPduId(DcmRxPduId);

# if(DCM_NET_TRANSP_OBJ_DYN_ALLOC_ENABLED == STD_ON)
      if(tObjHdl >= DCM_NET_INVALID_TOBJID)
      {
        /* just ignore in case the DCM_E_NOT_OK from ProvideRxBuffer has lead to the RxIndication (AR does not specify what will happen after this)*/
      }
      else
# endif
      {
        Dcm_NetTransportObjectPtrType pTranspObj = Dcm_NetGetTranspObjByHandle(tObjHdl);
        if(pTranspObj->State == DCM_NET_TOBJ_STATE_ONRX)/* expected state for RX indication? */
        {
          /* Consider also any nested request on different TP connection but from the same tester! */
          if(DcmRxPduId == pTranspObj->RxPduId)
          {
            if(Result != DCM_NET_ARENV_NTFRSLT_OK)
            {
              Dcm_NetTpRxIndicationNotOk(pTranspObj);
            }
            else
            {
              Dcm_NetTpRxIndicationOk(pTranspObj);
            }
          }/*else - indication of unexpected connection */
        }/* else- could be an unexpected API call but most probably it is due to a concurrent request (StartOfReception returns DCM_E_NOT_OK) from the same tester */
      }
    }
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_RXINDICATION, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}                                                                                                                                                    /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_ProvideTxBuffer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(BufReq_ReturnType, DCM_CODE) Dcm_ProvideTxBuffer(PduIdType DcmTxPduId
                                                     ,P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) *PduInfoPtr
                                                     ,PduLengthType Length)
{
  BufReq_ReturnType lResult = BUFREQ_E_NOT_OK;
  uint8             lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(DcmTxPduId >= Dcm_PbCfgNetNumTxPduIds)
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(PduInfoPtr == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
#  if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
    /* This API shall not be called when Transmit has not been called on a deleted connection! */
  if(Dcm_NetGetConnIdOfTxPduId(DcmTxPduId) >= Dcm_PbCfgNetNumConnections)
  {
     lErrorId = DCM_E_PARAM;
  }
  else
#  endif
# endif
  {
    Dcm_CfgNetTObjHandleMemType tObjHdl = Dcm_NetGetTranspObjIdOfTxPduId(DcmTxPduId);

    DCM_IGNORE_UNREF_PARAM(DcmTxPduId);                                                                                                              /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_DEV_ERROR_DETECT == STD_ON)
#  if(DCM_NET_TRANSP_OBJ_DYN_ALLOC_ENABLED == STD_ON)
    if(tObjHdl >= DCM_NET_INVALID_TOBJID)
    {
      lErrorId = DCM_E_ILLEGAL_STATE;
    }
    else
#  endif
# endif
    {
      Dcm_NetTransportObjectPtrType pTranspObj = Dcm_NetGetTranspObjByHandle(tObjHdl);
      /* Check always for valid call state - if free or skip -> ignore call
        * This check is necessary in case Dcm_Init is called some time during ongoing transmission or
        * The ongoing transmission is set to "canceled" (pending TxCancelation)! */
      if( (pTranspObj->State == DCM_NET_TOBJ_STATE_ONTX)
# if (DCM_NET_PROCESSING_CANCELLATION_ENABLED == STD_ON)
        &&((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_CANCELED) == 0)
# endif
        )
      {
# if(DCM_PAGED_BUFFER_ENABLED == STD_ON)
        if(pTranspObj->ResType == DCM_NET_TOBJ_RESTYPE_PAGED)
        {
          lResult = Dcm_PagedBufferCopyData(&pTranspObj->BuffInfo, Length);
        }
        else
# endif
        {
          DCM_IGNORE_UNREF_PARAM(Length);                                                                                                            /* PRQA S 3112 */ /* MD_Dcm_3112 */
          /* Linear case */
          /* the current buffer is the only one */
          lResult = BUFREQ_OK;
        }

        /* set PduInfo, just in case this is the first call */
        *PduInfoPtr = &(pTranspObj->BuffInfo);
      }
    }
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_PROVIDETXBUFFER, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lResult;
}                                                                                                                                                    /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_TxConfirmation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_TxConfirmation(PduIdType DcmTxPduId
                                       ,NotifResultType Result)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  DCM_IGNORE_UNREF_PARAM(DcmTxPduId);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_DEV_ERROR_DETECT == STD_ON)
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(DcmTxPduId >= Dcm_PbCfgNetNumTxPduIds)
  {
    lErrorId = DCM_E_PARAM;
  }
  else if (Dcm_NetGetConnIdOfTxPduId(DcmTxPduId) >= Dcm_PbCfgNetNumConnections)
  {
    /* This API shall not be called when Transmit has not been called on a deleted connection! */
    lErrorId = DCM_E_PARAM;
  }
  else
# endif
  {
# if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)
    /* check if TxPdu is main TxPdu (which is used for TP communication)  */
    /* Note: in ASR3, the TxPdu is identical to the TxConfPdu             */
    if (Dcm_PbCfgNetConnectionInfo[Dcm_NetGetConnIdOfTxPduId(DcmTxPduId)].TxPduIdMain != DcmTxPduId)
    {
#  if(DCM_NET_MULTI_CONNECT_ENABLED == STD_ON)
      if(Dcm_NetPeriodicMsgGetConnection() != Dcm_NetGetConnIdOfTxPduId(DcmTxPduId))
      {
        lErrorId = DCM_E_ILLEGAL_STATE;
      }
      else
#  endif
#  if(DCM_NET_MULTI_PERIODIC_TX_OBJ_ENABLED == STD_ON)
      if(Dcm_NetPeriodicMsgGetHandleFromTxPduId(DcmTxPduId) >= Dcm_NetPeriodicMsgNumMsgsCurrConnection())
      {
        lErrorId = DCM_E_ILLEGAL_STATE;
      }
      else
#  endif
      {
        /* confirmation of IF transmission */
        Dcm_NetPeriodicMsgRelease(Dcm_NetPTxObjWrpOnly(Dcm_NetPeriodicMsgGetHandleFromTxPduId(DcmTxPduId)));
      }
    }
    else
# endif /*(DCM_NET_PERIODIC_TX_ENABLED == STD_ON)*/
    {
      /* confirmation of TP transmission */
      Dcm_NetTpTxConfirmation(DcmTxPduId, Result);
    }
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_TXCONFIRMATION, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}                                                                                                                                                    /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)                                                                                                  /* COV_DCM_SUPPORT_PARTIALLY TX tx xf */
/**********************************************************************************************************************
 *  Dcm_ComM_NoComModeEntered()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_ComM_NoComModeEntered(NetworkHandleType networkId)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
# endif
  {
    Dcm_NetSetComModeEntered(networkId, DCM_NET_COMM_STATE_RX_DIS_TX_DIS);
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_COMMENTERNOCOMMODE, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}

/**********************************************************************************************************************
 *  Dcm_ComM_SilentComModeEntered()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_ComM_SilentComModeEntered(NetworkHandleType networkId)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
# endif
  {
    Dcm_NetSetComModeEntered(networkId, DCM_NET_COMM_STATE_RX_EN_TX_DIS);
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_COMMENTERSILENTCOMMODE, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}

/**********************************************************************************************************************
 *  Dcm_ComM_FullComModeEntered()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_ComM_FullComModeEntered(NetworkHandleType networkId)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
# endif
  {
    Dcm_NetSetComModeEntered(networkId, DCM_NET_COMM_STATE_RX_EN_TX_EN);
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_COMMENTERFULLCOMMODE, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}

# if (DCM_NET_MONITOR_FOREIGN_N_TA_ENABLED == STD_ON)                                                                                                /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_OnRequestDetection()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_OnRequestDetection(PduIdType canTpRxPduId
                                           ,uint8 tpAddrExtension)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

#  if (DCM_DEV_ERROR_DETECT == STD_ON)
  /* #10 Check whether the module is initialized. */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
#  endif
  {
    /* #20 Check whether the CanTpPduId is between the upper and lower bound of DCM CanTpPduIds. */
    if(
#  if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
        (Dcm_PbCfgNetNumCanRxPduIds > 0) &&  /* Check for a non-empty map */
#  endif
        ( (canTpRxPduId >= Dcm_PbCfgNetCanTpRxPduIdMin)
        &&(canTpRxPduId <= Dcm_PbCfgNetCanTpRxPduIdMax) )
      )
    {
      PduIdType lDcmRxPduId;

      /* #30 Retrieve the DCM RxPduId from the CanTp PduId. */
      lDcmRxPduId = Dcm_NetGetDcmRxPduIdOfCanTpPduId(canTpRxPduId);

      /* #40 Check for DCM connection on this SDU. */
      if(lDcmRxPduId < Dcm_PbCfgNetNumRxPduIds)
      {
        DCM_NETCONNID_LOCVAR_DEF
#  if (DCM_NET_MULTI_CONNECT_ENABLED == STD_ON)
        DCM_NETCONNID_LOCVAR_NAME = Dcm_NetGetConnIdOfRxPduId(lDcmRxPduId);
#  endif
        /* #50 Compare the N_TA with the own ECU address. React only on external ECU requests. */
        if(Dcm_NetGetNodeAddress(DCM_NETCONNID_LOCVAR_NAME) != tpAddrExtension)
        {
          Dcm_NetOnRequestDetection(Dcm_NetConnIdWrpOnly(DCM_NETCONNID_LOCVAR_NAME));
        }/* else - a DcmPduId and the same N_TA -> request will be ignored on task level */
      }/* else - not a DcmPduId or a functional DcmPduId -> ignore */
    }/* else - not a DcmPduId -> ignore */
  }

#  if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_ONREQUESTDETECTION, lErrorId);
  }
#  else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
#  endif
}
# endif

/**********************************************************************************************************************
 *  Dcm_StartOfReception()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(BufReq_ReturnType, DCM_CODE) Dcm_StartOfReception(PduIdType rxPduId
# if (DCM_PDUR_API_412_ENABLED == STD_ON)                                                                                                            /* COV_DCM_SUPPORT_ALWAYS TX */
                                                      ,P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info                                             /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
# endif
                                                      ,PduLengthType tpSduLength
                                                      ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) bufferSizePtr)
{
  BufReq_ReturnType lResult;
  uint8             lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  lResult = BUFREQ_E_NOT_OK;

  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(bufferSizePtr == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
#  if (DCM_PDUR_API_412_ENABLED == STD_ON)                                                                                                           /* COV_DCM_SUPPORT_ALWAYS TX */
  /* infoPool and meta-data not supported yet -> must always be NULL_PTR for DCM PDUs */
  if(info != NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
#  endif
#  if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
  /* check performed in the Dcm_NetStartOfReception */
#  else
  if(rxPduId >= Dcm_PbCfgNetNumRxPduIds)
  {
    lErrorId = DCM_E_PARAM;
  }
  else
#  endif
# endif
  {
# if (DCM_PDUR_API_412_ENABLED == STD_ON)                                                                                                            /* COV_DCM_SUPPORT_ALWAYS TX */
    DCM_IGNORE_UNREF_PARAM(info);                                                                                                                    /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
    lResult = Dcm_NetStartOfReception(rxPduId, tpSduLength, bufferSizePtr, DCM_NET_TOBJ_FLAG_NONE);                                                  /* SBSW_DCM_EXT_API_PARAM_PTR_PASSED_THROUGH */
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_STARTOFRECEPTION, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lResult;
}                                                                                                                                                    /* PRQA S 6010, 6030 */ /* MD_MSR_STPTH, MD_MSR_STCYC */

/**********************************************************************************************************************
 *  Dcm_CopyRxData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(BufReq_ReturnType, DCM_CODE) Dcm_CopyRxData(PduIdType rxPduId
                                                ,P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info                                                   /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) bufferSizePtr)
{
  BufReq_ReturnType           lResult;
  uint8                       lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  lResult = BUFREQ_E_NOT_OK;

  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(info == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else if( (info->SduLength  != 0)
         &&(info->SduDataPtr == NULL_PTR) )
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else if(bufferSizePtr == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else if(rxPduId >= Dcm_PbCfgNetNumRxPduIds)
  {
    lErrorId = DCM_E_PARAM;
  }
  else
# endif
  {
    DCM_IGNORE_UNREF_PARAM(rxPduId);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
#  if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
    if(Dcm_NetGetConnIdOfRxPduId(rxPduId) >= Dcm_PbCfgNetNumConnections)     /* This API shall not be called when StartOfReception has returned NOT_OK! */
    {
      lErrorId = DCM_E_PARAM;
    }
    else
#  endif
# endif
    {
      Dcm_CfgNetTObjHandleMemType tObjHdl;
      tObjHdl = Dcm_NetGetTranspObjIdOfRxPduId(rxPduId);

      /* Check always for valid call state - if free or ready -> ignore call
      * This check is necessary in case Dcm_Init is called some time during ongoing transmission
      */
# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
#  if(DCM_NET_TRANSP_OBJ_DYN_ALLOC_ENABLED == STD_ON)
      if(tObjHdl >= DCM_NET_INVALID_TOBJID)
      {
        /* Check for valid call state */
        lErrorId = DCM_E_ILLEGAL_STATE;
      }
      else
#  endif
# endif
      {
        Dcm_NetTransportObjectPtrType pTranspObj = Dcm_NetGetTranspObjByHandle(tObjHdl);
        Dcm_DebugAssert((rxPduId == pTranspObj->RxPduId), DCM_SID_COPYRXDATA, DCM_E_ILLEGAL_STATE)                                                   /* COV_DCM_RTM_DEV_DEBUG XF */

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
        if((DCM_NET_TOBJ_STATE_ONRX & pTranspObj->State) == 0)/* expected state for copy RX? */
        {
          lErrorId = DCM_E_ILLEGAL_STATE;
        }
        else
# endif
        {
          lResult = Dcm_NetCopyRxData(pTranspObj, info, bufferSizePtr);
        }
      }
    }
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_COPYRXDATA, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_TpRxIndication()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_TpRxIndication(PduIdType rxPduId
                                       ,Dcm_NetArEnvNotifResultType result)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
#  if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
  /* a disabled rxPduId */
#  else
  if(rxPduId >= Dcm_PbCfgNetNumRxPduIds)
  {
    lErrorId = DCM_E_PARAM;
  }
  else
#  endif
# endif
  {
# if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
    /* This API may be called also even StartOfReception has returned NOT_OK! */
    if( (rxPduId < Dcm_PbCfgNetNumRxPduIds)
      &&(Dcm_NetGetConnIdOfRxPduId(rxPduId) < Dcm_PbCfgNetNumConnections) ) /* keep evaluation order to guard the connRef indirection */
# endif
    {
      Dcm_NetTpRxIndication(rxPduId, result);
    }
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_TPRXINDICATION, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}

/**********************************************************************************************************************
 *  Dcm_CopyTxData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(BufReq_ReturnType, DCM_CODE) Dcm_CopyTxData(PduIdType txPduId
                                                ,P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) info                                                   /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
                                                ,P2VAR(RetryInfoType, AUTOMATIC, DCM_APPL_DATA) retry                                                /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                ,P2VAR(PduLengthType, AUTOMATIC, DCM_APPL_DATA) availableDataPtr)
{
  BufReq_ReturnType lResult;
  uint8             lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  lResult = BUFREQ_E_NOT_OK;

  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(txPduId >= Dcm_PbCfgNetNumTxPduIds)
  {
    lErrorId = DCM_E_PARAM;
  }
  else if(info == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else if( (info->SduLength  != 0)
         &&(info->SduDataPtr == NULL_PTR) )
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else if(availableDataPtr == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else if( (retry != NULL_PTR) /* else - if(retry == NULL_PTR) -> not used => OK */
         &&(retry->TpDataState != TP_DATACONF) )
  {
    lErrorId = DCM_E_PARAM;
  }
  else
#  if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
  if(Dcm_NetGetConnIdOfTxPduId(txPduId) >= Dcm_PbCfgNetNumConnections)
  {
    lErrorId = DCM_E_PARAM;
  }
  else
#  endif
# endif
  {
    Dcm_CfgNetTObjHandleMemType tObjHdl = Dcm_NetGetTranspObjIdOfTxPduId(txPduId);

    DCM_IGNORE_UNREF_PARAM(txPduId);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */
    DCM_IGNORE_UNREF_PARAM(retry);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
#  if(DCM_NET_TRANSP_OBJ_DYN_ALLOC_ENABLED == STD_ON)
    if(tObjHdl >= DCM_NET_INVALID_TOBJID)
    {
      /* Check for valid call state */
      lErrorId = DCM_E_ILLEGAL_STATE;
    }
    else
#  endif
# endif
    {
      Dcm_NetTransportObjectPtrType pTranspObj = Dcm_NetGetTranspObjByHandle(tObjHdl);
# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
      if((DCM_NET_TOBJ_STATE_ONTX & pTranspObj->State) == 0)
      {
        lErrorId = DCM_E_ILLEGAL_STATE;
      }
      else
# endif
      {
        lResult = Dcm_NetCopyTxData(pTranspObj, info, availableDataPtr);
      }
    }
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_COPYTXDATA, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lResult;
}                                                                                                                                                    /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_TpTxConfirmation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_TpTxConfirmation(PduIdType txPduId
                                         ,Dcm_NetArEnvNotifResultType result)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  DCM_IGNORE_UNREF_PARAM(txPduId);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(txPduId >= Dcm_PbCfgNetNumTxPduIds)
  {
    lErrorId = DCM_E_PARAM;
  }
  else
#  if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
    /* This API shall not be called when Transmit has not been called on a deleted connection! */
  if(Dcm_NetGetConnIdOfTxPduId(txPduId) >= Dcm_PbCfgNetNumConnections)
  {
    lErrorId = DCM_E_PARAM;
  }
  else
#  endif
# endif
  {
    Dcm_CfgNetTObjHandleMemType tObjHdl = Dcm_NetGetTranspObjIdOfTxPduId(txPduId);

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
#  if(DCM_NET_TRANSP_OBJ_DYN_ALLOC_ENABLED == STD_ON)
    if(tObjHdl >= DCM_NET_INVALID_TOBJID)
    {
      lErrorId = DCM_E_ILLEGAL_STATE;
    }
    else
#  endif
# endif
    {
      Dcm_NetTransportObjectPtrType pTranspObj = Dcm_NetGetTranspObjByHandle(tObjHdl);
# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
      if((DCM_NET_TOBJ_STATE_ONTX & pTranspObj->State) == 0)
      {
        lErrorId = DCM_E_ILLEGAL_STATE;
      }
      else
# endif
      {
        Dcm_NetUsdtTxConfirmation(pTranspObj, Dcm_NetArEnvGetTransmResult(result));
      }
    }
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_TPTXCONFIRMATION, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */

/**********************************************************************************************************************
 *  Dcm_TxConfirmation()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_TxConfirmation(PduIdType txPduId)
{
# if (DCM_NET_PERIODIC_TX_ENABLED == STD_ON)                                                                                                         /* COV_DCM_UNSUPPORTED XF */
  uint8 lErrorId = DCM_E_NO_ERROR;

  DCM_IGNORE_UNREF_PARAM(txPduId);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

#  if (DCM_DEV_ERROR_DETECT == STD_ON)
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(txPduId >= Dcm_PbCfgNetNumTxPduIds)
  {
    lErrorId = DCM_E_PARAM;
  }
  else
#   if(DCM_NET_MULTI_CONNECT_ENABLED == STD_ON)
  if(Dcm_NetPeriodicMsgGetConnection() != Dcm_NetGetConnIdOfTxPduId(txPduId))
  {
    lErrorId = DCM_E_ILLEGAL_STATE;
  }
  else
#   endif
#   if(DCM_NET_MULTI_PERIODIC_TX_OBJ_ENABLED == STD_ON)
  if(Dcm_NetPeriodicMsgGetHandleFromTxPduId(txPduId) >= Dcm_NetPeriodicMsgNumMsgsCurrConnection())
  {
    lErrorId = DCM_E_ILLEGAL_STATE;
  }
  else
#   endif
#  endif /* (DCM_DEV_ERROR_DETECT == STD_ON) */
  {
    Dcm_NetPeriodicMsgRelease(Dcm_NetPTxObjWrpOnly(Dcm_NetPeriodicMsgGetHandleFromTxPduId(txPduId)));
  }

#  if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_TXCONFIRMATION, lErrorId);
  }
#  else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
#  endif
# else
  /* Function is not used since 0x2A or periodic messages are not available.
   * Note: PduR may still need this API to be able to link in case periodic messages are available, but SID 0x2A shall
   * not be supported.
   */
  DCM_IGNORE_UNREF_PARAM(txPduId);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif /*(DCM_NET_PERIODIC_TX_ENABLED == STD_ON)*/
}
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_ResetToDefaultSession()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_ResetToDefaultSession(void)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

#if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                 /* COV_DCM_REQUIRED_BY_SAFEBSW TX */

  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
#endif
  {
    /* Just initiate resetting the ECU to the default session */
    Dcm_TskSetEvent(DCM_TSK_ID_DIAG_WORK, DCM_TSK_EV_DIAG_WORK_EXT_SET2DEF);
  }

#if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_RESET2DEFAULTSESSION, lErrorId);
  }
#else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
#endif
  return DCM_E_OK;
}

/**********************************************************************************************************************
 *  Dcm_GetSesCtrlType()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_GetSesCtrlType(P2VAR(Dcm_SesCtrlType, AUTOMATIC, DCM_APPL_DATA) SesCtrlType)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

#if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                 /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(SesCtrlType == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
#endif
  {
    *SesCtrlType = Dcm_CfgStateSessionInfo[Dcm_UtiGetBitPosition(Dcm_SingletonContext.StateMgr.Preconditions.Session)].Value;
  }

#if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_GETSESCTRLTYPE, lErrorId);
  }
#else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
#endif

  return DCM_E_OK;
}

#if (DCM_STATE_SECURITY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_GetSecurityLevel()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_GetSecurityLevel(P2VAR(Dcm_SecLevelType, AUTOMATIC, DCM_APPL_DATA) SecLevel)
{
  uint8          lErrorId = DCM_E_NO_ERROR;
  uint8          stateIdx = Dcm_UtiGetBitPosition(Dcm_SingletonContext.StateMgr.Preconditions.Security);

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(SecLevel == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
# endif
  {
    *SecLevel = Dcm_StateGetSecurityValue(stateIdx);
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_GETSECLEVEL, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return DCM_E_OK;
}
#endif

#if (DCM_STATE_SECURITY_EXT_SETTER_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_SetSecurityLevel()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_SetSecurityLevel(Dcm_SecLevelType SecLevel)
{
  Std_ReturnType lResult;
  uint8          lErrorId = DCM_E_NO_ERROR;
  sint8_least    lStateIdx;

  /* #10 Convert security access level to internal zero based security access state handle. */
  lStateIdx = Dcm_StateFindStateIndexFromSecLevel(SecLevel);/* Calling this API is safe since it does not depend on any internal DCM state (no initialization is needed!) */

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  lResult = DCM_E_NOT_OK;

  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if (lStateIdx < 0)
  {
    lErrorId = DCM_E_PARAM;
  }
  else
# endif
  {
# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
    /* #50 Check for valid API call context. */

    /* Protect against any ISR or higher priority tasks */
    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */

    if(Dcm_TskTraceIsEmpty())
    {
      /* No task active: this API is called outside of any DCM main-function context! */
      lErrorId = DCM_E_ILLEGAL_STATE;
    }
    else if(Dcm_TskTraceGetCurrTskId() != DCM_TSK_ID_DIAG_WORK)
    {
      /* A task is active, but not the correct one: worker task with low priority! */
      lErrorId = DCM_E_ILLEGAL_STATE;
    }
    else
    {
      /* Needed by MISRA */
    }
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */

    if(lErrorId == DCM_E_NO_ERROR)
# endif
    {
      Dcm_StateSetSecurity((Dcm_StateIndexOptType)lStateIdx);
      lResult = DCM_E_OK;
    }
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_SETSECLEVEL, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lResult;
}
#endif

#if (DCM_STATE_SECURITY_FIXED_BYTES_ENABLED == STD_ON)                                                                                               /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_GetSecurityLevelFixedBytes()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_GetSecurityLevelFixedBytes(Dcm_SecLevelType SecLevel
                                                             ,P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) FixedBytes
                                                             ,P2VAR(uint8, AUTOMATIC, DCM_APPL_DATA) BufferSize)
{
  Std_ReturnType  lResult;
  uint8           lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)
  lResult = DCM_E_NOT_OK;

  if (!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if ((FixedBytes == NULL_PTR) || (BufferSize == NULL_PTR))
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
# endif
  {
    lResult = Dcm_StateGetSecurityLevelFixedBytes(SecLevel, FixedBytes, BufferSize);
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_GETSECLEVELFIXEDBYTES, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lResult;
}
#endif
/**********************************************************************************************************************
 *  Dcm_InitMemory()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_InitMemory(void)
{
  /* Destroy default RAM content of all DCM variables (for uninitialized global variable revelation). */
  Dcm_UtiRamShredder(Dcm_SingletonContext, DCM_VAR_NOINIT);                                                                                          /* PRQA S 0310, 3109 */ /* MD_Dcm_DifferentPointerType_0310, MD_MSR_14.3 */
  Dcm_UtiRamShredder(Dcm_InstanceContext,  DCM_VAR_NOINIT);                                                                                          /* PRQA S 0310, 3109 */ /* MD_Dcm_DifferentPointerType_0310, MD_MSR_14.3 */

  /* Initialize memory of sub-components. */
  Dcm_DebugInitMemory(); /* Initialize first to start monitoring the module initialization */
}

/**********************************************************************************************************************
 *  Dcm_Init()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_Init(Dcm_ConfigPtrType configPtr)
{
  DCM_IGNORE_UNREF_PARAM(configPtr);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

#if (DCM_VARMGR_SUPPORT_ENABLED == STD_ON)
  if(Dcm_VarMgrInit(configPtr) == TRUE)
#endif
  {
    /* Initialize run-time kernel sub-system. */
    Dcm_TmrInit();
    Dcm_TskInit();

    /* Initialize communication sub-systems. */
    Dcm_NetInit();
    Dcm_PagedBufferInit();

    /* Initialize diagnostic service helpers sub-systems. */
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
    Dcm_DidMgrInit();
#endif
#if (DCM_MEMMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
    Dcm_MemMgrInit();
#endif

    /* Initialize diagnostic state management sub-systems. */
    Dcm_ModeInit();
    Dcm_StateInit();

    /* Initialize diagnostic service processing kernel sub-system. */
    Dcm_DiagInit();

    /* Initialize debug sub-component as last to mark DCM as completely initialized. */
    Dcm_DebugInit();/* from now on the DCM is ready to work */
  }
}                                                                                                                                                    /* PRQA S 6050 */ /* MD_MSR_STCAL */

/**********************************************************************************************************************
 *  Dcm_DeInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_DeInit(void)
{
  /* #10 Uninitialize all related sub-components (currently only "Debug" since it provides the central component initialized guard). */
  Dcm_DebugDeInit();
}

#if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_MainFunctionTimer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_MainFunctionTimer(void)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
  {
    Dcm_TskScheduler(DCM_TSK_PRIO_HIGH);
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_MAINFUNCTION, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}
#endif

#if (DCM_SPLIT_TASKS_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_MainFunctionWorker()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_MainFunctionWorker(void)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
  {
    Dcm_TskScheduler(DCM_TSK_PRIO_LOW);
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_MAINFUNCTION, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}
#endif

#if (DCM_SPLIT_TASKS_ENABLED == STD_OFF)
/**********************************************************************************************************************
 *  Dcm_MainFunction()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_MainFunction(void)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
  {
    Dcm_TskScheduler(DCM_TSK_PRIO_LOW);
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_MAINFUNCTION, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}
#endif
#if(DCM_DIAG_EXTERN_SVC_HANDLING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OptimizedProcessingDone()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_OptimizedProcessingDone(void)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
# endif
  {
    Dcm_ProcessingDone();
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_EXT_PROCESSINGDONE, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}
#endif

#if(DCM_DIAG_EXTERN_SVC_HANDLING_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_OptimizedSetNegResponse()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_OptimizedSetNegResponse(Dcm_NegativeResponseCodeType errorCode)
{
  uint8 lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)                                                                                                                /* COV_DCM_REQUIRED_BY_SAFEBSW TX */
  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else
# endif
  {
    Dcm_SetNegResponse(errorCode);
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_EXT_PROCESSINGDONE, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
}
#endif

#if (DCM_DIAG_STATE_RECOVERY_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_ProvideRecoveryStates()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_ProvideRecoveryStates(
                                                    P2VAR(Dcm_RecoveryInfoType, AUTOMATIC, DCM_APPL_DATA) RecoveryInfo)
{
  Std_ReturnType  lResult;
  uint8           lErrorId = DCM_E_NO_ERROR;

# if (DCM_DEV_ERROR_DETECT == STD_ON)
  lResult = DCM_E_NOT_OK;

  if(!Dcm_DebugOptIsModuleInitialized())
  {
    lErrorId = DCM_E_UNINIT;
  }
  else if(RecoveryInfo == NULL_PTR)
  {
    lErrorId = DCM_E_PARAM_POINTER;
  }
  else
# endif
  {
    Dcm_DiagProvideRecoveryStates(RecoveryInfo);
    lResult = DCM_E_OK;
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_PROVIDERECOVERYSTATES, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lResult;
}
#endif
#define DCM_STOP_SEC_CODE
/*lint -save -esym(961, 19.1)*/
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore*/
/* ----------------------------------------------
 ~&&&   Module internal API function implementations
---------------------------------------------- */
#define DCM_START_SEC_CODE
/*lint -save -esym(961, 19.1)*/
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore*/
#if (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                      /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrReadSupportedId()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgrReadSupportedId(uint32 maskValue, Dcm_MsgType resData)
{
  resData[0] = Dcm_UtiGetHiHiByte(maskValue);
  resData[1] = Dcm_UtiGetHiLoByte(maskValue);
  resData[2] = Dcm_UtiGetLoHiByte(maskValue);
  resData[3] = Dcm_UtiGetLoLoByte(maskValue);
  return DCM_E_OK;
}

# if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DCM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrReadUdsMid()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgrReadUdsMid(Dcm_ObdIdMgrHandleMemType handle
                                                     ,Dcm_OpStatusType opStatus
                                                     ,Dcm_MsgType resData)
{
  Std_ReturnType     lResult = DCM_E_OK; /* if no data to be returned -> positive response (same as Mode 0x06) */
  uint16             lTestValue;
  uint16             lMinLimit;
  uint16             lMaxLimit;
  Dcm_DTRStatusType  lStatus;

  /* data MID -> only one possible */
  P2CONST(Dcm_CfgSvc06MidTidInfoType, AUTOMATIC, DCM_CONST) tidObject = &Dcm_CfgSvc06MidTidInfoTable[Dcm_CfgSvc06Mid2TidRefMap[handle]];
  Dcm_CfgSvc06Mid2TidRefOptType numTids = (Dcm_CfgSvc06Mid2TidRefOptType)( Dcm_CfgSvc06Mid2TidRefMap[handle + 1]
                                                                         - Dcm_CfgSvc06Mid2TidRefMap[handle + 0]);

  for(; numTids != 0; --numTids)
  {
    lResult = tidObject->OpFunc(opStatus, &lTestValue, &lMinLimit, &lMaxLimit, &lStatus);
    if(lResult == DCM_E_OK)
    {
      if(lStatus == DCM_DTRSTATUS_INVISIBLE)
      {
        lTestValue = 0;
        lMinLimit  = 0;
        lMaxLimit  = 0;
      }

      /* Copy data */
      resData[0] = tidObject->Tid;

      resData[1] = tidObject->Uasid;

      resData[2] = Dcm_UtiGetHiByte(lTestValue);
      resData[3] = Dcm_UtiGetLoByte(lTestValue);

      resData[4] = Dcm_UtiGetHiByte(lMinLimit);
      resData[5] = Dcm_UtiGetLoByte(lMinLimit);

      resData[6] = Dcm_UtiGetHiByte(lMaxLimit);
      resData[7] = Dcm_UtiGetLoByte(lMaxLimit);

      Dcm_UtiNextItemByPtr(resData, 8u);/* move to next block of response */
      Dcm_UtiNextItemByPtr(tidObject,1u);/* next MIDTID object */
    }
    else
    {
      break;
    }
  }

  return lResult;
}
# endif

# if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgr_F6XX_IsDidAvailable()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgr_F6XX_IsDidAvailable(uint16 DID
                                                    ,Dcm_OpStatusType OpStatus
                                                    ,P2VAR(Dcm_DidSupportedType, AUTOMATIC, DCM_VAR_NOINIT) supported)
{
  uint8 lOBDMid = Dcm_UtiGetLoByte(DID);

  DCM_IGNORE_UNREF_PARAM(OpStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  *supported = DCM_DID_NOT_SUPPORTED;

  /* #10 Check kind of DID (Availability ID or Data ID)*/
  if (Dcm_ObdIdMgrIsAvailabilityId(DID))
  {
    uint32 lObdMidAvailMask;

    /* #20 If DID is a availability ID  */
    /* #30 Request value of availabity ID from Dem */
    if (Dem_DcmGetAvailableOBDMIDs(lOBDMid, &lObdMidAvailMask) == E_OK)
    {
      /* #40 If request ist successful */
      /* #50 Report to caller that DID is available */
      *supported = DCM_DID_SUPPORTED;
    }
  }
  else
  {
    uint8 lNumOfTIDs;

    /* #60 If DID is Data ID */
    /* #70 Request number of TIDs for Data ID */
    if (Dem_DcmGetNumTIDsOfOBDMID(lOBDMid, &lNumOfTIDs) == E_OK)
    {
      /* #80 If request is successful */
      /* #90 Report to caller that DID is available */
      *supported = DCM_DID_SUPPORTED;
    }
  }

  return DCM_E_OK;
}
# endif

# if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgr_F6XX_ReadDidRangeDataLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgr_F6XX_ReadDidRangeDataLength(uint16 DID
                                                                       ,Dcm_OpStatusType OpStatus
                                                                       ,Dcm_DidMgrDidLengthPtrType DataLength)

{
  Std_ReturnType lStdResult = DCM_E_OK;

  DCM_IGNORE_UNREF_PARAM(OpStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

   /* #10 Check kind of DID (Availability ID or Data ID)*/
  if (Dcm_ObdIdMgrIsAvailabilityId(DID))
  {
    /* #20 If DID is a availability ID  */
    /* #30 Set data length to 4 */
    *DataLength = 4u;
  }
  else
  {
    uint8 lObdMid = Dcm_UtiGetLoByte(DID);
    uint8 lNumOfTIDs;

    /* #40 If DID is Data ID */
    /* #50 Request number of TIDs for Data ID */
    if (Dem_DcmGetNumTIDsOfOBDMID(lObdMid, &lNumOfTIDs) == E_OK)
    {
      /* #60 If request is successful calculate total response data length. */
      *DataLength = lNumOfTIDs * 8;
    }
    else
    {
      /* #70 Otherwise something went wrong - report back. */
      lStdResult = DCM_E_NOT_OK;
    }
  }

  return lStdResult;
}
# endif

# if (DCM_OBDUDSIDMGR_UDSMID_SUPPORT_BY_DEM_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgr_F6XX_ReadDidData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_ObdIdMgr_F6XX_ReadDidData(uint16 DID
                                                          ,Dcm_MsgType Data
                                                          ,Dcm_OpStatusType OpStatus
                                                          ,Dcm_DidMgrDidLengthPtrType DataLength
                                                          ,Dcm_NegativeResponseCodePtrType ErrorCode)
{
  Std_ReturnType lStdResult;
  uint8 lObdMid = Dcm_UtiGetLoByte(DID);

  DCM_IGNORE_UNREF_PARAM(OpStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* #10 Check kind of DID (Availability ID or Data ID)*/
  if (Dcm_ObdIdMgrIsAvailabilityId(DID))
  {
    /* #20 If DID is a availability ID */
    /* #30 Read value of availabiltity Id */
    lStdResult = Dcm_ObdIdMgr_F6XX_ReadDidData_SupportedId(lObdMid, Data, DataLength, ErrorCode);
  }
  /*#40 Otherwise */
  else
  {
    /* #50 Read Value of Data Id */
    lStdResult = Dcm_ObdIdMgr_F6XX_ReadDidData_DataId(lObdMid, Data, DataLength, ErrorCode);
  }

  return lStdResult;
}
# endif

# if (DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrGetDidAvailabilityMask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(uint32, DCM_CODE) Dcm_ObdIdMgrGetDidAvailabilityMask(uint16 DidLookUpRefStart
                                                         ,uint16 DidLookUpRefEnd
                                                         ,Dcm_ObdIdMgrMaskValueTableType maskValue)
{
  uint32 lResultMask;
  uint16_least lLookUpIter;

  DCM_IGNORE_UNREF_PARAM(maskValue);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lResultMask = 0;

  /* #10 Iterate over all (WWH-)OBD DIDs related to the AID. */
  for(lLookUpIter  = DidLookUpRefStart;
      lLookUpIter <= DidLookUpRefEnd;
      ++lLookUpIter)
  {
    Dcm_DidMgrDidInfoContextType didContext;
    uint8 lDidLowByte;

    /* #20 Consider only the DID low-byte since the AID reports the availability mask only for a certain
     * DID range (e.g 0xF4XX).
     */
    lDidLowByte = Dcm_UtiGetLoByte(Dcm_CfgDidMgrDidLookUpTable[lLookUpIter]);

    didContext.Descriptor.DidInfoPtr = &Dcm_CfgDidMgrDidInfo[lLookUpIter-1];
    Dcm_DidMgrGetDidOpInfo(&didContext, DCM_DIDMGR_OP_READ);

    /* #30 If the DID is (still) supported: */
    if(Dcm_VarMgrIsEnabledInActiveVariants(didContext.Descriptor.DidOpInfoPtr->ExecCondRef) == TRUE)
    {
      /* #40 Set the corresponding bit in the availability bitmap. */
      Dcm_UtiBitOpSet(uint32, lResultMask, Dcm_ObdIdMgrGetObdIdMaskBit(lDidLowByte));
    }
  }

#  if (DCM_OBDUDSIDMGR_CALIBRATION_ENABLED == STD_ON)
  /* #50 Consider any DIDs additionally suppressed by calibration procedure. */
  lResultMask &= maskValue;
#  endif

  /* #60 Return calculated availability ID bitmap. */
  return lResultMask;
}
# endif

# if (DCM_VARMGR_MULTI_SVC_ANY_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_ObdIdMgrGetRidAvailabilityMask()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(uint32, DCM_CODE) Dcm_ObdIdMgrGetRidAvailabilityMask(uint16 RidLookUpRefStart
                                                         ,uint16 RidLookUpRefEnd
                                                         ,Dcm_ObdIdMgrMaskValueTableType maskValue)
{
  uint32 lResultMask;
  uint16_least lLookUpIter;

  DCM_IGNORE_UNREF_PARAM(maskValue);                                                                                                                 /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lResultMask = 0;
  /* #10 Iterate over all (WWH-)OBD RIDs related to the AID. */
  for(lLookUpIter  = RidLookUpRefStart;
      lLookUpIter <= RidLookUpRefEnd;
      ++lLookUpIter)
  {
    uint8 lRidLowByte;
    /* #20 Consider only the RID low-byte since the AID reports the availability mask only for a certain
     * RID range (e.g 0xE0XX).
     */
    lRidLowByte = Dcm_UtiGetLoByte(Dcm_CfgRidMgrRidLookUpTable[lLookUpIter]);

    /* #30 If the RID is (still) supported: */
    if(Dcm_VarMgrIsEnabledInActiveVariants(Dcm_CfgRidMgrRidInfo[lLookUpIter-1].ExecCondRef) == TRUE)
    {
      /* #40 Set the corresponding bit in the availability bitmap. */
      Dcm_UtiBitOpSet(uint32, lResultMask, Dcm_ObdIdMgrGetObdIdMaskBit(lRidLowByte));
    }
  }

#  if (DCM_OBDUDSIDMGR_CALIBRATION_ENABLED == STD_ON)
  /* #50 Consider any RIDs additionally suppressed by calibration procedure. */
  lResultMask &= maskValue;
#  endif

  /* #60 Return calculated availability ID bitmap. */
  return lResultMask;
}
# endif
#endif /* (DCM_OBDUDSIDMGR_SUPPORT_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_UtiLookUpUint8()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(sint16_least, DCM_CODE) Dcm_UtiLookUpUint8(Dcm_Uint8ConstDataPtrType lookUpTable, uint8 value)
{
  sint16_least iter;
  sint16_least lResult = -1;

  Dcm_DebugAssert((lookUpTable != NULL_PTR), DCM_SID_INTERNAL, DCM_E_PARAM_POINTER)                                                                  /* COV_DCM_RTM_DEV_DEBUG XF */

  for(iter = (sint16_least)lookUpTable[0]; iter>0 ; --iter)
  {
    if(lookUpTable[iter] == value)
    {
      lResult = (sint16_least)(iter-1);
      break;
    }
  }
  return lResult;
}

#if(DCM_UTI_NVM_READ_ENABLED == STD_ON)                                                                                                              /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_UtiNvMRead()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_UtiNvMRead(Dcm_OpStatusType                opStatus
                                             ,Dcm_GenericDcmRamNoInitPtrType  data
                                             ,uint16                          blockId)
{
  Std_ReturnType lStdResult;

  lStdResult = E_OK;

  /* #10 If first call: */
  if(opStatus == DCM_INITIAL)
  {
    /* #20 Initiate NvM read operation. */
    lStdResult = NvM_ReadBlock(blockId, data);

    /* #30 If NvM operation acccepted: */
    if (lStdResult == E_OK)
    {
      /* #40 Try immediate get status */
    }
    else
    {
      /* #50 Otherwise: NvM request failed; close job. */
      lStdResult = E_NOT_OK;
    }
  }
  else
# if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
  /* #60 If service is canceled: */
  if (opStatus == DCM_CANCEL)
  {

    /* #70 Try to cancel NvM read; this is all we can do. Operation result is not from importance. */
    (void)NvM_CancelJobs(blockId);

    /* #80 Finish the job with failed. */
    lStdResult = E_NOT_OK;
  }
  else
# endif
  {
    /* Shall not be any other then DCM_PENDING (i.e. DCM_FORCE_RCRRP_OK or DCM_FORCE_RCRRP_NOT_OK) */
    Dcm_DebugAssert((opStatus == DCM_PENDING), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                /* COV_DCM_RTM_DEV_DEBUG XF */
  }

  /* #90 If no error found during NvM request or just next call of this function: */
  if(lStdResult == E_OK)
  {
    /* #100 Gather and return the NvM operation state. */
    lStdResult = Dcm_UtiNvMGetErrorStatus(blockId);
  }/* else - result is already E_NOT_OK */

  /* #110 Return final result. */
  return lStdResult;
}
#endif

#if(DCM_UTI_NVM_WRITE_ENABLED == STD_ON)                                                                                                             /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_UtiNvMWrite()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_UtiNvMWrite(Dcm_OpStatusType                     opStatus
                                              ,Dcm_GenericDcmConstRamNoInitPtrType  data
                                              ,uint16                               blockId)
{
  Std_ReturnType lStdResult;

  lStdResult = E_OK;

  /* #10 If first call: */
  if(opStatus == DCM_INITIAL)
  {
    /* #20 Initiate NvM write operation. */
    lStdResult = NvM_WriteBlock(blockId, data);
    /* #30 If NvM operation acccepted: */
    if (lStdResult == E_OK)
    {
      /* #40 Try immediate get status */
    }
    else
    {
      /* #50 Otherwise: NvM request failed; close job. */
      lStdResult = E_NOT_OK;
    }
  }
  else
# if (DCM_DIAG_CANCEL_OP_ENABLED == STD_ON)
  /* #60 If service is canceled: */
  if (opStatus == DCM_CANCEL)
  {
    /* #70 Try to cancel NvM write; this is all we can do. Operation result is not from importance. */
    (void)NvM_CancelJobs(blockId);

    /* #80 Finish the job with failed. */
    lStdResult = E_NOT_OK;
  }
  else
# endif
  {
    /* Shall not be any other then DCM_PENDING (i.e. DCM_FORCE_RCRRP_OK or DCM_FORCE_RCRRP_NOT_OK) */
    Dcm_DebugAssert((opStatus == DCM_PENDING), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                /* COV_DCM_RTM_DEV_DEBUG XF */
  }

  /* #90 If no error found during NvM request or just next call of this function: */
  if(lStdResult == E_OK)
  {
    /* #100 Gather and return the NvM operation state. */
    lStdResult = Dcm_UtiNvMGetErrorStatus(blockId);
  }/* else - result is already E_NOT_OK */

  /* #110 Return final result. */
  return lStdResult;
}
#endif

#if(DCM_UTI_NVM_SWCDATA_WRITE_ENABLED == STD_ON)                                                                                                     /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_UtiNvMSwcDataWrite()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_UtiNvMSwcDataWrite(Dcm_OpStatusType                     opStatus
                                                     ,Dcm_GenericDcmConstRamNoInitPtrType  data
                                                     ,uint16                               blockId)
{
  Std_ReturnType lStdResult;

  /* #10 If first call: */
  if(opStatus == DCM_INITIAL)
  {
    /* #20 Lock the access to the blockId for any other NvM client. */
    NvM_SetBlockLockStatus(blockId, TRUE);
  }

  /* #30 Perform normal NvM write operation. */
  lStdResult = Dcm_UtiNvMWrite(opStatus, data, blockId);

  /* #40 If NvM operation failed for any reason. */
  if(lStdResult == DCM_E_NOT_OK)
  {
    /* #50 Unlock the access to the current blockId for other clients. */
    NvM_SetBlockLockStatus(blockId, FALSE);
  }/* else - DCM_E_PENDING, DCM_E_OK */

  /* #60 Return operation result. */
  return lStdResult;
}
#endif
#if(DCM_EXT_NEED_API_DEBUGISMODULEINITIALIZED_ENABLED == STD_ON)                                                                                     /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_DebugIsModuleInitialized()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(boolean, DCM_CODE) Dcm_DebugIsModuleInitialized(void)
{
  return (boolean)Dcm_DebugOptIsModuleInitialized();
}
#endif
#if (DCM_EXT_NEED_API_NETGETCOMSTATE_ENABLED == STD_ON)                                                                                              /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_NetGetComState()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Dcm_NetComMStateType, DCM_CODE) Dcm_NetGetComState(PduIdType rxPduId)
{
  Dcm_NetComMStateType lResult;
  uint8                lErrorId = DCM_E_NO_ERROR;

  DCM_IGNORE_UNREF_PARAM(rxPduId);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_DEV_ERROR_DETECT == STD_ON)
  lResult  = DCM_NET_COMM_STATE_RX_DIS_TX_DIS;

  if(rxPduId >= Dcm_PbCfgNetNumRxPduIds)
  {
    lErrorId = DCM_E_PARAM;
  }
  else
#  if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
  if(Dcm_NetGetConnIdOfRxPduId(rxPduId) >= Dcm_PbCfgNetNumConnections) /* keep evaluation order to guard the connRef indirection */
  {
    lErrorId = DCM_E_PARAM;
  }
  else
#  endif
# endif
  {
    lResult = Dcm_NetGetComStateByRxPduId(rxPduId);
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif

  return lResult;
}
#endif
#if (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON)                                                                                                  /* COV_DCM_UNSUPPORTED XF */
# if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetRxIndInternal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_NetRxIndInternal(PduIdType     rxPduId
                                                   ,Dcm_MsgType   data                                                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                   ,PduLengthType length)
{
  Dcm_NetArEnvNotifResultType notifResult = DCM_NET_ARENV_NTFRSLT_NOT_OK;
  BufReq_ReturnType bufReq;
  P2VAR(PduInfoType, AUTOMATIC, DCM_APPL_DATA) rxPduInfoPtr = NULL_PTR;

#  if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
  /* checked within the Dcm_NetProvideRxBuffer */
#  else
  Dcm_DebugAssert((rxPduId < Dcm_PbCfgNetNumRxPduIds), DCM_SID_INTERNAL, DCM_E_PARAM)                                                                /* COV_DCM_RTM_DEV_DEBUG XF */
#  endif

  /* start virtual request; */
  /*=================================*
   BEGIN CRITICAL SECTION
   *=================================*/
  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */

  bufReq = Dcm_NetProvideRxBuffer(rxPduId, length, &rxPduInfoPtr, DCM_NET_TOBJ_FLAG_INTERNAL);

  /*=================================*
  END CRITICAL SECTION
  *=================================*/
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */

  if(bufReq == BUFREQ_OK)
  {
#  if (DCM_NET_TRANSP_OBJ_DYN_ALLOC_ENABLED == STD_ON) || \
      (DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
    Dcm_CfgNetTObjHandleMemType tObjHdl;

    tObjHdl = Dcm_NetGetTranspObjIdOfRxPduId(rxPduId);
#  endif

#  if(DCM_NET_TRANSP_OBJ_DYN_ALLOC_ENABLED == STD_ON)
    if(tObjHdl >= DCM_NET_INVALID_TOBJID)
    {
      /* Check for valid call state */
      Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                   /* COV_DCM_RTM_DEV_DEBUG XF */
    }
    else
#  endif
    {
#  if(DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
      Dcm_NetTransportObjectPtrType pTranspObj = Dcm_NetGetTranspObjByHandle(tObjHdl);
      if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_BUSY) == 0)
#  endif
      {
        /* since buffer status is BUFREQ_OK and the TransportObj is not busy, the provided buffer must be valid and
        *  large enough!
        */
        Dcm_DebugAssert((rxPduInfoPtr != NULL_PTR), DCM_SID_INTERNAL, DCM_E_PARAM_POINTER)                                                           /* COV_DCM_RTM_DEV_DEBUG XF */
        Dcm_DebugAssert(rxPduInfoPtr->SduLength >= length, DCM_SID_INTERNAL, DCM_E_BUFFERTOOLOW)                                                     /* COV_DCM_RTM_DEV_DEBUG XF */

        Dcm_UtiMemCopy(data, rxPduInfoPtr->SduDataPtr, length);                                                                                      /* PRQA S 3109 */ /* MD_MSR_14.3 */

        notifResult = DCM_NET_ARENV_NTFRSLT_OK;
      } /* else - a busy request will not be processed over an internal request */
    }

    /*=================================*
     BEGIN CRITICAL SECTION
     *=================================*/
    Dcm_UtiArEnvEnterCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */

    Dcm_RxIndication(rxPduId, notifResult);

    /*=================================*
    END CRITICAL SECTION
    *=================================*/
    Dcm_UtiArEnvLeaveCriticalSection();                                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */

  } /*else - no reception possible, exit with fail */

  return Dcm_NetArEnvGetTransmResult(notifResult);
}
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_3XX_ENABLED == STD_ON) */
#if (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
    (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON)                                                                                                  /* COV_DCM_SUPPORT_PARTIALLY TX tx xf */
# if (DCM_NET_INTERNAL_REQ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_NetRxIndInternal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_NetRxIndInternal(PduIdType     rxPduId
                                                   ,Dcm_MsgType   data                                                                               /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
                                                   ,PduLengthType length)
{
  Dcm_NetArEnvNotifResultType notifResult = DCM_NET_ARENV_NTFRSLT_NOT_OK;
  BufReq_ReturnType bufReq;
  PduLengthType     bufferSize;

#  if (DCM_VARMGR_MULTI_COM_ENABLED == STD_ON)
  /* check performed in the Dcm_NetStartOfReception */
#  else
  Dcm_DebugAssert((rxPduId < Dcm_PbCfgNetNumRxPduIds), DCM_SID_INTERNAL, DCM_E_PARAM)                                                                /* COV_DCM_RTM_DEV_DEBUG XF */
#  endif

  /* start virtual request; */
  /*=================================*
   BEGIN CRITICAL SECTION
   *=================================*/
  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /* #10 Initiate reception for the required RxPduID. Mark this reception as an internal one in order to get correct
   * ComM management.
   */
  bufReq = Dcm_NetStartOfReception(rxPduId, length, &bufferSize, DCM_NET_TOBJ_FLAG_INTERNAL);
  /*=================================*
   END CRITICAL SECTION
  *=================================*/
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */

  /* #20 If reception accepted: */
  if(bufReq == BUFREQ_OK)
  {
#  if (DCM_NET_TRANSP_OBJ_DYN_ALLOC_ENABLED == STD_ON) || \
      (DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
    Dcm_CfgNetTObjHandleMemType tObjHdl;

    tObjHdl = Dcm_NetGetTranspObjIdOfRxPduId(rxPduId);
#  endif

#  if(DCM_NET_TRANSP_OBJ_DYN_ALLOC_ENABLED == STD_ON)
    if(tObjHdl >= DCM_NET_INVALID_TOBJID)
    {
      /* Check for valid call state */
      Dcm_DebugAssertAlways(DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                                                                                   /* COV_DCM_RTM_DEV_DEBUG XF */
    }
    else
#  endif
    {
#  if(DCM_NET_MULTI_CLIENT_ENABLED == STD_ON)
      Dcm_NetTransportObjectPtrType pTranspObj = Dcm_NetGetTranspObjByHandle(tObjHdl);
      /* #30 If not a pseudo parallel request. */
      if((pTranspObj->Flags & DCM_NET_TOBJ_FLAG_BUSY) == 0)
#  endif
      {
        PduInfoType   pduInfo;

        pduInfo.SduDataPtr = data;
        pduInfo.SduLength = length;

        /* #40 Copy received data. */
        bufReq= Dcm_CopyRxData(rxPduId, &pduInfo, &bufferSize);
        /* #50 If data copy succeeded: */
        if(bufReq == BUFREQ_OK)
        {
          /* #60 Notify DCM about successfull reception. */
          notifResult = DCM_NET_ARENV_NTFRSLT_OK;
        }/* else - Dcm_CopyRxData failed -> exit with Dcm_TpRxIndication(failed)*/
      }/* else - a busy request will not be processed over an internal request */
    }
    /* #70 Notify DCM about reception accomplishment only in case the reception was accepted. */
    Dcm_TpRxIndication(rxPduId, notifResult);
  }/*else - no reception possible exit with fail */
  /* #80 Return the operation result to the caller. */
  return Dcm_NetArEnvGetTransmResult(notifResult);
}
# endif
#endif /* (DCM_BSW_ENV_ASR_VERSION_4XX_ENABLED == STD_ON) || \
 (DCM_BSW_ENV_ASR_VERSION_401_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_RepeaterSetCallee()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_RepeaterSetCallee(Dcm_RepeaterProxyFuncType pProxy)
{
  Dcm_DebugAssert((pProxy != NULL_PTR), DCM_SID_INTERNAL, DCM_E_PARAM_POINTER)                                                                       /* COV_DCM_RTM_DEV_DEBUG XF */

  Dcm_InstanceContext.Repeater.Callee = pProxy;
  Dcm_RepeaterResetOpStatus();
}

#if (DCM_REPEATER_EXT_CONTEXT_GETTER_ENABLED == STD_ON)                                                                                              /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_RepeaterGetExtSvcContext()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Dcm_GenericDcmRamNoInitPtrType, DCM_CODE) Dcm_RepeaterGetExtSvcContext(Dcm_RepeaterSvcContextHandleType handle)
{
  Dcm_GenericDcmRamNoInitPtrType lResult;
  uint8                lErrorId = DCM_E_NO_ERROR;

  DCM_IGNORE_UNREF_PARAM(handle);                                                                                                                    /* PRQA S 3112 */ /* MD_Dcm_3112 */
# if (DCM_DEV_ERROR_DETECT == STD_ON)
  lResult  = NULL_PTR;
  if(handle != DCM_REPEATER_EXT_CNTXT_SVC86)
  {
    lErrorId = DCM_E_PARAM;
  }
  else
# endif
  {
    lResult = (Dcm_GenericDcmRamNoInitPtrType)(&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc86.ExtSvc86RepeaterContext));
  }

# if (DCM_DEV_ERROR_REPORT == STD_ON)
  if (lErrorId != DCM_E_NO_ERROR)
  {
    Dcm_DebugReportError(DCM_SID_INTERNAL, lErrorId);
  }
# else
  DCM_IGNORE_UNREF_PARAM(lErrorId);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
# endif
  return lResult;
}
#endif
#if (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON)                                                                                                          /* COV_DCM_SUPPORT_ALWAYS TX */
# if (DCM_MODE_ROE_ENABLED == STD_ON)                                                                                                                /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_ModeSwitchRoE()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_ModeSwitchRoE(Rte_ModeType_DcmResponseOnEvent mode)
{
  Std_ReturnType lStdResult;

  lStdResult = Dcm_ModeOnRoEModeChange(mode);

  DCM_IGNORE_UNREF_PARAM(lStdResult);                                                                                                                /* PRQA S 3112 */ /* MD_Dcm_3112 */
  Dcm_DebugApiCheckRte((lStdResult == RTE_E_OK), DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE)
}
# endif
#endif /* (DCM_MODEMGR_SUPPORT_ENABLED == STD_ON) */
/**********************************************************************************************************************
 *  Dcm_TskSetEvent()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_TskSetEvent(Dcm_TskTaskIdOptType taskId
                                    ,Dcm_TskTaskEvMemType ev)
{
  /* Task Id out of range */
  Dcm_DebugAssert((taskId < DCM_TSK_NUM_TASKS), DCM_SID_INTERNAL, DCM_E_PARAM)                                                                       /* COV_DCM_RTM_DEV_DEBUG XF */
  /* No zero events are allowed! Possibly the Dcm_TskTaskEvMemType is too small to hold the value?*/
  Dcm_DebugAssert((ev != 0u), DCM_SID_INTERNAL, DCM_E_PARAM)                                                                                         /* COV_DCM_RTM_DEV_DEBUG XF */

  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
   BEGIN CRITICAL SECTION
   *=================================*/
#if (DCM_TSK_TASK_COMPLEX_KILL_ENABLED == STD_ON)                                                                                                    /* COV_DCM_UNSUPPORTED XF */
  if(Dcm_TskIsFlagSet(taskId, DCM_TSK_TASK_FLAG_KILLED))
  {
    /* mask all to be set events, except the non-killable ones! */
    ev &= Dcm_TskTaskInfo[taskId].NonKillEvents;
  }
#endif
  Dcm_SingletonContext.TaskMgr.TaskContext[taskId].TaskEvents |= ev;
  Dcm_SingletonContext.TaskMgr.TaskScheduler[Dcm_TskWrapPrioValue(Dcm_TskTaskInfo[taskId].TskPrio)].SchdIsActive = TRUE; /* activate task scheduler */
  /*=================================*
   END CRITICAL SECTION
   *=================================*/
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
}

/**********************************************************************************************************************
 *  Dcm_TskClrEvent()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_TskClrEvent(Dcm_TskTaskIdOptType taskId
                                    ,Dcm_TskTaskEvMemType ev)
{
  /* Task Id out of range */
  Dcm_DebugAssert((taskId < DCM_TSK_NUM_TASKS), DCM_SID_INTERNAL, DCM_E_PARAM)                                                                       /* COV_DCM_RTM_DEV_DEBUG XF */
  /* No zero events are allowed! Possibly the Dcm_TskTaskEvMemType is too small to hold the value?*/
  Dcm_DebugAssert((ev != 0u), DCM_SID_INTERNAL, DCM_E_PARAM)                                                                                         /* COV_DCM_RTM_DEV_DEBUG XF */

  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
   BEGIN CRITICAL SECTION
   *=================================*/
  Dcm_UtiBitOpClr(Dcm_TskTaskEvMemType, Dcm_SingletonContext.TaskMgr.TaskContext[taskId].TaskEvents, ev);                                            /* PRQA S 0291 */ /* MD_Dcm_BitNegation_0291 */
  /*=================================*
   END CRITICAL SECTION
   *=================================*/
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
}
/**********************************************************************************************************************
 *  Dcm_TmrStartTimer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_TmrStartTimer(Dcm_TmrTimerIdOptType timerId
                                      ,Dcm_TmrTimerCntrMemType timeTicks)
{
  /* Timer Id out of range */
  Dcm_DebugAssert((timerId < DCM_TMR_NUM_TIMERS_CASTED), DCM_SID_INTERNAL, DCM_E_PARAM)                                                              /* COV_DCM_RTM_DEV_DEBUG XF */
  /* No zero times are allowed! Possibly the Dcm_TmrTimerCntrMemType is too small to hold the value?*/
  Dcm_DebugAssert((timeTicks != 0u), DCM_SID_INTERNAL, DCM_E_PARAM)                                                                                  /* COV_DCM_RTM_DEV_DEBUG XF */

  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
   BEGIN CRITICAL SECTION
   *=================================*/
  Dcm_SingletonContext.TimerMgr.Timer[timerId] = timeTicks;
  /*=================================*
  END CRITICAL SECTION
  *=================================*/
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  Dcm_TskSetEvent(DCM_TSK_ID_TIMER, DCM_TSK_EV_TIMER_ACTIVE); /* (re-)activate the timer task */
}

/**********************************************************************************************************************
 *  TmrMgrStopTimer()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_TmrStopTimer(Dcm_TmrTimerIdOptType timerId)
{
  /* Timer Id out of range */
  Dcm_DebugAssert((timerId < DCM_TMR_NUM_TIMERS_CASTED), DCM_SID_INTERNAL, DCM_E_PARAM)                                                              /* COV_DCM_RTM_DEV_DEBUG XF */

  Dcm_UtiArEnvEnterCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /*=================================*
   BEGIN CRITICAL SECTION
   *=================================*/
  Dcm_SingletonContext.TimerMgr.Timer[timerId] = 0u;
  /*=================================*
  END CRITICAL SECTION
  *=================================*/
  Dcm_UtiArEnvLeaveCriticalSection();                                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /* not needed to unregister since in worst case the task will make an iteration to find out that no timer is running */
}
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_DIDMGR_NVM_READ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrReadNvMSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrNvMReadSignal(Dcm_OpStatusType                opStatus
                                                      ,Dcm_MsgType                     data
                                                      ,uint16                          blockId)
{
  return Dcm_UtiNvMRead(opStatus, data, blockId);
}
# endif

# if (DCM_DIDMGR_NVM_WRITE_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgrWriteNvMSignal()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrNvMWriteSignal(Dcm_ReadOnlyMsgType data
                                                       ,Dcm_OpStatusType opStatus
                                                       ,Dcm_NegativeResponseCodePtrType errorCode
                                                       ,uint16 blockId)
{
  Std_ReturnType lStdResult;

  lStdResult = Dcm_UtiNvMSwcDataWrite(opStatus, data, blockId);

  if(lStdResult == DCM_E_NOT_OK)
  {
    *errorCode = DCM_E_GENERALPROGRAMMINGFAILURE;
  }
  return lStdResult;
}
# endif

# if (DCM_DIDMGR_SR_IO_CONTROL_ENABLED == STD_ON)
/**********************************************************************************************************************
*  Dcm_DidMgrIoCtrlSRHandler_Control()
*********************************************************************************************************************/
/*!
* Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
*********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrIoCtrlSRHandler_Control(Dcm_CfgDidMgrIoCtrlSRHandlersRefOptType srEntryIndex
                                                   ,uint8 ioOperation
                                                   ,Dcm_ReadOnlyMsgType reqData
                                                   ,Dcm_OpStatusType opStatus
                                                   ,uint32 cemr
                                                   ,Dcm_NegativeResponseCodePtrType  errorCode)
{
  Std_ReturnType lStdResult = DCM_E_OK;
  Dcm_IOOperationResponseType ioResponse;
  Dcm_DidMgrIoCtrlSRHandlersConstPtrType pIoControlSrHandlers = &(Dcm_CfgDidMgr_IOControlSenderReceiverHandlers[srEntryIndex]);

  *errorCode = DCM_E_POSITIVERESPONSE;

  /* ignore parameter reqData if no IO Did supports ShortTermAdjustment */
  DCM_IGNORE_UNREF_PARAM(reqData);                                                                                                                   /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if (opStatus == DCM_INITIAL)
  {
    /* Clear IsUpdated flag */
    lStdResult = pIoControlSrHandlers->IoCtrlResRead(&ioResponse);

#  if (DCM_DIDMGR_SR_IO_SHORT_TERM_ADJUSTMENT_ENABLED == STD_ON)
    if ((ioOperation == 0x03u) && (lStdResult == DCM_E_OK))
    {
      Dcm_DebugAssert((reqData != NULL_PTR), DCM_SID_INTERNAL, DCM_E_PARAM_POINTER)                                                                  /* COV_DCM_RTM_DEV_DEBUG XF */
      /* Transfer requested data */
      lStdResult = pIoControlSrHandlers->IoCtrlReqCtrlStateWrite(reqData);
    }
#  endif

    if (lStdResult == DCM_E_OK)
    {
      /* Transfer new IO operation and new CEMR  */
      lStdResult = pIoControlSrHandlers->IoCtrlReqIoOpReqWrite(ioOperation, cemr);
    }
  }

  /* OpStatus == DCM_CANCEL has no negative effect -> leave it unhandled */

  /* Get acknowledge */
  if (lStdResult == DCM_E_OK)
  {
    if (pIoControlSrHandlers->IoCtrlResIsUpdated() == TRUE)
    {
      lStdResult = pIoControlSrHandlers->IoCtrlResRead(&ioResponse);
      if (lStdResult == DCM_E_OK)
      {
        switch (ioResponse)
        {
        case DCM_POSITIVE_RESPONSE:
        {
          uint32 underControl;
          lStdResult = pIoControlSrHandlers->IoCtrlReqUnderControlRead(&underControl);
          if (lStdResult == DCM_E_OK)
          {
            lStdResult = pIoControlSrHandlers->IoCtrlReqUnderControlWrite(underControl | cemr);
          }
          /* Set IO Operation to Idle (0xFF); return value is not evaulated due to final response of application */
          (void)pIoControlSrHandlers->IoCtrlReqIoOpReqWrite(0xFFu, cemr);
        }
          break;
        case DCM_RESPONSE_PENDING:
        case DCM_IDLE: /* still no result */
          lStdResult = DCM_E_PENDING;
          break;
        default: /* any NRC */
          /* Set IO Operation to Idle (0xFF); return value is not evaulated due to final response of application */
          (void)pIoControlSrHandlers->IoCtrlReqIoOpReqWrite(0xFFu, cemr);
          *errorCode = ioResponse;
          lStdResult = DCM_E_NOT_OK;
          break;
        }
      }
    }
    else
    {
      lStdResult = DCM_E_PENDING;
    }
  }

  if ((lStdResult == DCM_E_NOT_OK) && (*errorCode == DCM_E_POSITIVERESPONSE))
  {
    *errorCode = DCM_E_PANIC_NRC;
  }/* else:RTE error codes are handled in DCM core. */

  return lStdResult;
}                                                                                                                                                    /* PRQA S 6030, 6060, 6080 */ /* MD_MSR_STCYC,  MD_Dcm_Design_6060, MD_MSR_STMIF */
# endif

# if (DCM_DIDMGR_SR_IO_CONTROL_ENABLED == STD_ON)
/**********************************************************************************************************************
*  Dcm_DidMgrIoCtrlSRHandler_Reset()
*********************************************************************************************************************/
/*!
* Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
*********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_DidMgrIoCtrlSRHandler_Reset(Dcm_CfgDidMgrIoCtrlSRHandlersRefOptType srEntryIndex
                                                 ,uint32 cemr
                                                 ,Dcm_NegativeResponseCodePtrType errorCode)
{
  Std_ReturnType lStdResult = DCM_E_OK;
  uint32 underControl;

  Dcm_DidMgrIoCtrlSRHandlersConstPtrType pIoControlSrHandlers = &(Dcm_CfgDidMgr_IOControlSenderReceiverHandlers[srEntryIndex]);

  /* Update under control elements */
  lStdResult = pIoControlSrHandlers->IoCtrlReqUnderControlRead(&underControl);

  if (lStdResult == DCM_E_OK)
  {
    lStdResult = pIoControlSrHandlers->IoCtrlReqUnderControlWrite(underControl & ~cemr);
  }

  if (lStdResult == DCM_E_OK)
  {
    /* Transfer new IO operation and new CEMR  */
    lStdResult = pIoControlSrHandlers->IoCtrlReqIoOpReqWrite(0x00u, cemr);
  }

  if (lStdResult == DCM_E_NOT_OK)
  {
    *errorCode = DCM_E_PANIC_NRC;
  }/* else:RTE error codes are handled in DCM core. */

  return lStdResult;
}
# endif
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_EXT_NEED_API_DIAGGETACTIVITYSTATE_ENABLED == STD_ON)                                                                                        /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_DiagGetActivityState()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Dcm_DiagProcessorStateType, DCM_CODE) Dcm_DiagGetActivityState(void)
{
  return Dcm_InstanceContext.Diag.State;
}
#endif
#if (DCM_EXT_NEED_API_VARMGRGETACTIVECOMVARIANT_ENABLED == STD_ON)                                                                                   /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_VarMgrGetActiveComVariant()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC (Dcm_CfgVarMgrComVariantType, DCM_CODE) Dcm_VarMgrGetActiveComVariant(void)
{
  /* #10 Return current communication variant reference. */
  return Dcm_SingletonContext.VarMgr.ActiveComVariant;
}
#endif
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service27Init()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_Service27Init(void)
{
  Dcm_Svc27ResetSequence();
# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
  {
    /* For each security level: */
    DCM_STATE_SEC_LEVEL_ITER_DEF

    DCM_STATE_SEC_LEVEL_LOOP_FOR_UP
    {
      /* Initialize the security timer and counter. */
      Dcm_Svc27TimerReset(DCM_STATE_SEC_LEVEL_ITER_VALUE);
      Dcm_Svc27CounterReset(DCM_STATE_SEC_LEVEL_ITER_VALUE);

#  if(DCM_STATE_SEC_DELAY_ON_BOOT_ENABLED == STD_ON)
      /* If a delay time on boot is supported: */
      if(Dcm_CfgStateSecurityInfo[DCM_STATE_SEC_LEVEL_ITER_VALUE].DelayTimeOnBoot != 0u)
      {
        /* Start the appropriate security timer. */
        Dcm_Svc27TimerSet(DCM_STATE_SEC_LEVEL_ITER_VALUE, Dcm_CfgStateSecurityInfo[DCM_STATE_SEC_LEVEL_ITER_VALUE].DelayTimeOnBoot);                 /* PRQA S 3109 */ /* MD_MSR_14.3 */
        Dcm_Svc27TimerStart(DCM_STATE_SEC_LEVEL_ITER_VALUE);                                                                                         /* PRQA S 3109 */ /* MD_MSR_14.3 */
      }
#  endif
    }
  }

  /* Initialize the bit masks related to Get- and Set-AttemptCounter APIs. */
#  if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
  Dcm_InstanceContext.Diag.Services.Svc27.GetAttCntrEventMask = DCM_SVC_27_LEVEL_MASK;
  Dcm_InstanceContext.Diag.Services.Svc27.SetAttCntrEventMask = 0u;
#   if (DCM_STATE_SEC_DELAY_TIME_ON_FAILED_GET_ATT_CNTR_ENABLED == STD_ON)
  Dcm_InstanceContext.Diag.Services.Svc27.ReloadMask = 0u;
#   endif
  Dcm_InstanceContext.Diag.Services.Svc27.GetAttOpStatus = DCM_INITIAL;
  Dcm_InstanceContext.Diag.Services.Svc27.SetAttOpStatus = DCM_INITIAL;

  /* Trigger the reading of the attempt counter values. */
  Dcm_TskSetEvent(DCM_TSK_ID_SVC27, DCM_TSK_EV_SVC_27_ATTEMPT_CNTR_READ);
#  endif
# endif
}
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service2AInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_Service2AInit(void)
{
  Dcm_Service2ASchedulerInit();
}
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrRead()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CDefMgrRead(Dcm_CfgDidMgrDynDidHandleMemType dynDidHandle
                                                  ,Dcm_OpStatusType opStatus
                                                  ,Dcm_MsgType data)
{
  Std_ReturnType lStdReturn;

  /* The DDDID shall be a defined one! */
  Dcm_DebugAssert((Dcm_InstanceContext.Diag.Services.Svc2C.Items[dynDidHandle].Count != 0u), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                  /* COV_DCM_RTM_DEV_DEBUG XF */

  lStdReturn = Dcm_Svc2CDefMgrReadCheckAccessAndInit(dynDidHandle, &opStatus);

  if(lStdReturn == DCM_E_OK)
  {
    if(opStatus == DCM_INITIAL)
    {
# if (DCM_DIDMGR_DYNDID_ASYNC_SUPPORT_ENABLED == STD_ON)
      Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.DynDidHandleInUse = dynDidHandle;
# endif
      Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemInProgress = Dcm_DidMgrGetDynDidSrcItemStartRef(dynDidHandle);
      Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemToStop = (Dcm_CfgDidMgrDynDidHandleMemType)(Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_SHARED].ItemInProgress + Dcm_InstanceContext.Diag.Services.Svc2C.Items[dynDidHandle].Count);
      Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ResData = data;
    }

    /* Process source items */
    lStdReturn = Dcm_Svc2CDefMgrReadSrcItems(opStatus);
  }

# if (DCM_DIDMGR_DYNDID_ASYNC_SUPPORT_ENABLED == STD_ON)
  if(lStdReturn != DCM_E_PENDING)
  {
    /* Release resource. */
    Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.DynDidHandleInUse = DCM_SVC2C_INVALID_DYNDID_HDL;
  }
# endif
  return lStdReturn;
}

# if (DCM_DIDMGR_DYNDID_SRCITEM_CHECK_COND_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrConditionCheckRead()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CDefMgrConditionCheckRead(Dcm_CfgDidMgrDynDidHandleMemType dynDidHandle
                                                                ,Dcm_OpStatusType opStatus
                                                                ,Dcm_NegativeResponseCodePtrType errorCode)
{
  Std_ReturnType lStdResult = DCM_E_OK; /*if the DynDID does not contain any DID sources -> always OK */
  /* The DDDID shall be a defined one! */
  Dcm_DebugAssert((Dcm_InstanceContext.Diag.Services.Svc2C.Items[dynDidHandle].Count != 0u), DCM_SID_INTERNAL, DCM_E_ILLEGAL_STATE)                  /* COV_DCM_RTM_DEV_DEBUG XF */

  if(opStatus == DCM_INITIAL)
  {
    Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_EXT_ONLY].ItemInProgress = Dcm_DidMgrGetDynDidSrcItemStartRef(dynDidHandle);
    Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_EXT_ONLY].ItemToStop = (Dcm_CfgDidMgrDynDidHandleMemType)(Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_EXT_ONLY].ItemInProgress + Dcm_InstanceContext.Diag.Services.Svc2C.Items[dynDidHandle].Count);
  }

  for(;
      ( Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_EXT_ONLY].ItemInProgress
       <Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_EXT_ONLY].ItemToStop);
      ++Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_EXT_ONLY].ItemInProgress)
  {
#  if (DCM_SVC_2C_HYBRID_MODE_ENABLED == STD_ON)
    if(Dcm_Svc2CIsDidSrcItem(Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_EXT_ONLY].ItemInProgress))
#  endif
    {
#  if (DCM_DIDMGR_OPTYPE_READ_CHECKCOND_ALL_ENABLED == STD_OFF)
      if(Dcm_DidMgrIsOpTypeSupported(Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_EXT_ONLY].ItemInProgress].DidDescriptor.DidContext.Descriptor.DidOpInfoPtr, DCM_DIDMGR_OPTYPE_READCHKCOND))
#  endif
      {
        Dcm_DidMgrGetOpClassInfo(&(Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_EXT_ONLY].ItemInProgress].DidDescriptor.DidContext)
                                ,DCM_DIDMGR_OPTYPE_READCHKCOND);

        lStdResult = Dcm_DidMgrReadCheckCond(opStatus
                                            ,&(Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_EXT_ONLY].ItemInProgress].DidDescriptor.DidContext)
                                            ,&(Dcm_InstanceContext.Diag.Services.Svc2C.DynDidAccessContext.ProcessContext[DCM_SVC_2C_PROCESS_CONTEXT_ID_EXT_ONLY].DidOpTypeContext)
                                            ,errorCode);
        if(lStdResult == DCM_E_OK)
        {
          /* prepare for next item */
          opStatus = DCM_INITIAL;
        }
        else
        {
          break; /* just delegate the return value */                                                                                                /* PRQA S 0771 */ /* MD_Dcm_Optimize_0771 */
        }
      }/* else - no check condition supported by this signal */
    }/* else - memory ranges cannot be checked in advance! */
  }
  return lStdResult;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Svc2CDefMgrReadDataLength()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CODE) Dcm_Svc2CDefMgrReadDataLength(Dcm_CfgDidMgrDynDidHandleMemType dynDidHandle
                                                            ,Dcm_DidMgrDidLengthPtrType dataLength)
{
  *dataLength = Dcm_InstanceContext.Diag.Services.Svc2C.Items[dynDidHandle].Length;
  return DCM_E_OK;
}
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service2CInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_Service2CInit(void)
{
  Dcm_Svc2CDefMgrInit();
}
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service2FInit()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_Service2FInit(void)
{
# if (DCM_DIDMGR_OPTYPE_IO_RETCTRL2ECU_ENABLED == STD_ON)
  Dcm_CfgDidMgrIoDidHandleOptType ioDidIter;

  Dcm_InstanceContext.Diag.Services.Svc2F.HasAnyActiveIoDid = FALSE;
  for(ioDidIter = 0; ioDidIter < Dcm_UtiGenericBitSetCalcSize(DCM_NUM_IODIDS_CONST); ++ioDidIter)
  {
    Dcm_InstanceContext.Diag.Services.Svc2F.ActiveIoDids[ioDidIter] = 0u;
  }
# endif
}
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service86Init()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CODE) Dcm_Service86Init(void)
{
  Dcm_ExtService86Init();/* delegate to the extension */
}
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CODE
/*lint -save -esym(961, 19.1)*/
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore*/
/* ----------------------------------------------
 ~&&&   Module call-out implementations
---------------------------------------------- */
#define DCM_START_SEC_CALLOUT_CODE
/*lint -save -esym(961, 19.1)*/
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore*/
#if (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_DIDMGR_DID_F186_READ_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_DidMgr_F186_ReadData()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_DidMgr_F186_ReadData(P2VAR(uint8, AUTOMATIC, DCM_VAR_NOINIT) Data)
{
  return Dcm_GetSesCtrlType(Data);
}
# endif
#endif /* (DCM_DIDMGR_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_01_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service01Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service01Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext)
{
  Dcm_NegativeResponseCodeType  lNrc;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_InstanceContext.Repeater.Contexts.Context.Svc01.ParserDesc.GetMaskFunc = Dcm_Svc01GetAvailabilityMask;
  Dcm_InstanceContext.Repeater.Contexts.Context.Svc01.ParserDesc.ParseFlags  = DCM_OBDIDMGR_PFLAG_NONE;

  lNrc = Dcm_ObdIdMgrParseReqAndPrepRes(&Dcm_InstanceContext.Repeater.Contexts.Context.Svc01.ParserDesc, pMsgContext);

  if(lNrc == DCM_E_POSITIVERESPONSE)
  {
    if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc01.ParserDesc.IsAvailabilityId == FALSE)
    {
      Std_ReturnType lStdResult;
      Dcm_ObdIdMgrListItemPtrType lIdList = Dcm_InstanceContext.Repeater.Contexts.Context.Svc01.ParserDesc.ParseResult;
      uint8_least pidIter = Dcm_InstanceContext.Repeater.Contexts.Context.Svc01.ParserDesc.ParseCount;

      do
      {
        --pidIter;
        /* compose response record */
        pMsgContext->resData[0] = lIdList->Id;
        lStdResult = Dcm_CfgSvc01ServiceInfoTable[lIdList->Result.Handle].OpFunc(&pMsgContext->resData[1]);
        if(lStdResult != DCM_E_OK)
        {
          lNrc = DCM_E_CONDITIONSNOTCORRECT;
          break;
        }/* else - already set to positive response */

        Dcm_DiagMoveOnResWithLength(pMsgContext, Dcm_CfgSvc01ServiceInfoTable[lIdList->Result.Handle].Length); /* PID size + data size */            /* PRQA S 3109 */ /* MD_MSR_14.3 */
        Dcm_UtiNextItemByPtr(lIdList, 1u);/* next item */
      }
      while(pidIter != 0u);

    }/* else - already copied data */
  }
  Dcm_SetNegResponse(lNrc);
  return DCM_E_PROCESSINGDONE;
}
#endif /* (DCM_SVC_01_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_02_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service02Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service02Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext)
{
  Dcm_NegativeResponseCodeType  lNrc = DCM_E_REQUESTOUTOFRANGE;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* At maximum 3 PID + 3 FF can be requested */
  if( (pMsgContext->reqDataLen <= 6u)
    &&(pMsgContext->reqDataLen >  0u) /* at least one byte (actually 2, but the even number check covers that) */
    &&((pMsgContext->reqDataLen & 0x01u) == 0) )/* request length must be an even number */
  {
    Dcm_ObdIdMgrHandleOptType pidIter = (Dcm_ObdIdMgrHandleOptType)pMsgContext->reqDataLen;
    uint8_least pidTypeMask = 0x00u;
    uint8 pidList[6];
    uint8 freezeFrameId;
    uint8 pid;
    uint8 processedPids = 0u;

    /* Store the requested data */
    Dcm_UtiMemCopy(pMsgContext->reqData, pidList, 6u);                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */

    do
    {
      /* Scan backwards since the order of responded PID not necessarily shall match the order of the requested PIDs (see OBD specification) */
      --pidIter;      /* navigate to the FF */
      freezeFrameId = pidList[pidIter];
      --pidIter;      /* navigate to the PID */
      pid = pidList[pidIter];

      pidTypeMask |= (uint8)(Dcm_ObdIdMgrIsAvailabilityId(pid)?0x01u:0x02u);  /* mark availability/DATA PID found (never matter whether it is supported or not!) */

      if(pidTypeMask != 0x03u)
      {
        uint32 maskValue;
        sint16_least lLookUpResult = Dcm_ObdIdMgrGetAvailabilityMask(pid, Dcm_CfgSvc02LookUpTable, Dcm_CfgSvc02ExecPrecondTable, Dcm_CfgSvc02SupportedIdMask, &maskValue);

        if( (lLookUpResult >= 0)    /* check if PID is supported */
          &&(freezeFrameId == 0x00u) ) /* Accept only FF = 0 */
        {
          processedPids += Dcm_Svc02ReadPidData(pid, pMsgContext, maskValue);
        }/* else:
          - FreezeFrame != 0 --> ignore
          - PID not supported --> ignore */
      }
      else
      {
        /* PID mixing --> ignore */
        break;
      }
    }
    while(pidIter != 0u);

    /* At least one processed PID */
    if(processedPids != 0u)
    {
      /* PIDs of one type detected */
      if(pidTypeMask != 0x03u)
      {
        lNrc = DCM_E_POSITIVERESPONSE;
      }/* else - lNrc is already set */
    }/* else - lNrc is already set */
  }/* else - lNrc is already set */
  Dcm_SetNegResponse(lNrc);
  return DCM_E_PROCESSINGDONE;
}
#endif /* (DCM_SVC_02_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_03_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service03Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service03Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_InstanceContext.Repeater.Contexts.Context.Svc03.ReadDtcContext.Origin = DEM_DTC_ORIGIN_PRIMARY_MEMORY;
  Dcm_InstanceContext.Repeater.Contexts.Context.Svc03.ReadDtcContext.StatusMask = DCM_DTC_BIT_CONF_DTC;
  return Dcm_ObdDtcMgrReadDtcByStatusMask(&Dcm_InstanceContext.Repeater.Contexts.Context.Svc03.ReadDtcContext, pMsgContext);
}
#endif /* (DCM_SVC_03_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_04_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service04Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service04Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext)                                                     /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
{
  Std_ReturnType lStdResult;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if(pMsgContext->reqDataLen == 0u)
  {
    Dcm_RepeaterSetUser(DCM_REPEATER_USER_DEM);/* set user for central repeater handling */
    Dcm_RepeaterSetCallee(Dcm_Svc04_XX_RepeaterProxy);
    lStdResult = DCM_E_LOOP;/* speed up processing */
  }
  else
  {
    Dcm_SetNegResponse(DCM_E_REQUESTOUTOFRANGE);
    lStdResult = DCM_E_PROCESSINGDONE;
  }
  return lStdResult;
}
#endif /* (DCM_SVC_04_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON)                                                 /* COV_DCM_UNSUPPORTED XF xf xf */
/**********************************************************************************************************************
 *  Dcm_Service06Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service06Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext)
{
  Dcm_NegativeResponseCodeType  lNrc;
  uint8 lObdMid = pMsgContext->reqData[0];

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if ((pMsgContext->reqDataLen > 0u)         /* At least one ID must be there */
    && (pMsgContext->reqDataLen <= 6u))      /* Up to 6 IDs possible */
  {
    /* #10 If request length is valid  */
    if (Dcm_ObdIdMgrIsAvailabilityId(lObdMid))
    {
      /* #20 If first MID in reuqest is a availabilty MID */
      /* #30 Process availability MID request */
      Dcm_Service06Process_SupportedMid(pMsgContext, &lNrc);
    }
    else if (pMsgContext->reqDataLen == 1u)
    {
      /* #40 Otherwise if request length is eqqal 1 (Not allowed to request multiple data MIDs */
      /* #50 Process single data MID request */
      Dcm_Service06Process_SingleMid(pMsgContext, &lNrc);
    }
    else
    {
      /* #60 Otherwise return NRC DCM_E_REQUESTOUTOFRANGE */
      lNrc = DCM_E_REQUESTOUTOFRANGE;
    }
  }
  else
  {
    /* #70 Otherwise return NRC DCM_E_REQUESTOUTOFRANGE */
    lNrc = DCM_E_REQUESTOUTOFRANGE;
  }

  Dcm_SetNegResponse(lNrc);
  return DCM_E_PROCESSINGDONE;
}
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DEM_ENABLED == STD_ON) */
#if (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON)                                                 /* COV_DCM_UNSUPPORTED XF xf xf */
/**********************************************************************************************************************
 *  Dcm_Service06Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service06Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext)
{
  Dcm_NegativeResponseCodeType  lNrc;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_InstanceContext.Repeater.Contexts.Context.Svc06.ParserDesc.GetMaskFunc = Dcm_Svc06GetAvailabilityMask;
  Dcm_InstanceContext.Repeater.Contexts.Context.Svc06.ParserDesc.ParseFlags  = DCM_OBDIDMGR_PFLAG_SINGLEDATAID;

  lNrc = Dcm_ObdIdMgrParseReqAndPrepRes(&Dcm_InstanceContext.Repeater.Contexts.Context.Svc06.ParserDesc, pMsgContext);

  if( (lNrc == DCM_E_POSITIVERESPONSE)
    &&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc06.ParserDesc.IsAvailabilityId == FALSE) )
  {
    uint16             lTestValue;
    uint16             lMinLimit;
    uint16             lMaxLimit;
    Dcm_DTRStatusType  lStatus;

    /* data MID -> only one possible */

    Dcm_ObdIdMgrListItemPtrType  lIdList = Dcm_InstanceContext.Repeater.Contexts.Context.Svc06.ParserDesc.ParseResult;
    P2CONST(Dcm_CfgSvc06MidTidInfoType, AUTOMATIC, DCM_CONST) tidObject = &Dcm_CfgSvc06MidTidInfoTable[Dcm_CfgSvc06Mid2TidRefMap[lIdList->Result.Handle]];
    Dcm_CfgSvc06Mid2TidRefOptType numTids = (Dcm_CfgSvc06Mid2TidRefOptType)( Dcm_CfgSvc06Mid2TidRefMap[lIdList->Result.Handle + 1]
                                                                           - Dcm_CfgSvc06Mid2TidRefMap[lIdList->Result.Handle + 0]);

    Dcm_DiagUpdateResLength(pMsgContext, (Dcm_MsgLenType)(numTids * 9));/* set total block to response */

    for(; numTids != 0; --numTids)
    {
      if(tidObject->OpFunc(opStatus, &lTestValue, &lMinLimit, &lMaxLimit, &lStatus) == DCM_E_OK)
      {
        if(lStatus == DCM_DTRSTATUS_INVISIBLE)
        {
          lTestValue = 0;
          lMinLimit  = 0;
          lMaxLimit  = 0;
        }

        /* Copy data */
        pMsgContext->resData[0] = lIdList->Id;

        pMsgContext->resData[1] = tidObject->Tid;

        pMsgContext->resData[2] = tidObject->Uasid;

        pMsgContext->resData[3] = Dcm_UtiGetHiByte(lTestValue);
        pMsgContext->resData[4] = Dcm_UtiGetLoByte(lTestValue);

        pMsgContext->resData[5] = Dcm_UtiGetHiByte(lMinLimit);
        pMsgContext->resData[6] = Dcm_UtiGetLoByte(lMinLimit);

        pMsgContext->resData[7] = Dcm_UtiGetHiByte(lMaxLimit);
        pMsgContext->resData[8] = Dcm_UtiGetLoByte(lMaxLimit);

        Dcm_DiagMoveOnRes(pMsgContext, 9u);/* move to next block of response */
        Dcm_UtiNextItemByPtr(tidObject,1u);/* next MIDTID object */
      }
      else
      {
        lNrc = DCM_E_CONDITIONSNOTCORRECT;
        break;
      }
    }
  }/* else
   - already copied data for availability TID or
   - lNrc already set */
  Dcm_SetNegResponse(lNrc);
  return DCM_E_PROCESSINGDONE;
}
#endif /* (DCM_SVC_06_SUPPORT_ENABLED == STD_ON) && (DCM_OBDIDMGR_OBDMID_SUPPORT_BY_DCM_ENABLED == STD_ON) */
#if (DCM_SVC_07_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service07Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service07Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_InstanceContext.Repeater.Contexts.Context.Svc07.ReadDtcContext.Origin = DEM_DTC_ORIGIN_PRIMARY_MEMORY;
  Dcm_InstanceContext.Repeater.Contexts.Context.Svc07.ReadDtcContext.StatusMask = DCM_DTC_BIT_PNDG_DTC;
  return Dcm_ObdDtcMgrReadDtcByStatusMask(&Dcm_InstanceContext.Repeater.Contexts.Context.Svc07.ReadDtcContext, pMsgContext);
}
#endif /* (DCM_SVC_07_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_08_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service08Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service08Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext)
{
  Dcm_NegativeResponseCodeType  lNrc;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_InstanceContext.Repeater.Contexts.Context.Svc08.ParserDesc.GetMaskFunc = Dcm_Svc08GetAvailabilityMask;
  Dcm_InstanceContext.Repeater.Contexts.Context.Svc08.ParserDesc.ParseFlags  = (Dcm_ObdIdMgrParserFlagsType)(DCM_OBDIDMGR_PFLAG_SINGLEDATAID|DCM_OBDIDMGR_PFLAG_REQHASDATA);

  lNrc = Dcm_ObdIdMgrParseReqAndPrepRes(&Dcm_InstanceContext.Repeater.Contexts.Context.Svc08.ParserDesc, pMsgContext);

  if(lNrc == DCM_E_POSITIVERESPONSE)
  {
  if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc08.ParserDesc.IsAvailabilityId == FALSE)
    {
      CONSTP2CONST(Dcm_CfgSvc08ServiceInfoType, AUTOMATIC, DCM_CONST) tidInfoEntry = &Dcm_CfgSvc08ServiceInfoTable[Dcm_InstanceContext.Repeater.Contexts.Context.Svc08.ParserDesc.ParseResult[0].Result.Handle];
      /* data TID -> only one possible */
      if(tidInfoEntry->ReqDataLen == pMsgContext->reqDataLen)
      {
        Dcm_DiagUpdateResLength(pMsgContext, tidInfoEntry->ResDataLen); /* prepare for positive response with specific length + TID length */
        if(tidInfoEntry->OpFunc(&(pMsgContext->resData[1]), &(pMsgContext->reqData[0])) != DCM_E_OK)/* execute operation */
        {
          lNrc = DCM_E_CONDITIONSNOTCORRECT;
        }/* else - OK */
      }
      else
      {
        lNrc = DCM_E_REQUESTOUTOFRANGE; /* request is with invalid length - use NRC 0x31 to reject/suppress response */
      }
    }/* else - already copied data */
  }/* else - lNrc already set */
  Dcm_SetNegResponse(lNrc);
  return DCM_E_PROCESSINGDONE;
}
#endif /* (DCM_SVC_08_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_09_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service09Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service09Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType lStdResult;
  Dcm_NegativeResponseCodeType  lNrc;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_InstanceContext.Repeater.Contexts.Context.Svc09.ParserDesc.GetMaskFunc = Dcm_Svc09GetAvailabilityMask;
  Dcm_InstanceContext.Repeater.Contexts.Context.Svc09.ParserDesc.ParseFlags  = DCM_OBDIDMGR_PFLAG_SINGLEDATAID;

  lNrc = Dcm_ObdIdMgrParseReqAndPrepRes(&Dcm_InstanceContext.Repeater.Contexts.Context.Svc09.ParserDesc, pMsgContext);

  if(lNrc == DCM_E_POSITIVERESPONSE)
  {
    if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc09.ParserDesc.IsAvailabilityId == FALSE)
    {
      Dcm_RepeaterSetCallee(Dcm_Svc09_XX_RepeaterProxy);
      lStdResult = DCM_E_LOOP;/* speed up processing */
    }
    else
    {/* else - already copied data */
      lStdResult = DCM_E_PROCESSINGDONE;
    }
  }
  else
  { /* else - lNrc is already set */
    Dcm_SetNegResponse(lNrc);
    lStdResult = DCM_E_PROCESSINGDONE;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_09_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service0AProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service0AProcessor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_InstanceContext.Repeater.Contexts.Context.Svc0A.ReadDtcContext.Origin = DEM_DTC_ORIGIN_PERMANENT_MEMORY;
  Dcm_InstanceContext.Repeater.Contexts.Context.Svc0A.ReadDtcContext.StatusMask = DCM_DTC_BIT_DONT_CARE; /* used for permanent DTC */
  return Dcm_ObdDtcMgrReadDtcByStatusMask(&Dcm_InstanceContext.Repeater.Contexts.Context.Svc0A.ReadDtcContext, pMsgContext);
}
#endif /* (DCM_SVC_0A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_10_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_SUPPORT_ALWAYS TX */
/**********************************************************************************************************************
 *  Dcm_Service10Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service10Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext)
{
  Dcm_DiagSubServiceRefOptType  subSvcRef;
  Dcm_NegativeResponseCodeType  lNrc;
  Std_ReturnType                lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Prepare for direct exit (with or without NRC) */
  lStdResult = DCM_E_PROCESSINGDONE;

  lNrc = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                            ,Dcm_CfgSvc10SubFuncLookUpTable
                                            ,Dcm_CfgSvc10SubFuncExecPrecondTable
                                            ,Dcm_DiagSvcWithOnlySubFuncReqLengthGetter
                                            ,&subSvcRef);
  if(lNrc == DCM_E_POSITIVERESPONSE)
  {
    /* Compose positive response */
    /* Sub-function already placed */
    pMsgContext->resData[0] = Dcm_UtiGetHiByte(Dcm_CfgSvc10SubFuncInfo[subSvcRef].ResponseTime.P2);
    pMsgContext->resData[1] = Dcm_UtiGetLoByte(Dcm_CfgSvc10SubFuncInfo[subSvcRef].ResponseTime.P2);
    pMsgContext->resData[2] = Dcm_UtiGetHiByte(Dcm_CfgSvc10SubFuncInfo[subSvcRef].ResponseTime.P2Star);
    pMsgContext->resData[3] = Dcm_UtiGetLoByte(Dcm_CfgSvc10SubFuncInfo[subSvcRef].ResponseTime.P2Star);
    Dcm_DiagUpdateResLength(pMsgContext, 4);                                                                                                         /* PRQA S 3109 */ /* MD_MSR_14.3 */

    Dcm_StateSetPendingSession(Dcm_UtiGetBitFromIndex(Dcm_CfgStateGroupMemType, subSvcRef));
    /* Set always a potential tester owner:
      * in case of failed positive response confirmation or negative response, the session will remain in its old state (default) -> the set value does not matter!
      * The situation that the session was a non-default one and another client has requested SID 0x10 is not possible:
      * - Each protocol switch invokes session transition to the default one!
      * - As long as a non-default session is active, no other client with the same priority can access the ECU! */
    Dcm_NetSetSessionConnection(Dcm_NetTranspObjGetConnIdValue(Dcm_DiagGetTranspObj()));/* set potential tester for the session */

    Dcm_InstanceContext.Repeater.Contexts.Context.Svc10.SesStateIdx = (uint8)subSvcRef;
# if (DCM_SVC_10_JMP2BOOT_ENABLED == STD_ON)
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc10.ResetMode = DCM_MODEMGR_ARENV_MODE_ECURESET_NONE;
    if(Dcm_CfgSvc10SubFuncInfo[subSvcRef].BootType != DCM_SVC10_BOOT_TYPE_NONE)
    {
      /* Prepare programming conditions */
      (void)Dcm_GetActiveProtocol(&Dcm_InstanceContext.Repeater.Contexts.Context.Svc10.ProgConditions.ProtocolId);
      Dcm_InstanceContext.Repeater.Contexts.Context.Svc10.ProgConditions.TesterSourceAddr =
                      Dcm_PbCfgNetConnectionInfo[Dcm_NetTranspObjGetConnIdValue(Dcm_DiagGetTranspObj())].ClientSrcAddr;
      Dcm_InstanceContext.Repeater.Contexts.Context.Svc10.ProgConditions.Sid = 0x10u;
      Dcm_InstanceContext.Repeater.Contexts.Context.Svc10.ProgConditions.SubFuncId =
                                                                           Dcm_CfgSvc10SubFuncLookUpTable[subSvcRef+1];
      Dcm_InstanceContext.Repeater.Contexts.Context.Svc10.ProgConditions.ReprogrammingRequest = TRUE;
      /* This flag shall be initialized from the FBL, not the DCM!
      Dcm_InstanceContext.Repeater.Contexts.Context.Svc10.ProgConditions.ApplUpdated = TRUE;*/
      /* To be set once the Dcm_setProgCond API is called in order to consider the current RCR-RP status!
        * Dcm_InstanceContext.Repeater.Contexts.Context.Svc10.ProgConditions.ResponseRequired = ...; */
      Dcm_InstanceContext.Repeater.Contexts.Context.Svc10.ResetMode =
            (Dcm_ModeMgrArEnvModeEcuResetType)((Dcm_CfgSvc10SubFuncInfo[subSvcRef].BootType == DCM_SVC10_BOOT_TYPE_OEM)
                                              ?DCM_MODEMGR_ARENV_MODE_ECURESET_JMP2BOOT_OEM
                                              :DCM_MODEMGR_ARENV_MODE_ECURESET_JMP2BOOT_SYS);
      Dcm_InstanceContext.Repeater.Contexts.Progress = DCM_SVC10_PROGRESS_WAIT_RST_ACK;

      if(Dcm_ModeMgrArEnvSwitchReqEcuReset(Dcm_InstanceContext.Repeater.Contexts.Context.Svc10.ResetMode) == DCM_E_OK)
      {
        /* Determine entry point - with or without RCR-RP */
        Dcm_RepeaterSetCallee(Dcm_Svc10_XX_RepeaterProxy);
        lStdResult = DCM_E_LOOP; /* start immediately */
      }
      else
      {
        /* for some reason, no mode swtich is possible - exit with NRC */
        Dcm_SetNegResponse(DCM_E_CONDITIONSNOTCORRECT);
      }
    }/* else - just send the final response */
# endif
  }
  else
  {
    /* else - lNrc is already set */
    Dcm_SetNegResponse(lNrc);
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service10FastPostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service10FastPostProcessor(Dcm_ConfirmationStatusType status)
{
  if(status == DCM_RES_POS_OK)
  {
    Dcm_DiagSetP2Timings(Dcm_InstanceContext.Repeater.Contexts.Context.Svc10.SesStateIdx
                        ,Dcm_NetGetProtIdOfActiveProtocol());

# if (DCM_SVC_10_RESET_AFTER_RESPONSE == STD_ON)
    if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc10.ResetMode != DCM_MODEMGR_ARENV_MODE_ECURESET_NONE)
    {
      Dcm_SingletonContext.Network.RxAllowed = FALSE; /* lock any further communication while the ECU is getting reset */
    }
# endif
  }
}

/**********************************************************************************************************************
 *  Dcm_Service10PostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service10PostProcessor(Dcm_ConfirmationStatusType status)
{
  if(status == DCM_RES_POS_OK)
  {
    /* execute transition */
    Dcm_StateSetSession(Dcm_InstanceContext.Repeater.Contexts.Context.Svc10.SesStateIdx);
# if (DCM_SVC_10_RESET_AFTER_RESPONSE == STD_ON)
    if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc10.ResetMode != DCM_MODEMGR_ARENV_MODE_ECURESET_NONE)
    {
      /* fire and forget - if failed - no chance to send any NRC from here. */
      (void)Dcm_ModeMgrArEnvSwitchReqEcuReset(DCM_MODEMGR_ARENV_MODE_ECURESET_EXECUTE);
    }
# endif
  }
  else
  {
# if (DCM_STATE_PEND_SESS_SUPPORT_ENABLED == STD_ON)
    /* on the way of changing a session */
    if(0 == ( Dcm_SingletonContext.StateMgr.Preconditions.Session
            & Dcm_SingletonContext.StateMgr.PendingSession) )
    {
      /* undo pending session expectation */
#  if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)                                                                                          /* COV_DCM_DEPENDS_ON_UNSUPPORTED TX */
      Dcm_UtiArEnvEnterCriticalSection();/* avoid interrupt from the Dcm_NetTaskRx || Dcm_NetStartOfReception() */                                   /* PRQA S 3109 */ /* MD_MSR_14.3 */
#  else
      Dcm_SplitTaskEnterCS();/* avoid interrupt from the Dcm_NetTaskRx */                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
#  endif
     /*=================================*
      BEGIN CRITICAL SECTION
      *=================================*/
      Dcm_StateSyncPendingSession();/* synchronize with the currently active session */
     /*=================================*
      END CRITICAL SECTION
      *=================================*/
#  if (DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)                                                                                          /* COV_DCM_DEPENDS_ON_UNSUPPORTED TX */
      Dcm_UtiArEnvLeaveCriticalSection();                                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
#  else
      Dcm_SplitTaskLeaveCS();                                                                                                                        /* PRQA S 3109 */ /* MD_MSR_14.3 */
#  endif
    }/* else - nothing to undo */
# endif
  }
}
#endif /* (DCM_SVC_10_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_11_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service11Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service11Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext)
{
  Dcm_DiagSubServiceRefOptType  subSvcRef;
  Dcm_NegativeResponseCodeType  lNrc;
  Std_ReturnType                lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_SVC_11_ECURESET_EXEC_FILTER_ENABLED == STD_ON)
  Dcm_InstanceContext.Repeater.Contexts.Context.Svc11.SubFuncId = pMsgContext->reqData[0];
# endif

  /* Min Length already checked in DiagDispatcher and expected to be 1 !!! */
  lNrc = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                              ,Dcm_CfgSvc11SubFuncLookUpTable
                                              ,Dcm_CfgSvc11SubFuncExecPrecondTable
                                              ,Dcm_DiagSvcWithOnlySubFuncReqLengthGetter
                                              ,&subSvcRef);

  if(lNrc == DCM_E_POSITIVERESPONSE)
  {
    Dcm_RepeaterSetCallee(Dcm_CfgSvc11SubFuncInfo[subSvcRef].SubSvcFunc); /* delegate job */
    lStdResult = DCM_E_LOOP;/* speed up processing */
  }
  else
  {
    /* lNrc is already set */
    Dcm_SetNegResponse(lNrc);
    lStdResult = DCM_E_PROCESSINGDONE;
  }
  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service11PostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service11PostProcessor(Dcm_ConfirmationStatusType status)
{
  DCM_IGNORE_UNREF_PARAM(status);                                                                                                                    /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_SVC_11_ECU_RESET_ENABLED == STD_ON)
  if(status == DCM_RES_POS_OK)
  {
#  if (DCM_SVC_11_ECURESET_EXEC_FILTER_ENABLED == STD_ON)
    if( (Dcm_InstanceContext.Repeater.Contexts.Context.Svc11.SubFuncId > 0x00u)
      &&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc11.SubFuncId < 0x04u) )
#  endif
    {
      /* reset only on 0x01 (hard), 0x02 (soft), 0x03 (keyOnOff) */
      (void)Dcm_ModeMgrArEnvSwitchReqEcuReset(DCM_MODEMGR_ARENV_MODE_ECURESET_EXECUTE);
    }
  }
# endif
}

/**********************************************************************************************************************
 *  Dcm_Service11FastPostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service11FastPostProcessor(Dcm_ConfirmationStatusType status)
{
  DCM_IGNORE_UNREF_PARAM(status);                                                                                                                    /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_SVC_11_ECU_RESET_ENABLED == STD_ON)
  if(status == DCM_RES_POS_OK)
  {
#  if (DCM_SVC_11_ECURESET_EXEC_FILTER_ENABLED == STD_ON)
    if( (Dcm_InstanceContext.Repeater.Contexts.Context.Svc11.SubFuncId > 0x00u)
      &&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc11.SubFuncId < 0x04u) )
#  endif
    {
      /* reset only on 0x01 (hard), 0x02 (soft), 0x03 (keyOnOff) */
      Dcm_SingletonContext.Network.RxAllowed = FALSE; /* lock any further communication while the ECU is getting reset */
    }
  }
# endif
}
# if (DCM_SVC_11_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service11_01Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service11_01Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext)                                                  /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */
  /* Delegate job to the concrete mode manager. */
  return Dcm_Svc11_ProcessEcuReset(DCM_MODEMGR_ARENV_MODE_ECURESET_HARD);
}
# endif
# if (DCM_SVC_11_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service11_02Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service11_02Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext)                                                  /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Delegate job to the concrete mode manager. */
  return Dcm_Svc11_ProcessEcuReset(DCM_MODEMGR_ARENV_MODE_ECURESET_KEYONOFF);
}
# endif
# if (DCM_SVC_11_03_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service11_03Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service11_03Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext)                                                  /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Delegate job to the concrete mode manager. */
  return Dcm_Svc11_ProcessEcuReset(DCM_MODEMGR_ARENV_MODE_ECURESET_SOFT);
}
# endif
# if (DCM_SVC_11_04_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service11_04Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service11_04Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext)                                                  /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Prepare for a positive response. */
  ++(pMsgContext->resDataLen);
  pMsgContext->resData[0] = DCM_SVC_11_POWERDOWNTIME;

  /* Delegate job to the concrete mode manager. */
  return Dcm_Svc11_ProcessRapPwrDwn(DCM_MODEMGR_ARENV_MODE_RPDPWRSHTDWN_ENABLE);
}
# endif
# if (DCM_SVC_11_05_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service11_05Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service11_05Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext)                                                  /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Delegate job to the concrete mode manager. */
  return Dcm_Svc11_ProcessRapPwrDwn(DCM_MODEMGR_ARENV_MODE_RPDPWRSHTDWN_DISABLE);
}
# endif
#endif /* (DCM_SVC_11_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_14_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service14Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service14Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType lStdReturn;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if(pMsgContext->reqDataLen == 3u)
  {
    pMsgContext->resDataLen = 0u; /* no data to return */
    /* Store requested DTC for asynchronous processing */
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc14.Dtc = Dcm_UtiMake32Bit(0x00u
                                                                              ,pMsgContext->reqData[0]
                                                                              ,pMsgContext->reqData[1]
                                                                              ,pMsgContext->reqData[2]);
    /* Clear DTC */
    Dcm_RepeaterSetUser(DCM_REPEATER_USER_DEM);/* set user for central repeater handling */
    Dcm_RepeaterSetCallee(Dcm_Svc14_XX_RepeaterProxy);
    lStdReturn = DCM_E_LOOP;/* speed up processing */
  }
  else
  {
    Dcm_SetNegResponse(DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT);
    lStdReturn = DCM_E_PROCESSINGDONE;
  }

  return lStdReturn;
}
#endif /* (DCM_SVC_14_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_19_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext)
{
  Dcm_DiagSubServiceRefOptType  subSvcRef;
  Dcm_NegativeResponseCodeType  lNrc;
  Std_ReturnType                lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lNrc = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                            ,Dcm_CfgSvc19SubFuncLookUpTable
                                            ,Dcm_CfgSvc19SubFuncExecPrecondTable
                                            ,Dcm_Svc19ReqLengthGetter
                                            ,&subSvcRef);
  if(lNrc == DCM_E_POSITIVERESPONSE)
  {
    Dcm_RepeaterSetUser(DCM_REPEATER_USER_DEM);/* set user for central repeater handling */
    Dcm_RepeaterSetCallee(Dcm_CfgSvc19SubFuncInfo[subSvcRef].SubSvcFunc); /* delegate job */

    Dcm_ExtSvc19UtiPatchDtcStatusInit();
    lStdResult = DCM_E_LOOP;/* speed up processing */
  }
  else
  {
    /* lNrc is already set */
    Dcm_SetNegResponse(lNrc);
    lStdResult = DCM_E_PROCESSINGDONE;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service19PostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service19PostProcessor(Dcm_ConfirmationStatusType status)
{
  DCM_IGNORE_UNREF_PARAM(status);                                                                                                                    /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_DEMAPI_SVC_19_ANYABLERECORDUPDATE_ENABLED == STD_ON)
  (void)Dcm_DemAPI(EnableDTCRecordUpdate)();/* always enable, even if not disabled or already enabled. */
# endif
}
# if (DCM_SVC_19_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_01Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_01Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  return Dcm_Svc19UtiReportNumDtcByStatusMaskData( DCM_SVC_19_DEM_SETFILTER_CLASS_01
                                                  ,pMsgContext->reqData[0]
                                                  ,0
                                                  ,pMsgContext);
}
# endif

# if (DCM_SVC_19_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_02Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_02Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  return Dcm_Svc19UtiReportDtcByStatusMaskData( DCM_SVC_19_DEM_SETFILTER_CLASS_01
                                               ,DCM_SVC_19_USE_MASK_REQ
                                               ,pMsgContext);
}
# endif

# if (DCM_SVC_19_03_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_03Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_03Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext)                                                  /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
{
  Std_ReturnType           lStdResult;
  Dem_ReturnSetFilterType  demResult;
  uint16                   numOfRecords;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  demResult = Dcm_DemAPI(SetFreezeFrameRecordFilter)(DEM_DTC_FORMAT_UDS, &numOfRecords);
  if (demResult == DEM_FILTER_ACCEPTED)
  {
#  if (DCM_DEM_API_PAGED_BUFFER_ENABLED == STD_ON)
    /* Starting iterations */
    Dcm_PagedBufferStart(Dcm_Svc19UtiCpyDemGetNxtFltrdRecord
                        ,NULL_PTR
                        ,(Dcm_MsgLenType)(numOfRecords * 4));
    /* Let the page-buffer do the job */
    lStdResult = DCM_E_OK;
#  else
    Dcm_Svc19UtiStartLinearCopy(Dcm_Svc19UtiCpyDemGetNxtFltrdRecord);
    lStdResult = DCM_E_LOOP;/* speed up processing */
#  endif
  }
  else
  { /* Any DEM error */
    Dcm_DemApiSetNegResponse(demResult, Dcm_DemApiNrcMapSetDTCFilter);
    lStdResult = DCM_E_PROCESSINGDONE;
  }
  return lStdResult;
}
# endif

# if (DCM_SVC_19_04_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_04Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_04Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext)                                                  /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  return Dcm_Svc19UtiReportDtcFFRByDtc(DEM_DTC_ORIGIN_PRIMARY_MEMORY, pMsgContext);
}
# endif

# if (DCM_SVC_19_05_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_05Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_05Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType lStdReturn;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.Origin     = DEM_DTC_ORIGIN_PRIMARY_MEMORY;
  Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNum  = pMsgContext->reqData[0];

  pMsgContext->resData[0] = 0x00u; /* prepare for positive case */

  Dcm_DiagMoveOnResWithLengthAll(pMsgContext, 1); /* skip FF number */                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */

  if( (Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNum == 0x00u)
    ||(Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.RecordNum == DCM_SVC_19_RECNUM_ALL) )
  {
    uint16 recordLength;
    Dcm_DemReturnGetFreezeFrameDataByRecordType demResult;

    recordLength = (uint16)(pMsgContext->resMaxDataLen - 4u);/* Reserve place for DTCAndStatusRecord */

    demResult = Dcm_DemAPI_GetOBDFreezeFrameData(0x00u
                                                ,Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.Origin
                                                ,&Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.Dtc
                                                ,&pMsgContext->resData[4]
                                                ,&recordLength);
    switch(demResult)
    {
    case DCM_DEM_RET_FFBYRECORD_OK:
      Dcm_DiagUpdateResLengthAll(pMsgContext, recordLength); /* commit data */                                                                       /* PRQA S 3109 */ /* MD_MSR_14.3 */
      lStdReturn = Dcm_Svc19UtiChainStart(Dcm_Svc19DemChainGetDtcStatusEnd);  /* now place the DTC status record */
      break;
    case DCM_DEM_RET_FFBYRECORD_NO_DTC:
      /* nothing to report - just the record number */
      lStdReturn = DCM_E_PROCESSINGDONE;
      break;
    default:
      Dcm_DemApiSetNegResponse(demResult, Dcm_Svc19NrcMapGetOBDFreezeFrameData);
      lStdReturn = DCM_E_PROCESSINGDONE;
      break;
    }
  }
  else
  {
    Dcm_SetNegResponse(DCM_E_REQUESTOUTOFRANGE);
    lStdReturn = DCM_E_PROCESSINGDONE;
  }
  return lStdReturn;
}
# endif

# if (DCM_SVC_19_06_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_06Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_06Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  return Dcm_Svc19UtiReportExtDataRecordByDtcNum(DEM_DTC_ORIGIN_PRIMARY_MEMORY
                                                ,pMsgContext);
}
# endif

# if (DCM_SVC_19_07_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_07Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_07Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  return Dcm_Svc19UtiReportNumDtcByStatusMaskData( DCM_SVC_19_DEM_SETFILTER_CLASS_02
                                                  ,pMsgContext->reqData[1]
                                                  ,pMsgContext->reqData[0]
                                                  ,pMsgContext);
}
# endif

# if (DCM_SVC_19_08_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_08Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_08Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType                    lStdResult;
  uint8                             dtcStatusMask;
  uint8                             dtcSeverityMask;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* save the requested masks */
  dtcSeverityMask= pMsgContext->reqData[0];
  dtcStatusMask  = pMsgContext->reqData[1];

  /* Copy the status availability mask (in any case) */
  lStdResult = Dcm_DemAPI(GetDTCStatusAvailabilityMask)(pMsgContext->resData);

  Dcm_DiagUpdateResLengthAll(pMsgContext, 1u);                                                                                                       /* PRQA S 3109 */ /* MD_MSR_14.3 */

  if(lStdResult == E_OK)
  {
    Dem_ReturnSetFilterType  demResultSetFilter;

    Dcm_ExtSvc19UtiPatchDtcStatusSetForFilter(&dtcStatusMask);                                                                                       /* PRQA S 3109 */ /* MD_MSR_14.3 */
    /* Form the relevant status bits */
    dtcStatusMask &= pMsgContext->resData[0];

    if(dtcStatusMask == 0u)
    {
      lStdResult = DCM_E_PROCESSINGDONE;/* no DTCs to report */
    }
    else
    {
      /* filter the DTCs */
      Dcm_UtiNextItemByPtr(pMsgContext->resData, 1u);

      demResultSetFilter = Dcm_DemAPI(SetDTCFilter)(dtcStatusMask
                                                    ,DEM_DTC_KIND_ALL_DTCS
                                                    ,DEM_DTC_FORMAT_UDS
                                                    ,DEM_DTC_ORIGIN_PRIMARY_MEMORY
                                                    ,DEM_FILTER_WITH_SEVERITY_YES
                                                    ,dtcSeverityMask
                                                    ,DEM_FILTER_FOR_FDC_NO);
      if(demResultSetFilter == DEM_FILTER_ACCEPTED)
      {
        lStdResult = Dcm_Svc19UtiChainStart(Dcm_Svc19_08DemChain);
      }
      else
      {
        /* error case - send NRC */
        Dcm_DemApiSetNegResponse(demResultSetFilter, Dcm_DemApiNrcMapSetDTCFilter);
        lStdResult = DCM_E_PROCESSINGDONE;
      }
    }
  }
  else
  {
    Dcm_DemApiSetNegResponse(lStdResult, Dcm_Svc19NrcMapStdReturnType);
    lStdResult = DCM_E_PROCESSINGDONE;
  }

  return lStdResult;
}
# endif

# if (DCM_SVC_19_09_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_09Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_09Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* save the requested masks */
  Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.Origin = DEM_DTC_ORIGIN_PRIMARY_MEMORY;
  Dcm_InstanceContext.Repeater.Contexts.Context.Svc19.Dtc = Dcm_UtiMake32Bit(0x00u
                                                                            ,pMsgContext->reqData[0]
                                                                            ,pMsgContext->reqData[1]
                                                                            ,pMsgContext->reqData[2]);

  /* Copy the status availability mask (in any case) */
  lStdResult = Dcm_DemAPI(GetDTCStatusAvailabilityMask)(pMsgContext->resData);

  Dcm_DiagMoveOnResWithLength(pMsgContext, 1u);                                                                                                      /* PRQA S 3109 */ /* MD_MSR_14.3 */

  if(lStdResult == E_OK)
  {
    lStdResult = Dcm_Svc19UtiChainStart(Dcm_Svc19_09DemChain);
  }
  else
  {
    /* else - error case - send NRC */
    Dcm_DemApiSetNegResponse(lStdResult, Dcm_Svc19NrcMapStdReturnType);
    lStdResult = DCM_E_PROCESSINGDONE;
  }
  return lStdResult;
}
# endif

# if (DCM_SVC_19_0A_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_0AProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_0AProcessor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  return Dcm_Svc19UtiReportDtcByStatusMaskData( DCM_SVC_19_DEM_SETFILTER_CLASS_01
                                               ,DCM_SVC_19_USE_MASK_ALL
                                               ,pMsgContext);
}
# endif

# if (DCM_SVC_19_0B_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_0BProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_0BProcessor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  return Dcm_Svc19UtiReportNumDtcByOccurenceTime(DEM_FIRST_FAILED_DTC
                                                ,pMsgContext);
}
# endif

# if (DCM_SVC_19_0C_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_0CProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_0CProcessor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  return Dcm_Svc19UtiReportNumDtcByOccurenceTime(DEM_FIRST_DET_CONFIRMED_DTC
                                                ,pMsgContext);
}
# endif

# if (DCM_SVC_19_0D_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_0DProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_0DProcessor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  return Dcm_Svc19UtiReportNumDtcByOccurenceTime(DEM_MOST_RECENT_FAILED_DTC
                                                ,pMsgContext);
}
# endif

# if (DCM_SVC_19_0E_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_0EProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_0EProcessor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  return Dcm_Svc19UtiReportNumDtcByOccurenceTime(DEM_MOST_REC_DET_CONFIRMED_DTC
                                                ,pMsgContext);
}
# endif

# if (DCM_SVC_19_0F_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_0FProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_0FProcessor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  return Dcm_Svc19UtiReportDtcByStatusMaskData( DCM_SVC_19_DEM_SETFILTER_CLASS_03
                                               ,DCM_SVC_19_USE_MASK_REQ
                                               ,pMsgContext);
}
# endif

# if (DCM_SVC_19_10_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_10Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_10Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  return Dcm_Svc19UtiReportExtDataRecordByDtcNum(DEM_DTC_ORIGIN_MIRROR_MEMORY
                                                ,pMsgContext);
}
# endif

# if (DCM_SVC_19_11_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_11Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_11Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  return Dcm_Svc19UtiReportNumDtcByStatusMaskData( DCM_SVC_19_DEM_SETFILTER_CLASS_03
                                                  ,pMsgContext->reqData[0]
                                                  ,0
                                                  ,pMsgContext);
}
# endif
# if (DCM_SVC_19_12_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_12Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_12Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  return Dcm_Svc19UtiReportNumDtcByStatusMaskData( DCM_SVC_19_DEM_SETFILTER_CLASS_04
                                                  ,pMsgContext->reqData[0]
                                                  ,0
                                                  ,pMsgContext);
}
# endif

# if (DCM_SVC_19_13_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_13Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_13Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  return Dcm_Svc19UtiReportDtcByStatusMaskData( DCM_SVC_19_DEM_SETFILTER_CLASS_04
                                               ,DCM_SVC_19_USE_MASK_REQ
                                               ,pMsgContext);
}
# endif
# if (DCM_SVC_19_14_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_14Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_14Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext)                                                  /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
{
  Std_ReturnType           lStdResult;
  Dem_ReturnSetFilterType  demResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  demResult = Dcm_DemAPI(SetDTCFilter)( 0x00u
                                        ,DEM_DTC_KIND_ALL_DTCS
                                        ,DEM_DTC_FORMAT_UDS
                                        ,DEM_DTC_ORIGIN_PRIMARY_MEMORY
                                        ,DEM_FILTER_WITH_SEVERITY_NO
                                        ,0u /* not used */
                                        ,DEM_FILTER_FOR_FDC_YES);
  if(demResult == DEM_FILTER_ACCEPTED)
  {
    lStdResult = Dcm_Svc19UtiChainStart(Dcm_Svc19_14DemChain);
  }
  else
  {
    /* else - error case - send NRC */
    Dcm_DemApiSetNegResponse(demResult, Dcm_DemApiNrcMapSetDTCFilter);
    lStdResult = DCM_E_PROCESSINGDONE;
  }
  return lStdResult;
}
# endif

# if (DCM_SVC_19_15_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_15Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_15Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext)
{
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  return Dcm_Svc19UtiReportDtcByStatusMaskData( DCM_SVC_19_DEM_SETFILTER_CLASS_05
                                               ,DCM_SVC_19_USE_MASK_ALL
                                               ,pMsgContext);
}
# endif

# if (DCM_SVC_19_17_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_17Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_17Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType lResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
#  if (DCM_SVC_19_USER_MEM_ID_CHECK_ENABLED == STD_ON)
  if(pMsgContext->reqData[1] != DCM_SVC_19_USER_MEM_ID)
  {
    Dcm_SetNegResponse(DCM_E_REQUESTOUTOFRANGE);
    lResult = DCM_E_PROCESSINGDONE;
  }
  else
#  endif
  {
    /* save UserMid and response location */
    uint8 lUserMemId = pMsgContext->reqData[1];
    Dcm_MsgType resUserMemIdPtr = pMsgContext->resData;
    /* skip the UserMid in response now */
    Dcm_DiagMoveOnResWithLengthAll(pMsgContext, 1u);                                                                                                 /* PRQA S 3109 */ /* MD_MSR_14.3 */

    lResult =  Dcm_Svc19UtiReportDtcByStatusMaskData( DCM_SVC_19_DEM_SETFILTER_CLASS_06
                                                     ,DCM_SVC_19_USE_MASK_REQ
                                                     ,pMsgContext);
    /* place the UserMid to the response */
    resUserMemIdPtr[0] = lUserMemId;
  }
  return lResult;
}
# endif

# if (DCM_SVC_19_18_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_18Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_18Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType lResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
#  if (DCM_SVC_19_USER_MEM_ID_CHECK_ENABLED == STD_ON)
  if(pMsgContext->reqData[4] != DCM_SVC_19_USER_MEM_ID)
  {
    Dcm_SetNegResponse(DCM_E_REQUESTOUTOFRANGE);
    lResult = DCM_E_PROCESSINGDONE;
  }
  else
#  endif
  {
    /* save UserMid and response location */
    uint8 lUserMemId = pMsgContext->reqData[4];
    Dcm_MsgType resUserMemIdPtr = pMsgContext->resData;
    /* skip the UserMid in response now */
    Dcm_DiagMoveOnResWithLengthAll(pMsgContext, 1u);                                                                                                 /* PRQA S 3109 */ /* MD_MSR_14.3 */

    lResult = Dcm_Svc19UtiReportDtcFFRByDtc(DEM_DTC_ORIGIN_SECONDARY_MEMORY
                                           ,pMsgContext);
    /* place the UserMid to the response */
    resUserMemIdPtr[0] = lUserMemId;
  }
  return lResult;
}
# endif

# if (DCM_SVC_19_19_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_19Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_19Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType lResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
#  if (DCM_SVC_19_USER_MEM_ID_CHECK_ENABLED == STD_ON)
  if(pMsgContext->reqData[4] != DCM_SVC_19_USER_MEM_ID)
  {
    Dcm_SetNegResponse(DCM_E_REQUESTOUTOFRANGE);
    lResult = DCM_E_PROCESSINGDONE;
  }
  else
#  endif
  {
    /* save UserMid and response location */
    uint8 lUserMemId = pMsgContext->reqData[4];
    Dcm_MsgType resUserMemIdPtr = pMsgContext->resData;
    /* skip the UserMid in response now */
    Dcm_DiagMoveOnResWithLengthAll(pMsgContext, 1u);                                                                                                 /* PRQA S 3109 */ /* MD_MSR_14.3 */

    lResult = Dcm_Svc19UtiReportExtDataRecordByDtcNum(DEM_DTC_ORIGIN_SECONDARY_MEMORY
                                                     ,pMsgContext);
    /* place the UserMid to the response */
    resUserMemIdPtr[0] = lUserMemId;
  }
  return lResult;
}
# endif

# if (DCM_SVC_19_42_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service19_42Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service19_42Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType                lStdResult;
  uint8                         dtcStatusMask;
  uint8                         dtcSeverityMask;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  if (pMsgContext->reqData[0] == 0x33u)
  {
    /* save the requested masks */
    dtcStatusMask  = pMsgContext->reqData[1];
    dtcSeverityMask= pMsgContext->reqData[2];

    /* Copy the functional group */
    pMsgContext->resData[0] = pMsgContext->reqData[0];

    /* Copy the status availability mask (in any case) */
    lStdResult = Dcm_DemAPI(GetDTCStatusAvailabilityMask)(&pMsgContext->resData[1]);

    if(lStdResult == E_OK)
    {
      lStdResult = Dcm_DemAPI(GetDTCSeverityAvailabilityMask)(&pMsgContext->resData[2]);

      if(lStdResult == E_OK)
      {
        Dem_ReturnSetFilterType  demResultSetFilter;

        /* evaluate the DTCFormatIdentifier */
        pMsgContext->resData[3] = Dcm_DemAPI(GetTranslationType)();

        Dcm_ExtSvc19UtiPatchDtcStatusSetForFilter(&dtcStatusMask);                                                                                   /* PRQA S 3109 */ /* MD_MSR_14.3 */

        /* Form the relevant status bits */
        dtcStatusMask &= pMsgContext->resData[1];

        Dcm_DiagMoveOnResWithLengthAll(pMsgContext,4);                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */

        if(dtcStatusMask == 0u)
        {
          lStdResult = DCM_E_PROCESSINGDONE;/* no DTCs to report */
        }
        else
        {
          /* filter the DTCs */
          demResultSetFilter = Dcm_DemAPI(SetDTCFilter)(dtcStatusMask
                                                        ,DEM_DTC_KIND_EMISSION_REL_DTCS
                                                        ,DEM_DTC_FORMAT_UDS
                                                        ,DEM_DTC_ORIGIN_PRIMARY_MEMORY
                                                        ,DEM_FILTER_WITH_SEVERITY_YES
                                                        ,dtcSeverityMask
                                                        ,DEM_FILTER_FOR_FDC_NO);

          if(demResultSetFilter == DEM_FILTER_ACCEPTED)
          {
            lStdResult = Dcm_Svc19UtiChainStart(Dcm_Svc19_42DemChain);
          }
          else
          {
            /* error case - send NRC */
            Dcm_SetNegResponse(Dcm_DemApiGetNrcForDemRetValue(demResultSetFilter, Dcm_DemApiNrcMapSetDTCFilter));
            lStdResult = DCM_E_PROCESSINGDONE;
          }
        }
      }
      else
      {
        Dcm_SetNegResponse(Dcm_DemApiGetNrcForDemRetValue(lStdResult, Dcm_Svc19NrcMapStdReturnType));
        lStdResult = DCM_E_PROCESSINGDONE;
      }
    }
    else
    {
      Dcm_SetNegResponse(Dcm_DemApiGetNrcForDemRetValue(lStdResult, Dcm_Svc19NrcMapStdReturnType));
      lStdResult = DCM_E_PROCESSINGDONE;
    }
  }
  else
  {
    /* Invalid functional group */
    Dcm_SetNegResponse(DCM_E_REQUESTOUTOFRANGE);
    lStdResult = DCM_E_PROCESSINGDONE;
  }
  return lStdResult;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif
#endif /* (DCM_SVC_19_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_22_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service22Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service22Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext)                                                     /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
{
  Std_ReturnType lStdReturn;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Min Length already checked in DiagDispatcher and expected to be 2 !!! */
  /* Check if the length is multiple of 2, since each DID is 2 Byte.*/
  if( ((pMsgContext->reqDataLen & 0x01u) == 0) /* length is an odd (wrong) or even (right) number */
    &&(pMsgContext->reqDataLen <= (Dcm_MsgLenType)(DCM_SVC_22_MAX_DID_LIST_LEN * 2)) )    /* Also the capacity of the ECU shall not be exceeded */
  {

    Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidInfoContextPtr = &(Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidInfoContextList[0]);
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.NumDids = 0u;
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.DidIter = 0u;
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc22.TotalLength = 0u;

    Dcm_RepeaterSetCallee(Dcm_Svc22DidLookUp);
    lStdReturn = DCM_E_LOOP;/* speed up processing */
  }
  else
  {
    Dcm_SetNegResponse(DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT);
    lStdReturn = DCM_E_PROCESSINGDONE;
  }

  return lStdReturn;
}
#endif /* (DCM_SVC_22_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_23_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service23Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service23Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType lStdReturn;
  Dcm_NegativeResponseCodeType lNrc;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* dispatcher guarantees for minimum length of 3 bytes (ALFID + MEM + SIZE) available */
  lNrc = Dcm_MemMgrValidateAlfid(pMsgContext->reqData, &pMsgContext->reqDataLen);
  if(lNrc == DCM_E_POSITIVERESPONSE)
  {
    /* check for exact length match */
    if(pMsgContext->reqDataLen == 0u)
    {
      (void)Dcm_MemMgrParseMemStream(pMsgContext->reqData[0]
                                    ,&pMsgContext->reqData[1]
                                    ,&Dcm_InstanceContext.Repeater.Contexts.Context.Svc23.MemBlock);
      pMsgContext->resDataLen = Dcm_InstanceContext.Repeater.Contexts.Context.Svc23.MemBlock.Length;

      lNrc = Dcm_MemMgrCheckMemBlock(&Dcm_InstanceContext.Repeater.Contexts.Context.Svc23.MemBlock, DCM_MEMMGR_OP_READ);
      if(lNrc == DCM_E_POSITIVERESPONSE)
      {
        /* Check for overflow */
        if(pMsgContext->resDataLen <= pMsgContext->resMaxDataLen)
        {
# if (DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
          Dcm_RepeaterSetCallee(Dcm_Svc23CheckAccess);
# else
          Dcm_RepeaterSetCallee(Dcm_Svc23ReadMemory);
# endif
          lStdReturn = DCM_E_LOOP;/* speed up processing */
        }
        else
        {
          Dcm_SetNegResponse(DCM_E_RESPONSETOOLONG);
          lStdReturn = DCM_E_PROCESSINGDONE;
        }
      }
      else
      {
        /* else - lNrc is already set */
        Dcm_SetNegResponse(lNrc);
        lStdReturn = DCM_E_PROCESSINGDONE;
      }
    }
    else
    {
      Dcm_SetNegResponse(DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT);
      lStdReturn = DCM_E_PROCESSINGDONE;
    }
  }
  else
  { /* else - lNrc is already set */
    Dcm_SetNegResponse(lNrc);
    lStdReturn = DCM_E_PROCESSINGDONE;
  }

  return lStdReturn;
}
#endif /* (DCM_SVC_23_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_24_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service24Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service24Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext)                                                     /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
{
  Std_ReturnType lStdReturn = DCM_E_PROCESSINGDONE;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* If valid service request length: */
  if(pMsgContext->reqDataLen == 2u)
  {
    /* Prepare for DID look up. */
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc24.DidInfoContext.Did = Dcm_UtiMake16Bit(pMsgContext->reqData[0], pMsgContext->reqData[1]);

    /* Initialize DID look up. */
    Dcm_RepeaterSetCallee(Dcm_Svc24DidLookUp);
    lStdReturn = DCM_E_LOOP;
  }
  else
  {
    /* Invlaid length detected -> send NRC 0x13 */
    Dcm_SetNegResponse(DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT);
  }
  /* Return control to DCM core. */
  return lStdReturn;
}
#endif /* (DCM_SVC_24_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_27_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service27Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service27Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType                lStdResult;
  Dcm_DiagSubServiceRefOptType  subSvcRef;
  Dcm_NegativeResponseCodeType  lNrc;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lStdResult = DCM_E_PROCESSINGDONE;

  lNrc = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                              ,Dcm_CfgSvc27SubFuncLookUpTable
                                              ,Dcm_CfgSvc27SubFuncExecPrecondTable
                                              ,Dcm_Svc27ReqLengthGetter
                                              ,&subSvcRef);

  Dcm_InstanceContext.Repeater.Contexts.Context.Svc27.SfIdx = (uint8)subSvcRef;/* Store working sub-function reference (also in negative response cases) */

  if(lNrc == DCM_E_POSITIVERESPONSE)
  {
    /* Just update response length. Data pointer will be filled and moved later, by the sub-service processors. */
    Dcm_DiagUpdateResLengthAll(pMsgContext, Dcm_CfgSvc27SubFuncInfo[Dcm_InstanceContext.Repeater.Contexts.Context.Svc27.SfIdx].ResLength);           /* PRQA S 3109 */ /* MD_MSR_14.3 */

    /* Delegate the job to the appropriate sub-function processor. */
    Dcm_RepeaterSetCallee(Dcm_CfgSvc27SubFuncInfo[Dcm_InstanceContext.Repeater.Contexts.Context.Svc27.SfIdx].SubSvcFunc);
    lStdResult = DCM_E_LOOP; /* Speed up processing. */
  }
  else
# if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
  if(lNrc == DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT)
  {
    /* If a compare key request was sent: */
    if( ((Dcm_InstanceContext.Repeater.Contexts.Context.Svc27.SfIdx & 0x01u) != 0u)/* wrong length key is an invalid key!*/
      &&(Dcm_InstanceContext.Diag.Services.Svc27.SeedLevel != DCM_SVC_27_SEED_LVL_INVALID) )
    {
      /* Increment the attempt counter. */
      Dcm_Svc27CounterInc(Dcm_Svc27GetCurReqLevAttemptIdx());                                                                                        /* PRQA S 3109 */ /* MD_MSR_14.3 */
#  if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
      /* Notify application about new attempt counter. */
      Dcm_RepeaterSetCallee(Dcm_Service27SetAttemptCntrRepeater);
      lStdResult = DCM_E_LOOP;/* Speed up processing. */
#  endif
    }
    /* send NRC */
  }
  else
# endif
  {
    /* Send prepared NRC */
  }
  Dcm_SetNegResponse(lNrc);

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service27PostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service27PostProcessor(Dcm_ConfirmationStatusType status)
{
  /* If a positive response was successfully sent. */
  if(status == DCM_RES_POS_OK)
  {
    /* If it was a compare key request: */
    if((Dcm_InstanceContext.Repeater.Contexts.Context.Svc27.SfIdx & 0x01u) != 0) /* odd sfIdx means "send key" request */
    {
      /* Apply the new security state and reset seuqence. */
      Dcm_StateSetSecurity((Dcm_StateIndexOptType)(Dcm_Svc27GetCurReqLev() + 1u));/* locked = 0x00 -> level 1 = 0x01, etc.*/
    }
    else
    {
      /* If this was no zero seed response: */
      if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc27.IsZeroSeed == FALSE)
      {
        /* Prepare for key acceptance. */
        Dcm_InstanceContext.Diag.Services.Svc27.SeedLevel = Dcm_CfgStateSecurityInfo[Dcm_Svc27GetCurReqLev()].Value;
      }
      else
      {
        /* Otherwise, there is no key expected in that case after zero seed. */
        Dcm_Svc27ResetSequence();
      }
    }
  }
  else if((DCM_DIAG_RES_NEG_ANY & status) != 0) /* Otherwise, if any negative response was sent: */
  {
    /* Reset the key-seed-sequence. */
    Dcm_Svc27ResetSequence();
  }
  else /* POS_NOK */
  {
    /*
     * Otherwise no change required:
     *   - on SeedReq: the client shall retry the seed request or send another one
     *                 -> do not move to expect key fora certain level
     *   - on KeyReq:  the client may retry the key request to get a response
     *                 -> do not invalidate expect key for this level
     */
  }
}
# if (DCM_SVC_27_SEED_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27SeedProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service27SeedProcessor(Dcm_OpStatusType opStatus
                                                                 ,Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* If the attempt counters are currently read or written by the application: */
#  if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
  if(Dcm_TskGetEvent(DCM_TSK_ID_SVC27) != 0u)
  {
    lStdResult = DCM_E_PENDING;
  }
  else
#  endif
  {
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc27.IsZeroSeed = FALSE;

    /* If the security timer is not yet expired: */
#  if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
    if(!Dcm_Svc27TimerExpired(Dcm_Svc27GetCurReqLevAttemptIdx()))
    {
      /* Send the NRC 0x37. */
      Dcm_SetNegResponse(DCM_E_REQUIREDTIMEDELAYNOTEXPIRED);
      lStdResult = DCM_E_PROCESSINGDONE;
    }
    else
#  endif
    {
      /* If seed level not yet unlocked: */
      if(0 == ( Dcm_StateGetSecurity() & Dcm_UtiGetBitFromIndex(Dcm_CfgStateGroupMemType, (Dcm_Svc27GetCurReqLev() + 1u))))
      {
        /* New seed request / repetition of the same seed request. Get application generated seed. */
        Dcm_RepeaterSetCallee(Dcm_Service27SeedRepeater);
        lStdResult = DCM_E_LOOP;/* Speed up processing. */
      }
      else
      {
        /* return zero seed */
        Dcm_InstanceContext.Repeater.Contexts.Context.Svc27.IsZeroSeed = TRUE;
        Dcm_UtiMemSetUintX(pMsgContext->resData, Dcm_MsgItemType, 0x00u, Dcm_CfgSvc27SubFuncInfo[Dcm_InstanceContext.Repeater.Contexts.Context.Svc27.SfIdx].ResLength); /* PRQA S 3109 */ /* MD_MSR_14.3 */
        lStdResult = DCM_E_PROCESSINGDONE;
      }
    }
  }
  return lStdResult;
}
# endif

# if (DCM_SVC_27_KEY_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service27KeyProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service27KeyProcessor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext)                                                  /* PRQA S 3673 */ /* MD_Dcm_Design_3673 */
{
  Std_ReturnType lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */
  DCM_IGNORE_UNREF_PARAM(pMsgContext);                                                                                                               /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* If the attempt counters are currently read or written by the application: */
#  if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
  if(Dcm_TskGetEvent(DCM_TSK_ID_SVC27) != 0u)
  {
    lStdResult = DCM_E_PENDING;
  }
  else
#  endif
  {
    /* If the security level of the requested key matches to the previously sent seed request: */
    if(Dcm_CfgStateSecurityInfo[Dcm_Svc27GetCurReqLev()].Value == Dcm_InstanceContext.Diag.Services.Svc27.SeedLevel )
    {
      /* Get application key comparator. */
      Dcm_RepeaterSetCallee(Dcm_Service27KeyRepeater);
      lStdResult = DCM_E_LOOP; /* Speed up processing. */
    }
    else
    {
      /* Send NRC 0x24. */
      Dcm_SetNegResponse(DCM_E_REQUESTSEQUENCEERROR);

#  if (DCM_STATE_SEC_RETRY_ENABLED == STD_ON)
      /* If a seed request has been sent: */
      if(Dcm_InstanceContext.Diag.Services.Svc27.SeedLevel != DCM_SVC_27_SEED_LVL_INVALID)
      {
        /* Increment attempt counter.  */
        Dcm_Svc27CounterInc(Dcm_Svc27GetCurReqLevAttemptIdx());                                                                                      /* PRQA S 3109 */ /* MD_MSR_14.3 */

#   if (DCM_STATE_SEC_ATT_CNTR_EXT_STORAGE_ENABLED == STD_ON)
        /* Notify application about new attempt counter and wait until it is stored. */
        Dcm_RepeaterSetCallee(Dcm_Service27SetAttemptCntrRepeater);
        lStdResult = DCM_E_LOOP;
#   else
        lStdResult = DCM_E_PROCESSINGDONE;
#   endif
      }
      else
#  endif
      {
        /* Otherwise - send prepared NRC */
        lStdResult = DCM_E_PROCESSINGDONE;
      }
    }
  }
  return lStdResult;
}
# endif
#endif /* (DCM_SVC_27_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_28_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service28_XXProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service28_XXProcessor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext)                                                  /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
{
  uint8   msgType;
  boolean validParam = TRUE;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /*-- interpret communication type parameter --*/

  /* Check network type */
  {
    sint16_least lookUpResult;
    lookUpResult = Dcm_UtiLookUpUint8(Dcm_CfgSvc28SubNetIdLookUp, (uint8)(pMsgContext->reqData[0] >> 4u));

    if(lookUpResult >= 0)
    {
      Dcm_InstanceContext.Repeater.Contexts.Context.Svc28.NetworkRef = Dcm_CfgSvc28SubNetIdMap[lookUpResult];
# if (DCM_SVC_28_CURNET_SUPPORT_ENABLED == STD_ON)
      if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc28.NetworkRef == DCM_SVC_28_NETWORK_CURRENT)
      {
        Dcm_InstanceContext.Repeater.Contexts.Context.Svc28.NetworkRef = Dcm_PbCfgNetConnComMChannelMap[Dcm_PbCfgNetConnectionInfo[Dcm_NetTranspObjGetConnIdValue(Dcm_DiagGetTranspObj())].NetworkIdRef];
      }
# endif
    }
    else
    {
      validParam = FALSE;
    }
  }

  /* Check message type */
  {
    msgType = (uint8)(pMsgContext->reqData[0] & 0x0Fu);

    if(Dcm_UtiLookUpUint8(Dcm_CfgSvc28MessageTypeLookUpTable, msgType) < 0)
    {
      validParam = FALSE;
    }
  }

  if(validParam == TRUE)
  {
    /*--------------------------------------------------------------
    Message types      |   Operations                |ComParamValue
    (Affected = 1,     |                             |
     Not affected = 0) | (Enable = 0, Disable = 1)   |
    ------+------------+-----------------+-----------+
    NM    |    Appl    |    RxPath       |  TxPath   |
    ------+------------+-----------------+-----------+--------------
      0   |     0      |        x        |    x      |    -
      0   |     1      |        0        |    0      |    4
      0   |     1      |        0        |    1      |    5
      0   |     1      |        1        |    0      |    6
      0   |     1      |        1        |    1      |    7
      1   |     0      |        0        |    0      |    8
      1   |     0      |        0        |    1      |    9
      1   |     0      |        1        |    0      |    10
      1   |     0      |        1        |    1      |    11
      1   |     1      |        0        |    0      |    12
      1   |     1      |        0        |    1      |    13
      1   |     1      |        1        |    0      |    14
      1   |     1      |        1        |    1      |    15
    ------+------------+-----------------+-----------+--------------
    => ModeValue := ((msgType) & 0x03) << 2) | ((RxPath) & 0x01) << 1) | ((TxPath) & 0x01) ) ) - 4
    SubFunc == ((RxPath) & 0x01) << 1) | ((TxPath) & 0x01);
    => ModeValue := ((msgType) & 0x03) << 2) | (SubFunc) ) - 4
    */
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc28.ComMode = (Dcm_CommunicationModeType)( ( ((msgType & 0x03u) << 2) | (Dcm_InstanceContext.Repeater.Contexts.Context.Svc28.SubServiceId & DCM_SVC_28_CTRL_OP_MASK) ) - 4);
    /* Mark post-processor to execute requested action */
    Dcm_Svc28SetInternallyProcessed(TRUE);
  }
  else
  {
    Dcm_SetNegResponse(DCM_E_REQUESTOUTOFRANGE);
  }

  return DCM_E_PROCESSINGDONE;
}

/**********************************************************************************************************************
 *  Dcm_Service28Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service28Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext)
{
  Dcm_DiagSubServiceRefOptType  subSvcRef;
  Dcm_NegativeResponseCodeType  lNrc;
  Std_ReturnType                lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* Prepare all generic part (independently of the SF validation result!) */
  Dcm_Svc28SetInternallyProcessed(FALSE);
  Dcm_InstanceContext.Repeater.Contexts.Context.Svc28.SubServiceId = pMsgContext->reqData[0];

  lNrc = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                            ,Dcm_CfgSvc28SubFuncLookUpTable
                                            ,Dcm_CfgSvc28SubFuncExecPrecondTable
                                            ,Dcm_Svc28ReqLengthGetter
                                            ,&subSvcRef);

  if(lNrc == DCM_E_POSITIVERESPONSE)
  {
    Dcm_RepeaterSetCallee(Dcm_CfgSvc28SubFuncInfo[subSvcRef].SubSvcFunc); /* delegate job */
    lStdResult = DCM_E_LOOP;/* speed up processing */
  }
  else
  {
    /* NRC is already set */
    Dcm_SetNegResponse(lNrc);
    lStdResult = DCM_E_PROCESSINGDONE;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service28PostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service28PostProcessor(Dcm_ConfirmationStatusType status)
{
  if(status == DCM_RES_POS_OK)
  {
# if (DCM_SVC_28_USER_ENABLED == STD_ON)
    if(Dcm_Svc28IsInternallyProcessed())
# endif
    {
      Dcm_Svc28ApplyCommControl(Dcm_InstanceContext.Repeater.Contexts.Context.Svc28.NetworkRef,
                                Dcm_InstanceContext.Repeater.Contexts.Context.Svc28.ComMode);
    }
  }
}
#endif /* (DCM_SVC_28_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service2AProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service2AProcessor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType lStdReturn;
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_NET_MULTI_CONNECT_ENABLED == STD_ON)
  Dcm_InstanceContext.Repeater.Contexts.Context.Svc2A.ConnId = Dcm_NetTranspObjGetConnIdValue(Dcm_DiagGetTranspObj());
#  if(DCM_NET_PROTECT_SESSION_OF_CLIENT_ENABLED == STD_ON)
  /* protected by the session connection ownership */
#  else
  if( (Dcm_NetPeriodicMsgGetConnection() != DCM_NET_INVALID_CONNID)
    &&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2A.ConnId != Dcm_NetPeriodicMsgGetConnection()) )
  {
    Dcm_SetNegResponse(DCM_E_CONDITIONSNOTCORRECT); /* the 2A service is currently in use by another client */
    lStdReturn = DCM_E_PROCESSINGDONE;
  }
  else
#  endif
#  if (DCM_NET_PERIODIC_TX_CONN_SPECIFIC_NUM_TX_OBJ_ENABLED == STD_ON)
  if(!Dcm_NetPeriodicMsgSupportedFor(Dcm_NetTranspObjGetConnIdValue(Dcm_DiagGetTranspObj())))
  {
    Dcm_SetNegResponse(DCM_E_PANIC_NRC); /* current client does not support periodic messages */
    lStdReturn = DCM_E_PROCESSINGDONE;
  }
  else
#  endif
# endif
  {
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc2A.HasAnySupportedDids = FALSE;
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc2A.UdsRate = pMsgContext->reqData[0];
    /* move on to first PDID byte */
    Dcm_DiagMoveOnReqWithLength(pMsgContext, 1u);                                                                                                    /* PRQA S 3109 */ /* MD_MSR_14.3 */

    if(pMsgContext->reqDataLen <= DCM_SVC_2A_MAX_DID_LIST_LEN)
    {
      if( (Dcm_InstanceContext.Repeater.Contexts.Context.Svc2A.UdsRate <= 4u)
        &&((DCM_SVC_2A_SUPPORTED_RATES & Dcm_UtiGetBitFromIndex(uint8, Dcm_InstanceContext.Repeater.Contexts.Context.Svc2A.UdsRate)) != 0) )
      {
        if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2A.UdsRate != 4u)
        {
          lStdReturn = Dcm_Svc2ADoScheduleDids(pMsgContext);
        }
        else
        {
          lStdReturn = Dcm_Svc2AStopScheduledDids(pMsgContext);
        }
      }
      else
      {
        Dcm_SetNegResponse(DCM_E_REQUESTOUTOFRANGE);
        lStdReturn = DCM_E_PROCESSINGDONE;
      }
    }
    else
    {
      Dcm_SetNegResponse(DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT);
      lStdReturn = DCM_E_PROCESSINGDONE;
    }
  }

  return lStdReturn;
}

/**********************************************************************************************************************
 *  Dcm_Service2APostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service2APostProcessor(Dcm_ConfirmationStatusType status)
{
  if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2A.UdsRate != 4u)
  {
    if(status == DCM_RES_POS_OK)
    {
      Dcm_Svc2ASchdCommit(Dcm_Svc2AMakeSchdRateFromUdsRate(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2A.UdsRate));
      Dcm_NetPeriodicMsgSetConnection(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2A.ConnId);
    }
    else
    {
      Dcm_Svc2ASchdDiscard();
    }
  }/* else - nothing */
}
#endif /* (DCM_SVC_2A_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
# if (DCM_SVC_2C_01_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service2C_01Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service2C_01Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType lStdReturn;

  lStdReturn = Dcm_Svc2CParseAndCheckDynDid(opStatus, pMsgContext);

  if(lStdReturn == DCM_E_OK)
  {
    /* there shall be an iteration (+[4Byte]) */
    if( (pMsgContext->reqDataLen > 0u)
      &&( (pMsgContext->reqDataLen % 4u) == 0) )
    {
      Dcm_NegativeResponseCodeType lNrc;

      pMsgContext->reqDataLen /= 4u;/* calculate number of source items to be processed */

      /* check DynDID capacity */
      lNrc = Dcm_Svc2CCheckNumOfItems(pMsgContext);
      if(lNrc == DCM_E_POSITIVERESPONSE)
      {
        Dcm_RepeaterSetCallee(Dcm_Svc2C_01SrcDidLookUp);
        lStdReturn =  DCM_E_LOOP;/* speed up processing */
      }
      else
      {
        /* else - lNrc already set */
        Dcm_SetNegResponse(lNrc);
        lStdReturn = DCM_E_PROCESSINGDONE;
      }
    }
    else
    {
      Dcm_SetNegResponse(DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT);
      lStdReturn = DCM_E_PROCESSINGDONE;
    }
  }/* else - just return the value: DCM_E_PENDING, DCM_E_PROCESSINGDONE (lNrc already set) */

  return lStdReturn;
}
# endif

# if (DCM_SVC_2C_02_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service2C_02Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service2C_02Processor(Dcm_OpStatusType opStatus, Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType lStdReturn;

  lStdReturn = Dcm_Svc2CParseAndCheckDynDid(opStatus, pMsgContext);

  if(lStdReturn == DCM_E_OK)
  {
    Dcm_NegativeResponseCodeType lNrc;

    /* the ALFID availability is checked within next call */
    lNrc = Dcm_MemMgrValidateAlfid(pMsgContext->reqData, &(pMsgContext->reqDataLen));
    if(lNrc == DCM_E_POSITIVERESPONSE)
    {
      Dcm_MsgType            lReqData;
      Dcm_MemMgrMemBlockType lMemBlock;
      uint8                  blockLength;

      lReqData = &pMsgContext->reqData[1];
      blockLength = Dcm_MemMgrGetMemBlockInfoLength(pMsgContext->reqData[0]);
      pMsgContext->reqDataLen += blockLength;/* restore the block length removed in the CheckALFID API (only the ALFID byte remains removed) */

      /* pMsgContext->reqDataLen cannot be zero! */
      if((pMsgContext->reqDataLen % blockLength) == 0) /* the remained request length shall be a multiple of the memory address and size request block */
      {
        pMsgContext->reqDataLen /= blockLength;/* calculate number of items to be processed */

        /* check DynDID capacity */
        lNrc = Dcm_Svc2CCheckNumOfItems(pMsgContext);
        if(lNrc == DCM_E_POSITIVERESPONSE)
        {
          do
          {
            lReqData = Dcm_MemMgrParseMemStream(pMsgContext->reqData[0]
                                               ,lReqData
                                               ,&lMemBlock);
            lNrc = Dcm_MemMgrCheckMemBlock(&lMemBlock, DCM_MEMMGR_OP_READ);

            if(lNrc != DCM_E_POSITIVERESPONSE)
            {
              /* stop immediately and report the error */
              Dcm_SetNegResponse(lNrc);
              Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.ReqNumOfItems = 0; /* break */
            } /* else - check for definition length overflow */
            else if( (lMemBlock.Length > DCM_SVC_2C_READ_BUFFER_SIZE)
                   ||(!Dcm_UtiIsAdditionSafe(uint32, Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidLength, lMemBlock.Length))
                   ||(Dcm_UtiPromotedSum(uint32, Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidLength, lMemBlock.Length) > Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.MaxAllowedLength) )
            {
              Dcm_SetNegResponse(DCM_E_REQUESTOUTOFRANGE);/* too much data referenced  */
              /* finish service processing immediately */
              Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.ReqNumOfItems = 0; /* break */
            }
            else
            {
              /* else - add this address to the DynDID definition */

              /* update total length of the DynDID for commitment */
              Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidLength += (Dcm_CfgNetBufferSizeMemType)(lMemBlock.Length);

              Dcm_UtiAssignStruct(Dcm_InstanceContext.Diag.Services.Svc2C.SrcItems[Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.SrcItemIndex].MemDescriptor.MemBlock /* PRQA S 0310 */ /* MD_Dcm_GenericStructAssign_0310 */
                                 ,lMemBlock
                                 ,Dcm_MemMgrMemBlockType);                                                                                           /* PRQA S 3109 */ /* MD_Dcm_CfgDepend_3109 */

              Dcm_Svc2CSetMemSrcItem(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.SrcItemIndex); /* set the type of the source item to MEMORY */
              ++Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.SrcItemIndex; /* next item to be configured */
              ++Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidItemCount; /* update number of items for commitment */
              --Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.ReqNumOfItems;/* commit processed item */
            }
          }
          while(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.ReqNumOfItems != 0);
        }
        else
        {
          /* else - lNrc already set */
          Dcm_SetNegResponse(lNrc);
        }
      }
      else
      {
        /* else - lNrc already set to 0x13 */
        Dcm_SetNegResponse(DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT);
      }
    }
    else
    {
      /* else - lNrc already set */
      Dcm_SetNegResponse(lNrc);
    }
  }/* else - just return the value: DCM_E_PENDING, DCM_E_PROCESSINGDONE (lNrc already set) */

  return DCM_E_PROCESSINGDONE;
}                                                                                                                                                    /* PRQA S 6080 */ /* MD_MSR_STMIF */
# endif

# if (DCM_SVC_2C_03_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service2C_03Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service2C_03Processor(Dcm_OpStatusType opStatus
                                                                ,Dcm_MsgContextPtrType pMsgContext)                                                  /* PRQA S 3673 */ /* MD_Dcm_APIStd_3673 */
{
  Std_ReturnType lStdReturn;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidItemCount = 0u; /* prepare for a successful clear */

  if(pMsgContext->reqDataLen == 0u)
  {
    /* clear all DynDID definitions */
    Dcm_CfgDidMgrDynDidHandleOptType dynDidIter;
    for(dynDidIter = 0; dynDidIter < DCM_NUM_DYNDIDS; ++dynDidIter)
    {
      Dcm_Svc2CDefMgrClear((Dcm_CfgDidMgrDynDidHandleMemType)dynDidIter);
    }
    lStdReturn = DCM_E_PROCESSINGDONE;
  }
  else if (pMsgContext->reqDataLen == 2u)
  {
    Dcm_RepeaterSetCallee(Dcm_Svc2C_03DidLookUp); /* next job */
    lStdReturn = DCM_E_LOOP;/* speed up processing */
  }
  else
  {
    Dcm_SetNegResponse(DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT);
    lStdReturn = DCM_E_PROCESSINGDONE;
  }
  return lStdReturn;
}
# endif

/**********************************************************************************************************************
 *  Dcm_Service2CProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service2CProcessor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext)
{
  Dcm_DiagSubServiceRefOptType  subSvcRef;
  Dcm_NegativeResponseCodeType  lNrc;
  Std_ReturnType                lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lNrc = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                              ,Dcm_CfgSvc2CSubFuncLookUpTable
                                              ,Dcm_CfgSvc2CSubFuncExecPrecondTable
                                              ,Dcm_Svc2CReqLengthGetter
                                              ,&subSvcRef);
  if(lNrc == DCM_E_POSITIVERESPONSE)
  {
    /* Perform SID specific checks */
    if(Dcm_CfgSvc2CSubFuncInfo[subSvcRef].MinReqLength <= pMsgContext->reqDataLen) /* min length = (DDID, (MEMdef|DIDdef))?  */
    {
      Dcm_RepeaterSetCallee(Dcm_CfgSvc2CSubFuncInfo[subSvcRef].SubSvcFunc); /* delegate job */
      lStdResult = DCM_E_LOOP;/* speed up processing */
    }
    else
    {
      Dcm_SetNegResponse(DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT);
      lStdResult = DCM_E_PROCESSINGDONE;
    }
  }
  else
  { /* NRC already set */
    Dcm_SetNegResponse(lNrc);
    lStdResult = DCM_E_PROCESSINGDONE;
  }

  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service2CPostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service2CPostProcessor(Dcm_ConfirmationStatusType status)
{
  if(status == DCM_RES_POS_OK)
  {
    if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidItemCount != 0u)/* this is a definition service , not the clear one*/
    {
# if (DCM_DIDMGR_PERIODICDYNDID_ENABLED == STD_ON) && \
     (DCM_DIDMGR_ASYNC_DID_SUPPORT_ENABLED == STD_ON)
      uint16 lDid = Dcm_DidMgrGetDynDidIdFromHandle(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidHandle);
      /* Kill any still not finished read periodic DID jobs to avoid inconsistent response data/length ! */
      Dcm_Svc2ASchdCancelReadByDid(lDid);
# endif
      /* Commit DynDID definition immediately */
      Dcm_InstanceContext.Diag.Services.Svc2C.Items[Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidHandle].Length = Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidLength;
      Dcm_InstanceContext.Diag.Services.Svc2C.Items[Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidHandle].Count  = Dcm_InstanceContext.Repeater.Contexts.Context.Svc2C.DynDidItemCount;
    } /* else - the dynDid has been already cleared */
  } /* else - the dynDid list properties will not be changed - all prepared data will be discarded */
}
#endif /* (DCM_SVC_2C_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service2EProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service2EProcessor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType lStdResult;
  Dcm_NegativeResponseCodeType  lNrc;

  /* Min Length already checked in DiagDispatcher and expected to be 3 !!! */
  Dcm_InstanceContext.Repeater.Contexts.Context.Svc2E.DidInfoContext.Did =  Dcm_UtiMake16Bit(pMsgContext->reqData[0], pMsgContext->reqData[1]);
  lStdResult = Dcm_DidMgrGetDidInfo(opStatus
                                   ,&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2E.DidInfoContext)
                                   ,&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2E.DidOpTypeContext)
                                   ,DCM_DIDMGR_OP_WRITE);

  if(lStdResult == DCM_E_OK)
  {
    /* Extract DID */
    Dcm_DiagMoveOnReqWithLength(pMsgContext, 2u);                                                                                                    /* PRQA S 3109 */ /* MD_MSR_14.3 */
    Dcm_DiagMoveOnResWithLength(pMsgContext, 2u);/* return the DID (shared RX-TX buffer) */                                                          /* PRQA S 3109 */ /* MD_MSR_14.3 */

    /* Check DID specific length */
# if (DCM_DIDMGR_WRITE_DYNLEN_DID_SUPPORT_ENABLED == STD_ON)
    if(  (0 < pMsgContext->reqDataLen) /* cover the case where a DID with dynamic length has only one data element (i.e. DidInfoPtr->MinLength == 0) */
       &&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2E.DidInfoContext.Descriptor.DidInfoPtr->MinLength    <= pMsgContext->reqDataLen)
       &&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2E.DidInfoContext.Descriptor.DidInfoPtr->Length >= pMsgContext->reqDataLen) )
# else
    if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2E.DidInfoContext.Descriptor.DidInfoPtr->Length == pMsgContext->reqDataLen)
# endif
    {
      lNrc = Dcm_DidMgrStaticDidStateCheck(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2E.DidInfoContext.Descriptor.DidOpInfoPtr->ExecCondRef);
      if(lNrc == DCM_E_POSITIVERESPONSE)
      {
        Dcm_DidMgrGetOpClassInfo(&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2E.DidInfoContext), DCM_DIDMGR_OPTYPE_WRITE);
# if (DCM_DIDMGR_2E_ACCESS_LOCK_ENABLED == STD_ON)
        Dcm_RepeaterSetCallee(Dcm_Svc2ECheckAccess); /* delegate job */
# else
        Dcm_RepeaterSetCallee(Dcm_Svc2EExecuteOp); /* delegate job */
# endif
        lStdResult = DCM_E_LOOP;/* speed up processing */
      }
      else
      {
        /* else - lNrc already assigned */
        Dcm_SetNegResponse(lNrc);
        lStdResult = DCM_E_PROCESSINGDONE;
      }
    }
    else
    {
      Dcm_SetNegResponse(DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT);
      lStdResult = DCM_E_PROCESSINGDONE;
    }
  }
  else if (lStdResult == DCM_E_PENDING)
  {
    /* DCM_E_PENDING -> try again */
  }
  else
  {
    Dcm_SetNegResponse(DCM_E_REQUESTOUTOFRANGE);
    lStdResult = DCM_E_PROCESSINGDONE;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_2E_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service2FProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service2FProcessor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType lStdResult;

  /* Min Length already checked in DiagDispatcher and expected to be 3 !!! */
  Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidInfoContext.Did = Dcm_UtiMake16Bit(pMsgContext->reqData[0], pMsgContext->reqData[1]);

  lStdResult = Dcm_DidMgrGetDidInfo(opStatus
                                   ,&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidInfoContext)
                                   ,&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidOpTypeContext)
                                   ,DCM_DIDMGR_OP_IO);

  if (lStdResult == DCM_E_OK)
  {
    /* convert from UDS to internal operation representation */
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.OpType = (Dcm_DidMgrOpMemType)((pMsgContext->reqData[2] < 4u)
                                                                                    ?Dcm_Svc2FCtrlOp2DidOpTypeMap[pMsgContext->reqData[2]]/* use interpreted value */
                                                                                    :0x00u); /* no supported operation */
    /* Check for supported sub-operation */
    if(Dcm_DidMgrIsOpTypeSupported(Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.DidInfoContext.Descriptor.DidOpInfoPtr
                                  ,Dcm_InstanceContext.Repeater.Contexts.Context.Svc2F.OpType) )
    {
      /* Extract header */
      Dcm_DiagMoveOnReqWithLength(pMsgContext,3);                                                                                                    /* PRQA S 3109 */ /* MD_MSR_14.3 */
      Dcm_DiagMoveOnResWithLength(pMsgContext,3);                                                                                                    /* PRQA S 3109 */ /* MD_MSR_14.3 */

      lStdResult = Dcm_Svc2FIoDidOperationProcessor(pMsgContext);
    }
    else
    {
      Dcm_SetNegResponse(DCM_E_REQUESTOUTOFRANGE);
      lStdResult = DCM_E_PROCESSINGDONE;
    }
  }
  else if(lStdResult == DCM_E_NOT_OK)
  {
    Dcm_SetNegResponse(DCM_E_REQUESTOUTOFRANGE);
    lStdResult = DCM_E_PROCESSINGDONE;
  }
  else
  {
    /* DCM_E_PENDING -> try again */
  }

  /* Reaching this point means diagnostic error was found */
  return lStdResult;
}

/**********************************************************************************************************************
 *  Dcm_Service2FPostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service2FPostProcessor(Dcm_ConfirmationStatusType status)
{
  DCM_IGNORE_UNREF_PARAM(status);                                                                                                                    /* PRQA S 3112 */ /* MD_Dcm_3112 */

# if (DCM_DIDMGR_2F_ACCESS_LOCK_ENABLED == STD_ON)
  Dcm_InstanceContext.DidMgr.DidRsrcContext.Io = 0u;
# endif
}
#endif /* (DCM_SVC_2F_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_31_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service31Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service31Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType lStdReturn;

  /* Min Length already checked in DiagDispatcher and expected to be 3 !!! */
  lStdReturn = Dcm_RidMgrRidLookUp(opStatus
                                  ,Dcm_UtiMake16Bit(pMsgContext->reqData[1], pMsgContext->reqData[2])
                                  ,&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc31.RidInfoPtr));

  if(lStdReturn == DCM_E_OK)
  {
    Dcm_NegativeResponseCodeType  lNrc;
    lNrc = Dcm_RidMgrStateCheckRid(Dcm_InstanceContext.Repeater.Contexts.Context.Svc31.RidInfoPtr->ExecCondRef);
    if(lNrc == DCM_E_POSITIVERESPONSE)
    {
      Dcm_InstanceContext.Repeater.Contexts.Context.Svc31.Op = Dcm_RidMgrConvOpOfSubFunc(pMsgContext->reqData[0]);
      Dcm_InstanceContext.Repeater.Contexts.Context.Svc31.RidOpInfoPtr = Dcm_RidMgrGetOpInfo(Dcm_InstanceContext.Repeater.Contexts.Context.Svc31.RidInfoPtr, Dcm_InstanceContext.Repeater.Contexts.Context.Svc31.Op);

      if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc31.RidOpInfoPtr != NULL_PTR)
      {
        if(
# if (DCM_RIDMGR_DYN_REQ_LEN_ENABLED == STD_ON)
          ( ((Dcm_InstanceContext.Repeater.Contexts.Context.Svc31.RidOpInfoPtr->DynLenMask & DCM_RIDMGR_DYNLEN_MASK_REQ) != 0)
          &&(Dcm_InstanceContext.Repeater.Contexts.Context.Svc31.RidOpInfoPtr->ReqLength >= pMsgContext->reqDataLen) ) ||
# endif
          (Dcm_InstanceContext.Repeater.Contexts.Context.Svc31.RidOpInfoPtr->ReqLength == pMsgContext->reqDataLen) )
        {
          /* Extract SF and RID */
          Dcm_DiagMoveOnReqWithLength(pMsgContext, 3u);                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
# if (DCM_RIDMGR_DYN_REQ_LEN_ENABLED == STD_ON)
          Dcm_DiagUpdateReqLength(pMsgContext, Dcm_InstanceContext.Repeater.Contexts.Context.Svc31.RidOpInfoPtr->ReqMinLength);/* reduce request length up to the last dynamic signal (if any) */
# endif
          Dcm_DiagUpdateResLength(pMsgContext, Dcm_InstanceContext.Repeater.Contexts.Context.Svc31.RidOpInfoPtr->ResLength);/* for static length - consider it now, if dynamic -> only the static part will be added */
          Dcm_DiagMoveOnRes(pMsgContext, 3u);

          Dcm_RepeaterSetCallee(Dcm_Svc31ExecuteOp); /* delegate job */
          lStdReturn = DCM_E_LOOP;/* speed up processing */
        }
        else
        {
          Dcm_SetNegResponse(DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT);
          lStdReturn = DCM_E_PROCESSINGDONE;
        }
      }
      else
      {
        Dcm_SetNegResponse(DCM_E_SUBFUNCTIONNOTSUPPORTED);
        lStdReturn = DCM_E_PROCESSINGDONE;
      }
    }/* else - lNrc already assigned */
    else
    {
      Dcm_SetNegResponse(lNrc);
      lStdReturn = DCM_E_PROCESSINGDONE;
    }
  }
  else if(lStdReturn == DCM_E_PENDING)
  {
    /* lStdReturn is already set */
  }
  else
  {
    Dcm_SetNegResponse(DCM_E_REQUESTOUTOFRANGE);
    lStdReturn = DCM_E_PROCESSINGDONE;
  }

  return lStdReturn;
}
#endif /* (DCM_SVC_31_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service3DProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service3DProcessor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext)
{
  Std_ReturnType lStdReturn;
  Dcm_NegativeResponseCodeType lNrc;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  /* dispatcher guarantees for minimum length of 4 bytes (ALFID + MEM + SIZE + DATA) available */
  lNrc = Dcm_MemMgrValidateAlfid(pMsgContext->reqData, &pMsgContext->reqDataLen);
  if(lNrc == DCM_E_POSITIVERESPONSE)
  {
    lNrc = DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT;
    /* check for exact length match */
    pMsgContext->resDataLen = (uint8)(Dcm_MemMgrGetMemBlockInfoLength(pMsgContext->reqData[0]) + 1u); /* (ALFID + MEM + SIZE) */
    pMsgContext->reqData = Dcm_MemMgrParseMemStream(pMsgContext->reqData[0]
                                                   ,&pMsgContext->reqData[1]
                                                   ,&Dcm_InstanceContext.Repeater.Contexts.Context.Svc3D.MemBlock);

    if(Dcm_InstanceContext.Repeater.Contexts.Context.Svc3D.MemBlock.Length == pMsgContext->reqDataLen)
    {
      lNrc = Dcm_MemMgrCheckMemBlock(&Dcm_InstanceContext.Repeater.Contexts.Context.Svc3D.MemBlock, DCM_MEMMGR_OP_WRITE);
      if(lNrc == DCM_E_POSITIVERESPONSE)
      {
# if (DCM_MEMMGR_ACCESS_LOCK_ENABLED == STD_ON)
        Dcm_RepeaterSetCallee(Dcm_Svc3DCheckAccess);
# else
        Dcm_RepeaterSetCallee(Dcm_Svc3DWriteMemory);
# endif
        lStdReturn = DCM_E_LOOP;/* speed up processing */
      }
      else
      {
        /* else - lNrc is already set */
        Dcm_SetNegResponse(lNrc);
        lStdReturn = DCM_E_PROCESSINGDONE;
      }
    }
    else
    {
      /* else - lNrc is already set */
      Dcm_SetNegResponse(lNrc);
      lStdReturn = DCM_E_PROCESSINGDONE;
    }
  }
  else
  {
    /* else - lNrc is already set */
    Dcm_SetNegResponse(lNrc);
    lStdReturn = DCM_E_PROCESSINGDONE;
  }
  return lStdReturn;
}
#endif /* (DCM_SVC_3D_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_3E_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service3EProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service3EProcessor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext)
{
  Dcm_DiagSubServiceRefOptType  subSvcRef;

  /* Check that the module is initialized. */
  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  Dcm_SetNegResponse(Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                                         ,Dcm_CfgSvc3ESubFuncLookUpTable
                                                         ,Dcm_CfgSvc3ESubFuncExecPrecondTable
                                                         ,Dcm_DiagSvcWithOnlySubFuncReqLengthGetter
                                                         ,&subSvcRef));

  /* Finish diagnostic job processing. */
  return DCM_E_PROCESSINGDONE;
}
#endif /* (DCM_SVC_3E_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_85_SUPPORT_ENABLED == STD_ON)
/**********************************************************************************************************************
 *  Dcm_Service85Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service85Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext)
{
  Dcm_DiagSubServiceRefOptType  subSvcRef;
  Dcm_NegativeResponseCodeType  lNrc;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lNrc = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                             ,Dcm_CfgSvc85SubFuncLookUpTable
                                             ,Dcm_CfgSvc85SubFuncExecPrecondTable
                                             ,Dcm_Svc85ReqLengthGetter
                                             ,&subSvcRef);
  if(lNrc == DCM_E_POSITIVERESPONSE)
  {
    Dem_ReturnControlDTCSettingType lDemResult;

    Dcm_InstanceContext.Repeater.Contexts.Context.Svc85.ReqMode = Dcm_CfgSvc85SubFuncInfo[subSvcRef].Mode;

# if (DCM_SVC_85_DTC_GRP_ENABLED == STD_ON)
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc85.DTCGroup = Dcm_UtiMake32Bit(0x00u
                                                                                   ,pMsgContext->reqData[0]
                                                                                   ,pMsgContext->reqData[1]
                                                                                   ,pMsgContext->reqData[2]);
# else
    Dcm_InstanceContext.Repeater.Contexts.Context.Svc85.DTCGroup = DEM_DTC_GROUP_ALL_DTCS;
# endif

    lDemResult = Dcm_CfgSvc85SubFuncInfo[subSvcRef].DemFunc(Dcm_InstanceContext.Repeater.Contexts.Context.Svc85.DTCGroup
                                                           ,DEM_DTC_KIND_ALL_DTCS);

    switch(lDemResult)
    {
    case DEM_CONTROL_DTC_SETTING_OK:
      /* success */
      break;
    case DEM_CONTROL_DTC_SETTING_N_OK:
      lNrc = DCM_E_CONDITIONSNOTCORRECT;
      break;
# if (DCM_SVC_85_DTC_GRP_ENABLED == STD_ON)
    case DEM_CONTROL_DTC_WRONG_DTCGROUP:
      lNrc = DCM_E_REQUESTOUTOFRANGE;
      break;
# endif
    default:
      lNrc = DCM_E_PANIC_NRC;
      Dcm_DebugReportError(DCM_SID_INTERNAL, DCM_E_INTERFACE_RETURN_VALUE);
      break;
    }
  }/* else - NRC already set */

  Dcm_SetNegResponse(lNrc);
  return DCM_E_PROCESSINGDONE;
}

/**********************************************************************************************************************
 *  Dcm_Service85PostProcessor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *********************************************************************************************************************/
FUNC(void, DCM_CALLOUT_CODE) Dcm_Service85PostProcessor(Dcm_ConfirmationStatusType status)
{
  /* If a positive response was (successfully) sent: */
  if((status & DCM_DIAG_RES_NEG_ANY) == 0)
  {
    /* Trigger the requested mode switch. */
    Dcm_ModeSwitchDtcSetting(Dcm_InstanceContext.Repeater.Contexts.Context.Svc85.ReqMode
                            ,Dcm_InstanceContext.Repeater.Contexts.Context.Svc85.DTCGroup);
  }
}
#endif /* (DCM_SVC_85_SUPPORT_ENABLED == STD_ON) */
#if (DCM_SVC_86_SUPPORT_ENABLED == STD_ON)                                                                                                           /* COV_DCM_UNSUPPORTED XF */
/**********************************************************************************************************************
 *  Dcm_Service86Processor()
 *********************************************************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *********************************************************************************************************************/
FUNC(Std_ReturnType, DCM_CALLOUT_CODE) Dcm_Service86Processor(Dcm_OpStatusType opStatus
                                                             ,Dcm_MsgContextPtrType pMsgContext)
{
  Dcm_DiagSubServiceRefOptType  subSvcRef;
  Dcm_NegativeResponseCodeType  lNrc;
  Std_ReturnType                lStdResult;

  DCM_IGNORE_UNREF_PARAM(opStatus);                                                                                                                  /* PRQA S 3112 */ /* MD_Dcm_3112 */

  lNrc = Dcm_DiagVerifyServiceWithSubFunction(pMsgContext
                                              ,Dcm_CfgSvc86SubFuncLookUpTable
                                              ,Dcm_CfgSvc86SubFuncExecPrecondTable
                                              ,Dcm_Svc86ReqLengthGetter
                                              ,&subSvcRef);

  if(lNrc == DCM_E_POSITIVERESPONSE)
  {
    Dcm_RepeaterSetCallee(Dcm_CfgSvc86SubFuncInfo[subSvcRef].SubSvcFunc); /* delegate job */
    lStdResult = DCM_E_LOOP;/* speed up processing */
  }
  else
  {
    /* NRC is already set */
    Dcm_SetNegResponse(lNrc);
    lStdResult = DCM_E_PROCESSINGDONE;
  }

  return lStdResult;
}
#endif /* (DCM_SVC_86_SUPPORT_ENABLED == STD_ON) */
#define DCM_STOP_SEC_CALLOUT_CODE
/*lint -save -esym(961, 19.1)*/
#include "MemMap.h"                                                                                                                                  /* PRQA S 5087 */ /* MD_MSR_19.1 */
/*lint -restore*/
/* ----------------------------------------------
 ~&&&   MISRA
---------------------------------------------- */
/* module specific MISRA deviations:

   MD_Dcm_Design_0715
     Description: Rule 1.1
                  All code shall conform to ISO 9899:1990 C programming language, ISO 9899, amended and corrected by
                  ISO/IEC 9899/COR1:1995, ISO/IEC 9899/AMD1:1995, and ISO/IEC 9899/COR2: 1996
     Reason:      Time critical code path averts restructuring into multiple functions
     Risk:        Compilation error, lost logical paths.
     Prevention:  Compiler compatibility is tested during integration.

   MD_Dcm_BitNegation_0277:
     Description: Rule 3.1
                  All usage of implementation-defined behaviour shall be documented.
     Reason:      Using the ~ operator avoids errors in manually typed bit masks.
     Risk:        May generate compiler warnings although explicit casts are used.
     Prevention:  None.

   MD_Dcm_QacIssue_0504:
     Description: Rule 1.2
                  Dereferencing pointer value that is apparently NULL.
     Reason:      Pointer is checked against NULL, but prior dereferencing it it is assigned to a non-NULL value. Seems to be an issue in QAC.
     Risk:        No risks, since pointer value is definitely non-zero.
     Prevention:  None.

   MD_Dcm_Optimize_0759:
     Description: Rule 18.4
                  An object of union type has been defined.
     Reason:      An union object has been defined to optimize RAM usage for not in parallel executed jobs.
     Risk:        No risks, since all members of this shared RAM have always mutually exclusive access (i.e. service processor cannot be executed in parallel to another one).
     Prevention:  None.

   MD_Dcm_CfgDepend_0777:
     Description: Rule 5.1
                  Identifiers (internal and external) shall not rely on the significance of more than 31 characters.
     Reason:      It depends on the module's configuration (user settings) on how long the identifiers will be.
     Risk:        Compilation errors are possible.
     Prevention:  The user shall choose shorter names while configuring the module.

   MD_Dcm_Understand_0779:
     Description: Rule 5.1
                  Identifiers (internal and external) shall not rely on the significance of more than 31 characters.
     Reason:      Code maintainability requires structured names conflicting with this limitation.
     Risk:        Compilation errors are possible.
     Prevention:  Compiler compatibility is tested during integration.

   MD_Dcm_CodingRule_3218:
     Description: Rule 8.7
                  Objects shall be defined at block scope if they are only accessed from within a single function.
     Reason:      Vector style guide prevents usage of static variables/constant objects in function scope.
     Risk:        None.
     Prevention:  None.
   
   MD_Dcm_3353:
    Description: Rule 9.1: The variable '%s' is possibly unset at this point.
    Reason:      A variable is only set under certain conditions in another branch; when used later, a preceding check which verifies that the specific condition are fulfilled is not recognized by QAC.
    Risk:        Variable may be unset.
    Prevention:  Review, runtime tests in test suite.

   MD_Dcm_AbstractTokenReplacment_3410:
     Description: Rule 19.10
                  Macro parameter not enclosed in ().
     Reason:      The macro parameter represents an abstract token: either data type or operation, or structure member, etc.. If encolsed in () the code will not compile.
     Risk:        In worst case, the code will not compile due to unknown or not expected token.
     Prevention:  None.

   MD_Dcm_OptimizedInlineCode_3440:
     Description: Rule 12.13
                  Result of ++ or -- operator used in expression.
     Reason:      This kind of operator is used only in case of function-like macros where also a return value is expected. Needed for maximum inlining efficiency and less other MISRA deviations.
     Risk:        The risks are at minimum since the affected locations are simple expressions.
     Prevention:  These code sections are thoroughly tested by dedicated unit tests.

   MD_Dcm_0313:
     Description: Rule 11.1
                  Conversions shall not be performed between a pointer to a function and any type other than an integral type.
     Reason:      No efficient dynamic-cast operation available in ANSI-C.
     Risk:        Data corruption due to miscast.
     Prevention:  Covered by descriptive pointer types and code review for correct usage.

   MD_Dcm_GenericStructAssign_0310:
     Description: Rule 11.4
                  A cast should not be performed between a pointer to object type and a different pointer to object type.
     Reason:      For some compilers there is a workaround that helps perform generic structure assignments. Usually this operation is left to the compiler.
     Risk:        Compile error/warnings.
     Prevention:  Compiler compatibility is tested during integration.

   MD_Dcm_DifferentPointerType_0310:
     Description: Rule 11.4
                  A cast should not be performed between a pointer to object type and a different pointer to object type.
     Reason:      To optimize access without the need of local variable, pointers to data types of the same size (uint8, sint8) will be casted to the corresponding target pointer type.
     Risk:        Compile error/warnings.
     Prevention:  Compiler compatibility is tested during integration.

   MD_Dcm_3112:
     Description: Rule 14.2
                  All non-null statements shall either (i) have at least one side-effect however executed, or
                  (ii) cause control flow to change.
     Reason:      This statement is used to avoid warnings caused by unused parameters. Parameters are defined by
                  standardized API requirements, and not needed in case a feature is disabled by configuration.
                  It is either impossible due to API standardization or necessary code duplication (severe maintenance
                  increase) to provide feature dependent APIs with different signatures.
     Risk:        Unavoidable compiler warning or error because of either unused statements or unused parameter.
     Prevention:  None.

   MD_Dcm_CfgDepend_3109:
     Description: Rule 14.3
                  Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a
                  comment provided that the first character following the null statement is a white-space character.
     Reason:      The statement can be empty or not - it is configuration parameter dependent.
     Risk:        None.
     Prevention:  None.

   MD_Dcm_Optimize_0771:
     Description: Rule 14.6
                  For any iteration statement there shall be at most one break statement used for loop termination.
     Reason:      The loop needs multiple exit points since error conditions cannot be verified prior to the loop.
     Risk:        None.
     Prevention:  None.

   MD_Dcm_Optimize_3333:
     Description: Rule 14.6
                  For any iteration statement there shall be at most one break statement used for loop termination.
     Reason:      The loop/switch needs multiple exit points for more efficient run-time/ROM usage for complex program flows.
     Risk:        None.
     Prevention:  None.

   MD_Dcm_Optimize_2006:
     Description: Rule 14.7
                  A function shall have a single point of exit at the end of the function.
     Reason:      For code run-time/ROM usage reason this function terminates immediately.
     Risk:        None.
     Prevention:  None.

   MD_Dcm_APIStd_3673:
     Description: Rule 16.7
                  A pointer parameter in a function prototype should be declared as pointer to const if the pointer is
                  not used to modify the addressed object.
     Reason:      The API is defined by the AUTOSAR standardization.
     Risk:        None.
     Prevention:  None.

   MD_Dcm_Design_3673:
     Description: Rule 16.7
                  A pointer parameter in a function prototype should be declared as pointer to const if the pointer is
                  not used to modify the addressed object.
     Reason:      The API has to be compatible to a common prototype, defined by module's design to serve generic purposes.
     Risk:        None.
     Prevention:  None.

   MD_Dcm_Understand_0841:
     Description: Rule 19.6
                  #undef shall not be used
     Reason:      Use for better code readability.
     Risk:        None due to no small scope of definition and undefinition of a switch.
     Prevention:  None.

   MD_Dcm_StructMemberAbstr_3410:
     Description: Rule 19.10
                  In the definition of a function-like macro each instance of a parameter shall be enclosed in parentheses unless it is used as the operand of # or ##.
     Reason:      This is aspecial deviation in order to make dynamic structure member reference: #define a(idx, member)  (myStruct[idx].Member).
     Risk:        Compile error will occur if the macro parameter is enclosed in ().
     Prevention:  None.

   MD_Dcm_Optimize_0750:
     Description: Rule 18.4
                  Unions shall not be used
     Reason:      Data without shared lifetime is stored in union for efficiency.
     Risk:        None due to no shared lifetime.
     Prevention:  None.

  MD_Dcm_Consistency_0342:
     Description: Rule 19.13
                  The # and ## preprocessor operators should not be used.
     Reason:      Simplifies and improves the consistency on for function name convention change withi AR releases.
     Risk:        If a preprocessor does not support this ISO operator, then a compile error will occur.
     Prevention:  Compiler compatibility is tested during integration.

  MD_Dcm_BitNegation_0290:
     Description: Rule 21.1
                  Minimisation of run-time failures shall be ensured by the use of at least one of (a) static analysis
                  tools/techniques; (b) dynamic analysis tools/techniques; (c) explicit coding of checks to handle
                  run-time faults.
     Reason:      False positive due to insufficient data flow analysis. Despite thorough review no defect could be
                  recognized.
     Risk:        None.
     Prevention:  None.

  MD_Dcm_BitNegation_0291:
     Description: Rule 21.1
                  Minimisation of run-time failures shall be ensured by the use of at least one of (a) static analysis
                  tools/techniques; (b) dynamic analysis tools/techniques; (c) explicit coding of checks to handle
                  run-time faults.
     Reason:      False positive due to insufficient data flow analysis. Despite thorough review no defect could be
                  recognized.
     Risk:        None.
     Prevention:  None.

  MD_Dcm_Optimize_2003:
     Description: Rule 15.2
                  The preceding non-empty 'case' or 'default' clause does not end with an explicit 'break' or 'return' statement.
     Reason:      To use optimal design small switch-case dispatchers use fall-through cases.
     Risk:        None, since documented as an explicit fall-through case.
     Prevention:  None.

  MD_Dcm_RteSpecific_1330:
     Description: Rule 16.4
                  The parameter identifiers in this function declaration differ from those in a previous declaration.
     Reason:      The function declaration generated by the RTE are RTE-implementation specific and unknown at the DCM development time.
     Risk:        None.
     Prevention:  None.

  MD_Dcm_Design_6060:
     Description: Metric STPAR
                  Number of function parameters defined by HIS shall be in range 0..5.
     Reason:      DCM uses flyweight pattern to minimize shared resource management complexity and risks of overwritten RAM.
                  This pattern requires more input data in comparison with functions with access to global RAM.
     Risk:        Stack usage and runtime too high for target uC.
     Prevention:  Use local inline functions to minimize stack and run-time usage.
*/
/* ----------------------------------------------
 ~&&&   COVERAGE
---------------------------------------------- */
/* COV_JUSTIFICATION_BEGIN

\ID COV_DCM_MACRO_OVERRIDE
  \ACCEPT TX
  \ACCEPT XF
  \REASON The value of a macro may be overridden by user config for test purposes. Since this is not officially
          supported, it is not covered by the test suite.

\ID COV_DCM_UNSUPPORTED
  \REASON [COV_MSR_UNSUPPORTED]

\ID COV_DCM_SUPPORT_PARTIALLY
  \REASON [COV_MSR_UNSUPPORTED]

\ID COV_DCM_SUPPORT_ALWAYS
  \REASON This configuration switch is always on, but the code is enclosed in a pre-processor precondition for consistency reasons and safe future changes.

\ID COV_DCM_SUPPORT_RESTRICTED
  \REASON This configuration switch is always on/ff, due to feature range limitation.

\ID COV_DCM_SUPPORT_WITH_MSR_DEM
  \REASON This configuration switch is always on as long as MSR4 DEM is used (required for SafeBSW context).

\ID COV_DCM_REQUIRED_BY_SAFEBSW
  \REASON This configuration switch is always on as requried by SafeBSW context.

\ID COV_DCM_DEPENDS_ON_UNSUPPORTED
  \REASON This configuration switch is always on/off due to a justified expression it is involved in.

\ID COV_DCM_RTM_NO_RCR_RP_TX
  \ACCEPT XX
  \REASON The justified object is unreachable, since the configuration does not support any feature that could use it.
          A complete encapsulation of all use-cases where no RCR-RP will be sent would be too complex and risky.

\ID COV_DCM_DEV_DEBUG
  \REASON The justified object is uncovered, since it is only used during component development to ease the detection of errors!

\ID COV_DCM_RTM_DEV_DEBUG
  \REASON [COV_DCM_DEV_DEBUG]

\ID COV_DCM_RTM_UNREACHABLE
  \REASON The justified object is uncovered, since it is not intended to be reached! It just exists because of other reasons like MISRA (default case in a switch)
          or because of added debug assert monitorig for development purposes (see COV_DCM_RTM_DEV_DEBUG).

\ID COV_DCM_RTM_UNREACHABLE_COMPLEXITY
  \REASON The justified object is uncovered, since it can be reached only in very rare situations (i.e. interrupt, multiple events in a specific sequence, etc.)!
          But at the same time it is part of the (sub-)component design and cannot be removed.

\ID COV_DCM_RTM_DESIGN_LOWER_LAYER
  \REASON The justified object is uncovered, since it is a basic (lower layer) functionality and is designed to behave in different situations.
          These situations are not necessarily supported by all configurations. Due to the high complexity of dependend functionalities
          the concrete usage of the uncovered functionality is left to the upper layers in DCM!

\ID COV_DCM_RTM_DEPENDS_ON_UNSUPPORTED
  \REASON The justified object is uncovered, since it can vary only if a specific (non supported in SafeBSW context) configuration is activated.

COV_JUSTIFICATION_END */
/* ----------------------------------------------
 ~&&&   SafeBSW
---------------------------------------------- */
/* SBSW_JUSTIFICATION_BEGIN

\ID SBSW_DCM_EXT_API_PARAM_PTR_WRITE_VERSIONINFO
  \DESCRIPTION    The function "Dcm_GetVersionInfo" writes to the object referenced by parameter "versionInfo".
  \COUNTERMEASURE \N The caller ensures that the pointers passed to the parameter "versionInfo" is valid.

\ID SBSW_DCM_EXT_API_PARAM_PTR_WRITE_ACTIVEPROTOCOL
  \DESCRIPTION    The function "Dcm_GetActiveProtocol" writes to the object referenced by parameter "ActiveProtocol".
  \COUNTERMEASURE \N The caller ensures that the pointers passed to the parameter "ActiveProtocol" is valid.

\ID SBSW_DCM_EXT_API_PARAM_PTR_PASSED_THROUGH
  \DESCRIPTION    The externally called DCM API passes the externally set pointer parameter to an internal API for further processing.
                  It is checked against NULL, but this does not guarantee that the referenced memory is valid.
  \COUNTERMEASURE \S [CM_DCM_EXT_API_POINTER]

\ID SBSW_DCM_INT_API_PARAM_PTR_WRITE
  \DESCRIPTION    The internally called DCM API performs a writes access to memory location addressed by the passed pointer parameter.

  \COUNTERMEASURE \S [CM_DCM_INT_API_POINTER]

\ID SBSW_DCM_INT_API_PARAM_PTR_PASSED_THROUGH
  \DESCRIPTION    The internally called DCM API passes the pointer parameter to another internal API for further processing.

  \COUNTERMEASURE \N [CM_DCM_INT_API_POINTER]

\ID SBSW_DCM_ALLOC_TRANSP_OBJECT_WRITE
  \DESCRIPTION    An internal DCM function performs write access on a dynamically allocated or directly linked transport object.

  \COUNTERMEASURE \R [CM_DCM_RTM_ALLOC_TRANSP_OBJECT_USAGE]
                  \M [CM_DCM_MSSV_ALLOC_TRANSP_OBJECT_USAGE]

\ID SBSW_DCM_ALLOC_TRANSP_OBJECT_PASS_THROUGH
  \DESCRIPTION    An internal DCM function passes a dynamically allocated or directly linked transport object to another function.

  \COUNTERMEASURE \R [CM_DCM_RTM_ALLOC_TRANSP_OBJECT_USAGE]
                  \M [CM_DCM_MSSV_ALLOC_TRANSP_OBJECT_USAGE]

SBSW_JUSTIFICATION_END */

/*

\CM CM_DCM_EXT_API_POINTER Describe in the Safety Manual that pointers passed to a DCM API must point to a defined memory range.

\CM CM_DCM_INT_API_POINTER Any pointer passed from internal API to another internal API shall be validated in the very first caller.
                           To be covered by code inspection.

\CM CM_DCM_RTM_ALLOC_TRANSP_OBJECT_USAGE  Each time a transport object is allocated (Dcm_NetAllocateOrGetTranspObject()), its validity (allocation succeeded/failed) is verified.
                           In case of static associtation (1:1 each DCM connection has a dedicated transport object or single transport object (shared among all connections)),
                           the transport object validity is guaranteed.

\CM CM_DCM_MSSV_ALLOC_TRANSP_OBJECT_USAGE Verify that DCM_NET_MAX_NUM_TRANSP_OBJECTS <= DCM_NET_MAX_NUM_CONNECTIONS

*/
/* ********************************************************************************************************************
 * END OF FILE: Dcm.c
 * ******************************************************************************************************************** */
